
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>ARM_AssyLang.pdf - StudyBuddy Flipbook</title>
            <style>
                body {
                    margin: 0;
                    padding: 20px;
                    font-family: Arial, sans-serif;
                    background: #f5f5f5;
                }
                .flipbook-container {
                    max-width: 800px;
                    margin: 0 auto;
                    background: white;
                    border-radius: 8px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    overflow: hidden;
                }
                .flipbook-header {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 20px;
                    text-align: center;
                }
                .flipbook-content {
                    padding: 20px;
                    line-height: 1.6;
                    white-space: pre-wrap;
                }
                .page-info {
                    background: #f8f9fa;
                    padding: 10px;
                    text-align: center;
                    border-top: 1px solid #dee2e6;
                }
            </style>
        </head>
        <body>
            <div class="flipbook-container">
                <div class="flipbook-header">
                    <h1>ARM_AssyLang.pdf</h1>
                    <p>StudyBuddy Interactive Document</p>
                </div>
                <div class="flipbook-content">
                    School of Design, Engineering & Computing
BSc (Hons) Computing
BSc (Hons) Soft w are Engineering Managemen t
ARM: Assembl y Language Pr ogramming
Peter Kna ggs
and
Stephen Welsh
August 31, 2004

Contents
Con ten ts i
List of Programs vii
Preface ix
1 In tro duction 1
1.1 The Meaning of Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1.1 Binary Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 A Computer Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.3 The Binary Programming Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.4 Using Octal or Hexadecimal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.5 Instruction Co de Mnemonics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.6 The Assem bler Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.6.1 A dditional F eatures of Assem blers . . . . . . . . . . . . . . . . . . . . . . . 4
1.6.2 Cho osing an Assem bler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.7 Disadv an tages of Assem bly Language . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.8 High-Lev el Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.8.1 A dv an tages of High-Lev el Languages . . . . . . . . . . . . . . . . . . . . . . 6
1.8.2 Disadv an tages of High-Lev el Languages . . . . . . . . . . . . . . . . . . . . 7
1.9 Whic h Lev el Should Y ou Use? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.9.1 Applications for Mac hine Language . . . . . . . . . . . . . . . . . . . . . . . 8
1.9.2 Applications for Assem bly Language . . . . . . . . . . . . . . . . . . . . . . 8
1.9.3 Applications for High-Lev el Language . . . . . . . . . . . . . . . . . . . . . 8
1.9.4 Other Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.10 Wh y Learn Assem bler? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2 Assem blers 11
2.1 Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1.1 Delimiters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1.2 Lab els . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2 Op eration Co des (Mnemonics) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.3 Directiv es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.3.1 The DEFINE CONST ANT (Data) Directiv e . . . . . . . . . . . . . . . . . 14
2.3.2 The EQUA TE Directiv e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.3.3 The AREA Directiv e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.3.4 Housek eeping Directiv es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.5 When to Use Lab els . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.4 Op erands and A ddresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.4.1 Decimal Num b ers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.4.2 Other Num b er Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.4.3 Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.4.4 Character Co des . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
i
ii CONTENTS
2.4.5 Arithmetic and Logical Expressions . . . . . . . . . . . . . . . . . . . . . . 18
2.4.6 General Recommendations . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.5 Commen ts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.6 T yp es of Assem blers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.7 Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.8 Loaders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
3 ARM Arc hitecture 23
3.1 Pro cessor mo des . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.2 Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.2.1 The stac k p oin ter, SP or R 13 . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.2.2 The Link Register, LR or R 14 . . . . . . . . . . . . . . . . . . . . . . . . . . 27
3.2.3 The program coun ter, PC or R 15 . . . . . . . . . . . . . . . . . . . . . . . . 27
3.2.4 Curren t Pro cessor Status Registers: CPSR . . . . . . . . . . . . . . . . . . . 28
3.3 Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.4 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.5 Instruction Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.5.1 Conditional Execution: /angbracketleft c c/angbracketright . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.5.2 Data Pro cessing Op erands: /angbracketleft op1/angbracketright . . . . . . . . . . . . . . . . . . . . . . . 32
3.5.3 Memory A ccess Op erands: /angbracketleft op2/angbracketright . . . . . . . . . . . . . . . . . . . . . . . . 34
4 Instruction Set 37
4.0.4 Branc h instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.0.5 Data-pro cessing instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.0.6 Status register transfer instructions . . . . . . . . . . . . . . . . . . . . . . . 39
4.0.7 Load and store instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.0.8 Copro cessor instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.0.9 Exception-generating instructions . . . . . . . . . . . . . . . . . . . . . . . . 41
4.0.10 Conditional Execution: /angbracketleft c c/angbracketright . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
5 A ddressing Mo des 45
5.1 Data Pro cessing Op erands: /angbracketleft op1/angbracketright . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.1.1 Unmo died V alue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.1.2 Logical Shift Left . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.1.3 Logical Shift Righ t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.1.4 Arithmetic Shift Righ t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.1.5 Rotate Righ t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.1.6 Rotate Righ t Extended . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.2 Memory A ccess Op erands: /angbracketleft op2/angbracketright . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.2.1 Oset A ddressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
5.2.2 Pre-Index A ddressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
5.2.3 P ost-Index A ddressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
6 Programs 51
6.1 Example Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
6.1.1 Program Listing F ormat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
6.1.2 Guidelines for Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
6.2 T rying the examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
6.3 T rying the examples from the command line . . . . . . . . . . . . . . . . . . . . . . 53
6.3.1 Setting up T extP ad . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
6.4 Program Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
6.5 Sp ecial Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
6.6 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
CONTENTS iii
7 Data Mo v emen t 57
7.1 Program Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
7.1.1 16-Bit Data T ransfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
7.1.2 One's Complemen t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
7.1.3 32-Bit A ddition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
7.1.4 Shift Left One Bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
7.1.5 Byte Disassem bly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
7.1.6 Find Larger of T w o Num b ers . . . . . . . . . . . . . . . . . . . . . . . . . . 62
7.1.7 64-Bit A dition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
7.1.8 T able of F actorials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
7.2 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
7.2.1 64-Bit Data T ransfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
7.2.2 32-Bit Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
7.2.3 Shift Righ t Three Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
7.2.4 Halfw ord Assem bly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
7.2.5 Find Smallest of Three Num b ers . . . . . . . . . . . . . . . . . . . . . . . . 66
7.2.6 Sum of Squares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
7.2.7 Shift Left n bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
8 Logic 69
9 Program Lo ops 71
9.1 Program Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
9.1.1 Sum of n um b ers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
9.1.2 Num b er of negativ e elemen ts . . . . . . . . . . . . . . . . . . . . . . . . . . 73
9.1.3 Find Maxim um V alue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
9.1.4 Normalize A Binary Num b er . . . . . . . . . . . . . . . . . . . . . . . . . . 75
9.2 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
9.2.1 Chec ksum of data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
9.2.2 Num b er of Zero, P ositiv e, and Negativ e n um b ers . . . . . . . . . . . . . . . 77
9.2.3 Find Minim um . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
9.2.4 Coun t 1 Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
9.2.5 Find elemen t with most 1 bits . . . . . . . . . . . . . . . . . . . . . . . . . 77
10 Strings 79
10.1 Handling data in ASCI I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
10.2 A string of c haracters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
10.2.1 Fixed Length Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
10.2.2 T erminated Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
10.2.3 Coun ted Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
10.3 In ternational Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
10.4 Program Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
10.4.1 Length of a String of Characters . . . . . . . . . . . . . . . . . . . . . . . . 82
10.4.2 Find First Non-Blank Character . . . . . . . . . . . . . . . . . . . . . . . . 84
10.4.3 Replace Leading Zeros with Blanks . . . . . . . . . . . . . . . . . . . . . . . 84
10.4.4 A dd Ev en P arit y to ASCI I Chatacters . . . . . . . . . . . . . . . . . . . . . 85
10.4.5 P attern Matc h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
10.5 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
10.5.1 Length of a T elet yp ewriter Message . . . . . . . . . . . . . . . . . . . . . . 88
10.5.2 Find Last Non-Blank Character . . . . . . . . . . . . . . . . . . . . . . . . . 88
10.5.3 T runcate Decimal String to In teger F orm . . . . . . . . . . . . . . . . . . . 88
10.5.4 Chec k Ev en P arit y and ASCI I Characters . . . . . . . . . . . . . . . . . . . 89
10.5.5 String Comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
iv CONTENTS
11 Co de Con v ersion 91
11.1 Program Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
11.1.1 Hexadecimal to ASCI I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
11.1.2 Decimal to Sev en-Segmen t . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
11.1.3 ASCI I to Decimal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
11.1.4 Binary-Co ded Decimal to Binary . . . . . . . . . . . . . . . . . . . . . . . . 94
11.1.5 Binary Num b er to ASCI I String . . . . . . . . . . . . . . . . . . . . . . . . 95
11.2 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
11.2.1 ASCI I to Hexadecimal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
11.2.2 Sev en-Segmen t to Decimal . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
11.2.3 Decimal to ASCI I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
11.2.4 Binary to Binary-Co ded-Decimal . . . . . . . . . . . . . . . . . . . . . . . . 97
11.2.5 P ac k ed Binary-Co ded-Decimal to Binary String . . . . . . . . . . . . . . . . 97
11.2.6 ASCI I string to Binary n um b er . . . . . . . . . . . . . . . . . . . . . . . . . 97
12 Arithmetic 99
12.1 Program Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
12.1.2 64-Bit A ddition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
12.1.3 Decimal A ddition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
12.1.4 Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
12.1.5 32-Bit Binary Divide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
12.2 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
12.2.1 Multiple precision Binary subtraction . . . . . . . . . . . . . . . . . . . . . 103
12.2.2 Decimal Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
12.2.3 32-Bit b y 32-Bit Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
13 T ables and Lists 105
13.1 Program Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
13.1.1 A dd En try to List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
13.1.2 Chec k an Ordered List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
13.1.3 Remo v e an Elemen t from a Queue . . . . . . . . . . . . . . . . . . . . . . . 107
13.1.4 Sort a List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
13.1.5 Using an Ordered Jump T able . . . . . . . . . . . . . . . . . . . . . . . . . 109
13.2 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
13.2.1 Remo v e En try from List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
13.2.2 A dd En try to Ordered List . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
13.2.3 A dd Elemen t to Queue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
13.2.4 4-Byte Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
13.2.5 Using a Jump T able with a Key . . . . . . . . . . . . . . . . . . . . . . . . 110
14 The Stac k 111
15 Subroutines 113
15.1 T yp es of Subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
15.2 Subroutine Do cumen tation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
15.3 P arameter P assing T ec hniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
15.3.1 P assing P arameters In Registers . . . . . . . . . . . . . . . . . . . . . . . . 114
15.3.2 P assing P arameters In A P arameter Blo c k . . . . . . . . . . . . . . . . . . . 115
15.3.3 P assing P arameters On The Stac k . . . . . . . . . . . . . . . . . . . . . . . 115
15.4 T yp es Of P arameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
15.5 Program Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
15.6 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
15.6.1 ASCI I Hex to Binary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
15.6.2 ASCI I Hex String to Binary W ord . . . . . . . . . . . . . . . . . . . . . . . 123
CONTENTS v
15.6.3 T est for Alphab etic Character . . . . . . . . . . . . . . . . . . . . . . . . . . 123
15.6.4 Scan to Next Non-alphab etic . . . . . . . . . . . . . . . . . . . . . . . . . . 123
15.6.5 Chec k Ev en P arit y . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
15.6.6 Chec k the Chec ksum of a String . . . . . . . . . . . . . . . . . . . . . . . . 124
15.6.7 Compare T w o Coun ted Strings . . . . . . . . . . . . . . . . . . . . . . . . . 124
16 In terrupts and Exceptions 125
A ARM Instruction Denitions 127
A.1 ADC: A dd with Carry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
A.2 ADD: A dd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
A.3 AND: Bit wise AND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
A.4 B, BL: Branc h, Branc h and Link . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
A.5 CMP: Compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
A.6 EOR: Exclusiv e OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
A.7 LDM: Load Multiple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
A.8 LDR: Load Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
A.9 LDRB: Load Register Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
A.10 MO V: Mo v e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
A.11 MVN: Mo v e Negativ e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
A.12 ORR: Bit wise OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
A.13 SBC: Subtract with Carry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
A.14 STM: Store Multiple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
A.15 STR: Store Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
A.16 STRB: Store Register Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
A.17 SUB: Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
A.18 SWI: Soft w are In terrupt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
A.19 SWP: Sw ap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
A.20 SWPB: Sw ap Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
B ARM Instruction Summary 139
vi CONTENTS
List of Programs
7.1 move16.s 16bit data transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
7.2 invert.s Find the one's complimen t (in v erse) of a n um b er . . . . . . . . . . . . 58
7.3a add.s A dd t w o n um b ers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
7.3b add2.s A dd t w o n um b ers and store the result . . . . . . . . . . . . . . . . . . 59
7.4 shiftleft.s Shift Left one bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
7.5 nibble.s Disassem ble a b yte in to its high and lo w order nibbles . . . . . . . . . 61
7.6 bigger.s Find the larger of t w o n um b ers . . . . . . . . . . . . . . . . . . . . . . 62
7.7 add64.s 64 bit addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
7.8 factorial.s Lo okup the factorial from a table b y using the address of the memory
lo cation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
8.7a bigger.s Find the larger of t w o n um b ers . . . . . . . . . . . . . . . . . . . . . . 69
8.7a add64.s 64 bit addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
8.7a factorial.s Lo okup the factorial from a table b y using the address of the memory
lo cation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
9.1a sum16.s A dd a series of 16 bit n um b ers b y using a table address . . . . . . . . 72
9.1b sum16b.s A dd a series of 16 bit n um b ers b y using a table address lo ok-up . . . 72
9.2a countneg.s Scan a series of 32 bit n um b ers to nd ho w man y are negativ e . . . . 73
9.2b countneg16.s Scan a series of 16 bit n um b ers to nd ho w man y are negativ e . . . . 74
9.3 largest16.s Scan a series of 16 bit n um b ers to nd the largest . . . . . . . . . . . 75
9.4 normalize.s Normalize a binary n um b er . . . . . . . . . . . . . . . . . . . . . . . . 75
10.1a strlencr.s Find the length of a Carage Return terminated string . . . . . . . . . 82
10.1b strlen.s Find the length of a n ull terminated string . . . . . . . . . . . . . . . 83
10.2 skipblanks.s Find rst non-blank . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
10.3 padzeros.s Supress leading zeros in a string . . . . . . . . . . . . . . . . . . . . . 84
10.4 setparity.s Set the parit y bit on a series of c haracters store the amended string in
Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
10.5a cstrcmp.s Compare t w o coun ted strings for equalit y . . . . . . . . . . . . . . . . 86
10.5b strcmp.s Compare n ull terminated strings for equalit y assume that w e ha v e no
kno wledge of the data structure so w e m ust assess the individual strings 87
11.1a nibtohex.s Con v ert a single hex digit to its ASCI I equiv alen t . . . . . . . . . . . 91
11.1b wordtohex.s Con v ert a 32 bit hexadecimal n um b er to an ASCI I string and output
to the terminal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
11.2 nibtoseg.s Con v ert a decimal n um b er to sev en segmen t binary . . . . . . . . . . 92
11.3 dectonib.s Con v ert an ASCI I n umeric c haracter to decimal . . . . . . . . . . . . 93
11.4a ubcdtohalf.s Con v ert an unpac k ed BCD n um b er to binary . . . . . . . . . . . . . . 94
11.4b ubcdtohalf2.s Con v ert an unpac k ed BCD n um b er to binary using MUL . . . . . . . 94
11.5 halftobin.s Store a 16bit binary n um b er as an ASCI I string of '0's and '1's . . . . 95
12.2 add64.s 64 Bit A ddition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
vii
viii LIST OF PR OGRAMS
12.3 addbcd.s A dd t w o pac k ed BCD n um b ers to giv e a pac k ed BCD result . . . . . 100
12.4a mul16.s 16 bit binary m ultiplication . . . . . . . . . . . . . . . . . . . . . . . . 101
12.4b mul32.s Multiply t w o 32 bit n um b er to giv e a 64 bit result (corrupts R0 and R1) 101
12.5 divide.s Divide a 32 bit binary no b y a 16 bit binary no store the quotien t and
remainder there is no 'DIV' instruction in ARM! . . . . . . . . . . . . 102
13.1a insert.s Examine a table for a matc h - store a new en try at the end if no matc h
found . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
13.1b insert2.s Examine a table for a matc h - store a new en try if no matc h found
extends insert.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
13.2 search.s Examine an ordered table for a matc h . . . . . . . . . . . . . . . . . . 106
13.3 head.s Remo v e the rst elemen t of a queue . . . . . . . . . . . . . . . . . . . 107
13.4 sort.s Sort a list of v alues  simple bubble sort . . . . . . . . . . . . . . . . . 108
15.1a init1.s Initiate a simple stac k . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
15.1b init2.s Initiate a simple stac k . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
15.1c init3.s Initiate a simple stac k . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
15.1d init3a.s Initiate a simple stac k . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
15.1e byreg.s A simple subroutine example program passes a v ariable to the routine
in a register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
15.1f bystack.s A more complex subroutine example program passes v ariables to the
routine using the stac k . . . . . . . . . . . . . . . . . . . . . . . . . . 119
15.1g add64.s A 64 bit addition subroutine . . . . . . . . . . . . . . . . . . . . . . . 121
15.1h factorial.s A subroutine to nd the factorial of a n um b er . . . . . . . . . . . . . 122
Preface
Broadly sp eaking, y ou can divide the history of computers in to four p erio ds: the mainframe, the
mini, the micropro cessor, and the mo dern p ost-micropro cessor. The mainfr ame era w as c harac-
terized b y computers that required large buildings and teams of tec hnicians and op erators to k eep
them going. More often than not, b oth academics and studen ts had little direct con tact with the
mainframey ou handed a dec k of punc hed cards to an op erator and w aited for the output to ap-
p ear hours later. During the mainfame era, academics concen trated on languages and compilers,
algorithms, and op erating systems.
The minic omputer era put computers in the hands of studen ts and academics, b ecause univ ersit y
departmen ts could no w buy their o wn minis. As minicomputers w ere not as complex as main-
frames and b ecause studen ts could get direct hands-on exp erience, man y departmen ts of computer
science and electronic engineering taugh t studen ts ho w to program in the nativ e language of the
computerassem bly language. In those da ys, the mid 1970s, assem bly language programming
w as used to teac h b oth the con trol of I/O devices, and the writing of programs (i.e., assem bly
language w as taugh t rather lik e high lev el languages). The explosion of computer soft w are had
not tak en place, and if y ou w an ted soft w are y ou had to write it y ourself.
The late 1970s sa w the in tro duction of the micr opr o c essor . F or the rst time, eac h studen t w as
able to access a real computer. Unfortunately , micropro cessors app eared b efore the in tro duction
of lo w-cost memory (b oth primary and secondary). Studen ts had to program micropro cessors
in assem bly language b ecause the only storage mec hanism w as often a R OM with just enough
capacit y to hold a simple single-pass assem bler.
The adv en t of the lo w-cost micropro cessor system (usually on a single b oard) ensured that virtually
ev ery studen t to ok a course on assem bly language. Ev en to da y , most courses in computer science
include a mo dule on computer arc hitecture and organization, and teac hing studen ts to write
programs in assem bly language forces them to understand the computer's arc hitecture. Ho w ev er,
some computer scien tists who had b een educated during the mainframe era w ere unhapp y with
the micropro cessor, b ecause they felt that the 8-bit micropro cessor w as a retrograde stepits
arc hitecture w as far more primitiv e than the mainframes they had studied in the 1960s.
The 1990s is the p ost-micr opr o c essor era. T o da y's p ersonal computers ha v e more p o w er and
storage capacit y than man y of y esterda y's mainframes, and they ha v e a range of p o w erful soft w are
to ols that w ere undreamed of in the 1970s. Moreo v er, the computer science curriculum of the
1990s has explo ded. In 1970 a studen t could b e exp ected to b e familiar with all eld of computer
science. T o da y , a studen t can b e exp ected only to bro wse through the highligh ts.
The a v ailabilit y of high-p erformance hardw are and the driv e to include more and more new ma-
terial in the curriculum, has put pressure on academics to justify what they teac h. In particular,
man y are questioning the need for courses on assem bly language.
If y ou regard computer science as b eing primarily concerned with the use of the computer, y ou
can argue that assem bly language is an irrelev ance. Do es the surgeon study metallurgy in order
to understand ho w a scalp el op erates? Do es the pilot study thermo dynamics to understand ho w
a jet engine op erates? Do es the news reader study electronics to understand ho w the camera
ix
x PREF A CE
op erates? The answ er to all these questions is  no . So wh y should w e inict assem bly language
and computer arc hitecture on the studen t?
First, e duc ation is not the same as tr aining . The studen t of computer science is not simply b eing
trained to use a n um b er of computer pac k ages. A univ ersit y course leading to a degree should
also co v er the history and the the or etic al b asis for the sub ject. Without a kno wledge of computer
arc hitecture, the computer scien tist cannot understand ho w computers ha v e dev elop ed and what
they are capable of.
Is assem bly language to da y the same as assem bly language y esterda y?
T w o factors ha v e inuenced the w a y in whic h w e teac h assem bly languageone is the w a y in whic h
micropro cessors ha v e c hanged, and the other is the use to whic h assem bly language teac hing is
put. Ov er the y ears micropro cessors ha v e b ecome more and more complex, with the result that
the arc hitecture and assem bly language of a mo dern state-of-the-art micropro cessor is radically
dieren t to that of an 8-bit mac hine of the late 1970s. When w e rst taugh t assem bly language in
the 1970s and early 1980s, w e did it to demonstrate ho w computers op erated and to giv e studen ts
hands-on exp erience of a computer. Since all studen ts either ha v e their o wn computer or ha v e ac-
cess to a computer lab, this role of the single-b oard computer is no w obsolete. Moreo v er, assem bly
language programming once attempted to ap e high-lev el language programming studen ts w ere
taugh t algorithms suc h as sorting and searc hing in assem bly language, as if assem bly language
w ere no more than the (desp erately) p o or p erson's C.
The argumen t for teac hing assem bly language programming to da y can b e divided in to t w o com-
p onen ts: the underpinning of computer arc hitecture and the underpinning of computer soft w are.
Assem bly language teac hes ho w a computer w orks at the mac hine (i.e., register) lev el. It is there-
fore necessary to teac h assem bly language to all those who migh t later b e in v olv ed in computer
arc hitectureeither b y sp ecifying computers for a particular application, or b y designing new
arc hitectures. Moreo v er, the v on Neumann mac hine's sequen tial nature teac hes studen ts the limi-
tation of con v en tional arc hitectures and, indirectly , leads them on to uncon v en tional arc hitectures
(parallel pro cessors, Harv ard arc hitectures, data o w computers, and ev en neural net w orks).
It is probably in the realm of soft w are that y ou can most easily build a case for the teac hing of
assem bly language. During a studen t's career, he or she will encoun ter a lot of abstr act concepts in
sub jects ranging from programming languages, to op erating systems, to real-time programming,
to AI. The foundation of man y of these concepts lies in assem bly language programming and
computer arc hitecture. Y ou migh t ev en sa y that assem bly language pro vides b ottom-up supp ort
for the top-down metho dology w e teac h in high-lev el languages. Consider some of the follo wing
examples (tak en from the teac hing of A dv anced RISC Mac hines Ltd (ARM) assem bly language).
Data t yp es
Studen ts come across data t yp es in high-lev el languages and the eects of strong and w eak
data t yping. T eac hing an assem bly language that can op erate on bit, b yte, w ord and long
w ord op erands helps studen ts understand data t yp es. Moreo v er, the abilit y to p erform an y
t yp e of assem bly language op eration on an y t yp e of data structure demonstrates the need
for strong t yping.
A ddressing mo des
A vital comp onen t of assem bly language teac hing is addressing mo des (literal, direct, and
indirect). The studen t learns ho w p oin ters function and ho w p oin ters are manipulated. This
asp ect is particularly imp ortan t if the studen t is to b ecome a C programmer. Because an
assem bly language is unencum b ered b y data t yp es, the studen ts' view of p oin ters is m uc h
simplied b y an assem bly language. The ARM has complex addressing mo des that supp ort
direct and indirect addressing, generated jump tables and handling of unkno wn memory
osets.
PREF A CE xi
The stac k and subroutines
Ho w pro cedures are called, and parameters passed and returned from pro cedures. By using
an assem bly language y ou can readily teac h the passing of parameters b y value and b y
r efer enc e . The use of lo c al variables and r e-entr ant programming can also b e taugh t. This
supp orts the teac hing of task switc hing k ernels in b oth op erating systems and real-time
programming.
Recursion
The recursiv e calling of subroutines often causes a studen t problems. Y ou can use an assem-
bly language, together with a suitable system with a tracing facilit y , to demonstrate ho w
recursion op erates. The studen t can actually observ e ho w the stac k gro ws as pro cedures are
called.
Run-time supp ort for high-lev el languages
A high-p erformance pro cessor lik e the ARM pro vides facilities that supp ort run-time c hec k-
ing in high-lev el languages. F or example, the programming tec hniques do cumen t lists a
series of programs that in terface with 'C' and pro vide run-time c hec king for errors suc h as
an attempt to divide a n um b er b y zero.
Protected-mo de op eration
Mem b ers of the ARM family op erate in either a privile dge mo de or a user mo de . The
op erating system op erates in the priviledge mo de and all user (applications) programs run in
the user mo de. This mec hanism can b e used to construct se cur e or pr ote cte d en vironmen ts in
whic h the eects of an error in one application can b e prev en ted from harming the op erating
system (or other applications).
Input-output
Man y high-lev el languages mak e it dicult to access I/O p orts and devices directly . By
using an assem bly language w e can teac h studen ts ho w to write device driv ers and ho w to
con trol in terfaces. Most real in terfaces are still programmed at the mac hine lev el b y accessing
registers within them.
All these topics can, of course, b e taugh t in the appropriate courses (e.g., high-lev el languages,
op erating systems). Ho w ev er, b y teac hing them in an assem bly language course, they pa v e the
w a y for future studies, and also sho w the studen t exactly what is happ ening within the mac hine.
Conclusion
A strong case can b e made for the con tin ued teac hing of assem bly language within the computer
science curriculum. Ho w ev er, an assem bly language cannot b e taugh t just as if it w ere another
general-purp ose programming language as it w as once taugh t ten y ears ago. P erhaps more than
an y other comp onen t of the computer science curriculum, teac hing an assem bly language supp orts
a wide range of topics at the heart of computer science. An assem bly language should not b e used
just to illustrate algorithms, but to demonstrate what is actually happ ening inside the computer.
xii PREF A CE
1Introduction
A computer program is ultimately a series of n um b ers and therefore has v ery little meaning to a
h uman b eing. In this c hapter w e will discuss the lev els of h uman-lik e language in whic h a computer
program ma y b e expressed. W e will also discuss the reasons for and uses of assem bly language.
1.1 The Meaning of Instructions
The instruction set of a micropro cessor is the set of binary inputs that pro duce dened actions
during an instruction cycle. An instruction set is to a micropro cessor what a function table is to a
logic device suc h as a gate, adder, or shift register. Of course, the actions that the micropro cessor
p erforms in resp onse to its instruction inputs are far more complex than the actions that logic
devices p erform in resp onse to their inputs.
1.1.1 Binary Instructions
An instruction is a binary digit pattern  it m ust b e a v ailable at the data inputs to the micropro-
cessor at the prop er time in order to b e in terpreted as an instruction. F or example, when the ARM
receiv es the binary pattern 111000000100 as the input during an instruction fetc h op eration, the
pattern means subtract. Similary the microinstruction 111000001000 means add. Th us the 32
bit pattern 11100000010011101100000000001111 means:
 Subtr act R15 fr om R14 and put the answer in R12. 
The micropro cessor (lik e an y other computer) only recognises binary patterns as instructions or
data; it do es not recognise c haracters or o ctal, decimal, or hexadecimal n um b ers.
1.2 A Computer Program
A program is a series of instructions that causes a computer to p erform a particular task.
A ctually , a computer program includes more than instructions, it also con tains the data and the
memory addresses that the micropro cessor needs to accomplish the tasks dened b y the instruc-
tions. Clearly , if the micropro cessor is to p erform an addition, it m ust ha v e t w o n um b ers to add
and a place to put the result. The computer program m ust determine the sources of the data and
the destination of the result as w ell as the op eration to b e p erformed.
All micropro cessors execute instructions sequen tially unless an instruction c hanges the order of
execution or halts the pro cessor. That is, the pro cessor gets its next instruction from the next
higher memory address unless the curren t instruction sp ecically directs it to do otherwise.
Ultimately , ev ery program is a set of binary n um b ers. F or example, this is a snipp et of an ARM
program that adds the con ten ts of memory lo cations 8094 32 and8098 32 and places the result in
memory lo cation 809C32 :
1
2 CHAPTER 1. INTR ODUCTION
11100101100111110001000000010000
11100101100111110001000000001000
11100000100000010101000000000000
11100101100011110101000000001000
This is a mac hine language, or ob ject, program. If this program w ere en tered in to the memory of
an ARM-based micro computer, the micro computer w ould b e able to execute it directly .
1.3 The Binary Programming Problem
There are man y diculties asso ciated with creating programs as ob ject, or binary mac hine lan-
guage, programs. These are some of the problems:
â€¢ The programs are dicult to understand or debug. (Binary n um b ers all lo ok the same,
particularly after y ou ha v e lo ok ed at them for a few hours.)
â€¢ The programs do not describ e the task whic h y ou w an t the computer to p erform in an ything
resem bling a h uman-readable format.
â€¢ The programs are long and tiresome to write.
â€¢ The programmer often mak es careless errors that are v ery dicult to lo cate and correct.
F or example, the follo wing v ersion of the addition ob ject program con tains a single bit error. T ry
to nd it:
11100101100111110001000000010000
11100101100111110001000000001000
11100000100000010101000000000000
11100110100011110101000000001000
Although the computer handles binary n um b ers with ease, p eople do not. P eople nd binary
programs long, tiresome, confusing, and meaningless. Ev en tually , a programmer ma y start re-
mem b ering some of the binary co des, but suc h eort should b e sp en t more pro ductiv ely .
1.4 Using Octal or Hexadecimal
W e can impro v e the situation somewhat b y writing instructions using o ctal or hexadecimal n um-
b ers, rather than binary . W e will use hexadecimal n um b ers b ecause they are shorter, and b ecause
they are the standard for the micropro cessor industry . T able 1.1 denes the hexadecimal digits
and their binary equiv alen ts. The ARM program to add t w o n um b ers no w b ecomes:
E59F1010
E59f0008
E0815000
E58F5008
A t the v ery least, the hexadecimal v ersion is shorter to write and not quite so tiring to examine.
Errors are somewhat easier to nd in a sequence of hexadecimal digits. The erroneous v ersion of
the addition program, in hexadecimal form, b ecomes:
1.5. INSTR UCTION CODE MNEMONICS 3
Hexadecimal Binary Decimal
Digit Equiv alen t Equiv alen t
0 0000 0
1 0001 1
2 0010 2
3 0011 3
4 0100 4
5 0101 5
6 0110 6
7 0111 7
8 1000 8
9 1001 9
A 1010 10
B 1011 11
C 1100 12
D 1101 13
E 1110 14
F 1111 15
T able 1.1: Hexadecimal Con v ersion T able
E59F1010
E59f0008
E0815000
E68F5008
The mistak e is far more ob vious.
The hexadecimal v ersion of the program is still dicult to read or understand; for example, it
do es not distinguish op erations from data or addresses, nor do es the program listing pro vide an y
suggestion as to what the program do es. What do es 3038 or 31C0 mean? Memorising a card full
of co des is hardly an app etising prop osition. F urthermore, the co des will b e en tirely dieren t for
a dieren t micropro cessor and the program will require a large amoun t of do cumen tation.
1.5 Instruction Co de Mnemonics
An ob vious programming impro v emen t is to assign a name to eac h instruction co de. The instruc-
tion co de name is called a  mnemonic  or memory jogger.
In fact, all micropro cessor man ufacturers pro vide a set of mnemonics for the micropro cessor in-
struction set (they cannot remem b er hexadecimal co des either). Y ou do not ha v e to abide b y the
man ufacturer's mnemonics; there is nothing sacred ab out them. Ho w ev er, they are standard for
a giv en micropro cessor, and therefore understo o d b y all users. These are the instruction co des
that y ou will nd in man uals, cards, b o oks, articles, and programs. The problem with selecting
instruction mnemonics is that not all instructions ha v e ob vious names. Some instructions do
(for example, ADD , AND , ORR ), others ha v e ob vious con tractions (suc h as SUB for subtraction, EOR
for exclusiv e-OR), while still others ha v e neither. The result is suc h mnemonics as BIC , STMIA ,
and ev en MRS . Most man ufacturers come up with some reasonable names and some hop eless ones.
Ho w ev er, users who devise their o wn mnemonics rarely do m uc h b etter.
Along with the instruction mnemonics, the man ufacturer will usually assign names to the CPU
registers. As with the instruction names, some register names are ob vious (suc h as A for A ccum u-
lator) while others ma y ha v e only historical signicance. Again, w e will use the man ufacturer's
suggestions simply to promote standardisation.
If w e use standard ARM instruction and register mnemonics, as dened b y A dv anced RISC Ma-
c hines, our ARM addition program b ecomes:
4 CHAPTER 1. INTR ODUCTION
LDR R1, num1
LDR R0, num2
ADD R5, R1, R0
STR R5, num3
The program is still far from ob vious, but at least some parts are comprehensible. ADD is a
considerable impro v emen t o v er E59F . The LDR mnemonic do es suggest loading data in to a register
or memory lo cation. W e no w see that some parts of the program are op erations and others are
addresses. Suc h a program is an assem bly language program.
1.6 The Assem bler Program
Ho w do w e get the assem bly language program in to the computer? W e ha v e to translate it, either
in to hexadecimal or in to binary n um b ers. Y ou can translate an assem bly language program b y
hand, instruction b y instruction. This is called hand assem bly .
The follo wing table illustrates the hand assem bly of the addition program:
Instruction Mnemonic Register/Memory Lo cation Hexadecimal Equiv alen t
LDR R1, num1 E59F1010
LDR R0, num2 E59F0008
ADD R5, R1, R0 E0815000
STR R5, num3 E58F5008
Hand assem bly is a rote task whic h is unin teresting, rep etitiv e, and sub ject to n umerous minor
errors. Pic king the wrong line, transp osing digits, omitting instructions, and misreading the co des
are only a few of the mistak es that y ou ma y mak e. Most micropro cessors complicate the task ev en
further b y ha ving instructions with dieren t lengths. Some instructions are one w ord long while
others ma y b e t w o or three. Some instructions require data in the second and third w ords; others
require memory addresses, register n um b ers, or who kno ws what?
Assem bly is a rote task that w e can assign to the micro computer. The micro computer nev er
mak es an y mistak es when translating co des; it alw a ys kno ws ho w man y w ords and what format
eac h instruction requires. The program that do es this job is an  assembler . The assem bler
program translates a user program, or source program written with mnemonics, in to a mac hine
language program, or ob ject program, whic h the micro computer can execute. The assem bler's
input is a source program and its output is an ob ject program.
Assem blers ha v e their o wn rules that y ou m ust learn. These include the use of certain mark ers
(suc h as spaces, commas, semicolons, or colons) in appropriate places, correct sp elling, the prop er
con trol of information, and p erhaps ev en the correct placemen t of names and n um b ers. These
rules are usually simple and can b e learned quic kly .
1.6.1 A dditional F eatures of Assem blers
Early assem blers did little more than translate the mnemonic names of instructions and registers
in to their binary equiv alen ts. Ho w ev er, most assem blers no w pro vide suc h additional features as:
â€¢ Allo wing the user to assign names to memory lo cations, input and output devices, and ev en
sequences of instructions
â€¢ Con v erting data or addresses from v arious n um b er systems (for example, decimal or hex-
adecimal) to binary and con v erting c haracters in to their ASCI I or EBCDIC binary co des
1.7. DISAD V ANT A GES OF ASSEMBL Y LANGUA GE 5
â€¢ P erforming some arithmetic as part of the assem bly pro cess
â€¢ T elling the loader program where in memory parts of the program or data should b e placed
â€¢ Allo wing the user to assign areas of memory as temp orary data storage and to place xed
data in areas of program memory
â€¢ Pro viding the information required to include standard programs from program libraries, or
programs written at some other time, in the curren t program
â€¢ Allo wing the user to con trol the format of the program listing and the input and output
devices emplo y ed
1.6.2 Cho osing an Assem bler
All of these features, of course, in v olv e additional cost and memory . Micro computers generally
ha v e m uc h simpler assem blers than do larger computers, but the tendency is alw a ys for the size of
assem blers to increase. Y ou will often ha v e a c hoice of assem blers. The imp ortan t criterion is not
ho w man y o-b eat features the assem bler has, but rather ho w con v enien t it is to use in normal
practice.
1.7 Disadv an tages of Assem bly Language
The assem bler do es not solv e all the problems of programming. One problem is the tremendous gap
b et w een the micro computer instruction set and the tasks whic h the micro computer is to p erform.
Computer instructions tend to do things lik e add the con ten ts of t w o registers, shift the con ten ts
of the A ccum ulator one bit, or place a new v alue in the Program Coun ter. On the other hand, a
user generally w an ts a micro computer to do something lik e prin t a n um b er, lo ok for and react to
a particular command from a telet yp ewriter, or activ ate a rela y at the prop er time. An assem bly
language programmer m ust translate suc h tasks in to a sequence of simple computer instructions.
The translation can b e a dicult, time-consuming job.
F urthermore, if y ou are programming in assem bly language, y ou m ust ha v e detailed kno wledge of
the particular micro computer that y ou are using. Y ou m ust kno w what registers and instructions
the micro computers has, precisely ho w the instructions aect the v arious registers, what addressing
metho ds the computer uses, and a mass of other information. None of this information is relev an t
to the task whic h the micro computer m ust ultimately p erform.
In addition, assem bly language programs are not p ortable. Eac h micro computer has its o wn
assem bly language whic h reects its o wn arc hitecture. An assem bly language program written for
the ARM will not run on a 486, P en tium, or Z8000 micropro cessor. F or example, the addition
program written for the Z8000 w ould b e:
LD R0,%6000
ADD R0,%6002
LD %6004,R0
The lac k of p ortabilit y not only means that y ou will not b e able to use y our assem bly language
program on a dieren t micro computer, but also that y ou will not b e able to use an y programs that
w ere not sp ecically written for the micro computer y ou are using. This is a particular dra wbac k
for new micro computers, since few assem bly language programs exist for them. The result, to o
frequen tly , is that y ou are on y our o wn. If y ou need a program to p erform a particular task, y ou
are not lik ely to nd it in the small program libraries that most man ufacturers pro vide. Nor are
y ou lik ely to nd it in an arc hiv e, journal article, or someone's old program File. Y ou will probably
ha v e to write it y ourself.
6 CHAPTER 1. INTR ODUCTION
1.8 High-Lev el Languages
The solution to man y of the diculties asso ciated with assem bly language programs is to use,
insted, high-level or pr o c e dur e-oriente d langauges. Suc h languages allo w y ou to describ e tasks in
forms that are problem-orien ted rather than computer-orien ted. Eac h statemen t in a high-lev el
language p erforms a recognisable function; it will generally corresp ond to man y assem bly language
instruction. A program called a compiler translates the high-lev el language source program in to
ob ject co de or mac hine language instructions.
Man y dieren t hgih-lev el languages exist for dieren t t yp es of tasks. If, for examp e, y ou can
express what y ou w an t the computer to do in algebraic notation, y ou can write y our F ORTRAN
( F or m ula T r an slation Language), the oldest of the high-lev el languages. No w, if y ou w an t to add
t w o n um b ers, y ou just tell the computer:
sum = num1 + num2;
That is a lot simpler (and shorter) than either the equiv alen t mac hine language program or the
equiv alen t assem bly language program. Other high-lev el languages include COBOL (for business
applications), BASIC (a cut do wn v ersion of F ORTRAN designed to protot yp e ideas b efore co deing
them in full), C (a systems-programming language), C++ and JA V A (ob ject-orien tated general
dev elopmen t languages).
1.8.1 A dv an tages of High-Lev el Languages
Clearly , high-lev el languages mak e program easier and faster to write. A common estimate is
that a programmer can write a program ab out ten times as fast in a high-lev el langauge as in
assem bly language. That is just writing the program; it do es not include problem denition,
program design, debugging testing or do cumen tation, all of whic h b ecome simpler and faster. The
high-lev el language program is, for instance, partly self-do cumen ting. Ev en if y ou do not kno w
F ORTRAN , y ou could probably tell what the statemen t illustrated ab o v e do es.
Mac hine Indep endence
High-lev el languages solv e man y other problems asso ciated with assem bly language programming.
The high-lev el language has its o wn syn tax (usually dened b y an in ternational standard). The
language do es not men tion the instruction set, registers, or other features of a particular computer.
The compiler tak es care of all suc h details. Programmers can concen trate on their o wn tasks; they
do not need a detailed understanding of the underlying CPU arc hitecture  for that matter, they
do not need to kno w an ything ab out the computer the are programming.
P ortabilit y
Programs written in a high-lev el language are p ortable  at least, in theory . They will run on
an y computer that has a standard compiler for that language.
A t the same time, all previous programs written in a high-lev el language for prior computers and
a v ailable to y ou when programming a new computer. This can mean thousands of programs in
the case of a common language lik e C .
1.8. HIGH-LEVEL LANGUA GES 7
1.8.2 Disadv an tages of High-Lev el Languages
If all the go o d things w e ha v e said ab out high-lev el languages are true  if y ou can write programs
faster and mak e them p ortable b esides  wh y b other with assebly languages? Who w an ts to
w orry ab out registers, instruction co des, mnemonics, and all that garbage! As usual, there are
disadv an tages that balance the adv an tages.
Syn tax
One ob vious problem is that, as with assem bly language, y ou ha v e to learn the rules or syntax
of an y high-lev el language y ou w an t to use. A high-lev el langauge has a fairly complicated set of
rules. Y ou will nd that it tak es a lot of time just to get a program that is syn tactically correct
(and ev en then it probably will not do what y ou w an t). A high-lev el computer language is lik e
a foreign language. If y ou ha v e talen t, y ou will get used to the rules and b e able to turn out
programs that the compiler will accept. Still, learning the rules and trying to get the program
accepted b y the compiler do es not con tribute directly to doing y our job.
Cost of Compilers
Another ob vious problem is that y ou need a compiler to translate program written in a high-lev el
language in to mac hine language. Compilers are exp ensiv e and use a large amoun t of memory .
While most assem blers o ccup y only a few KBytes of memory , compilers w ould o ccup y far larger
amoun ts of memory . A compiler could easily require o v er four times as m uc h memory as an
assem bler. So the amoun t of o v erhead in v olv ed in using the compiler is rather large.
A dapting T asks to a Language
F urthermore, only some compilers will mak e the implemen tation of y our task simpler. Eac h
language has its o wn target proglem area, for example, F ORTRAN is w ell-suited to problems
that can b e expressed as algebraic form ulas. If ho w ev er, y our problem is con trolling a displa y
terminal, editing a string of c haracters, or monitoring an alarm system, y our problem cannot
b e easily expressed. In fact, form ulating the solution in F ORTRAN ma y b e more a wkw ard and
more dicult than form ulating it in assem bly language. The answ er is, of course, to use a more
suitable high-lev el language. Languages sp ecically designed for tasks suc h as those men tioned
ab o v e do exist  they are called system implemen tation languages. Ho w ev er, these languages are
less widely used.
Ineciency
High-lev el languages do not pro duce v ery ecien t mac hine language program. The basic reason
for this is that compilation is an automatic pro cess whic h is riddled with compromises to allo w for
man y ranges of p ossibilities. The compiler w orks m uc h lik e a computerised language translator 
sometimes the w ords are righ t but the sen tence structures are a wkw ard. A simpler compiler connot
kno w when a v ariable is no longer b eing used and can b e discarded, when a register should b e
used rather than a memory lo cation, or when v ariables ha v e simple relationships. The exp erienced
programmer can tak e adv an tage of shortcuts to shorten execution time or reduce memory usage.
A few compiler (kno wn as optimizing cmpilers) can also do this, but suc h compilers are m uc h
larger than regular compilers.
8 CHAPTER 1. INTR ODUCTION
1.9 Whic h Lev el Should Y ou Use?
Whic h language lev el y ou use dep ends on y our particulr application. Let us briey note some of
the factors whic h ma y fa v or particular lev els:
1.9.1 Applications for Mac hine Language
Virtually no one programs in mac hine language b ecause it w astes h uman time and is dicult to
do cumen t. An assem bler costs v ery little and greatly reduces programming time.
1.9.2 Applications for Assem bly Language
â€¢ Limited data pro cessing â€¢ Short to mo derate-sized programs
â€¢ High-v olume applications â€¢ Application where memory cost is a factor
â€¢ Real-Time con trol applications â€¢ Applications in v olving more input/output
or con trol than computation
1.9.3 Applications for High-Lev el Language
â€¢ Long programs â€¢ Compatibilit y with similar applications
using larger computers
â€¢ Lo w-v olume applications â€¢ Applications in v oling more computation
than input/output or con trol
â€¢ Programs whic h are exp ected â€¢ Applications where the amout of memory
to undergo man y c hanges required is already v ery large
â€¢ A v ailabilit y of a sp ecic program in a high-lev el language whic h can b e used
in the application.
1.9.4 Other Considerations
Man y other factors are also imp ortan t, suc h as the a v ailabilit y of a large computer for use in
dev elopmen t, exp erience with particular languages, and compatibilit y with other applications.
If hardw are will ultimately b e the largest cost in y our application, or if sp eed is critical, y ou should
fa v or assem bly language. But b e prepared to sp end m uc h extra time in soft w are dev elopmen t in
exc hange for lo w er memory costs and higher execution sp eeds. If soft w are will b e the largest cost
in y our application, y ou should fa v or a high-lev el language. But b e prepared to sp end the extra
money required for the supp orting hardw are and soft w are.
Of course, no one except some theorists will ob ject if y ou use b oth assem bly and high-lev el lan-
guages. Y ou can write the program originally in a high-lev el language and then patc h some sections
in assem bly language. Ho w ev er, most users prefer not to do this b ecause it can create ha v o c in
debugging, testing, and do cumen tation.
1.10 Wh y Learn Assem bler?
Giv en the adv ance of high-lev el languages, wh y do y ou need to learn assem bly language program-
ming? The reasons are:
1.10. WHY LEARN ASSEMBLER? 9
1. Most industrial micro computer users program in assem bly language.
2. Man y micro computer users will con tin ue to program in assem bly language since they need
the detailed con trol that it pro vides.
3. No suitable high-lev el language has y et b ecome widely a v ailable or standardised.
4. Man y application require the eciency of assem bly language.
5. An understanding of assem bly language can help in ev aluating high-lev el languages.
6. Almost all micro computer programmers ultimately nd that they need some kno wledge of
assem bly language, most often to debug programs, write I/O routines, sp eed up or shorten
critical sections of programs written in high-lev el languages, utilize or mo dify op erating
system functions, and undertand other p eople's programs.
The rest of these notes will deal exclusiv ely with assem bler and assem bly language programming.
10 CHAPTER 1. INTR ODUCTION
2Assemblers
This c hapter discusses the functions p erformed b y assem blers, b eginning with features common
to most assem blers and pro ceeding through more elab orate capabilities suc h as macros and con-
ditional assem bly . Y ou ma y wish to skim this c hapter for the presen t and return to it when y ou
feel more comfortable with the material.
As w e men tioned, to da y's assem blers do m uc h more than translate assem bly language mnemonics
in to binary co des. But w e will describ e ho w an assem bler handles the translation of mnemonics
b efore describing additional assem bler features. Finally w e will explain ho w assem blers are used.
2.1 Fields
Assem bly language instructions (or statemen ts) are divided in to a n um b er of  elds .
The op eration co de eld is the only eld whic h can nev er he empt y; it alw a ys con tains either an
instruction mnemonic or a directiv e to the assem bler, sometimes called a pseudo-instruction,
pseudo-op eration, or pseudo-op.
The op erand or address eld ma y con tain an address or data, or it ma y b e blank.
The commen t and lab el elds are optional. A programmer will assign a lab el to a statemen t or
add a commen t as a p ersonal con v enience: namely , to mak e the program easier to read and use.
Of course, the assem bler m ust ha v e some w a y of telling where one eld ends and another b egins.
Assem blers often require that eac h eld start in a sp ecic column. This is a xed format.
Ho w ev er, xed formats are incon v enien t when the input medium is pap er tap e; xed formats are
also a n uisance to programmers. The alternativ e is a free format where the elds ma y app ear
an ywhere on the line.
2.1.1 Delimiters
If the assem bler cannot use the p osition on the line to tell the elds apart, it m ust use something
else. Most assem blers use a sp ecial sym b ol or delimiter at the b eginning or end of eac h eld.
Lab el Op eration Co de Op erand or
Field or Mnemonic A ddress Commen t Field
Field Field
VALUE1 DCW 0x201E ;FIRST VALUE
VALUE2 DCW 0x0774 ;SECOND VALUE
RESULT DCW 1 ;16-BIT STORAGE FOR ADDITION RESULT
START MOV R0, VALUE1 ;GET FIRST VALUE
ADD R0, R0, VALUE2 ;ADD SECOND VALUE TO FIRST VALUE
STR RESULT, R0 ;STORE RESULT OF ADDITION
NEXT: ? ? ;NEXT INSTRUCTION
11
12 CHAPTER 2. ASSEMBLERS
lab el/angbracketleft whitesp ac e/angbracketright instruction/angbracketleft whitesp ac e/angbracketright ; commen t
whitespace Bet w een lab el and op eration co de, b et w een op eration co de and ad-
dress, and b efore an en try in the commen t eld
comma Bet w een op erands in the address eld
asterisk Before an en tire line of commen t
semicolon Marks the start of a commen t on a line that con tains preceding co de
T able 2.1: Standard ARM Assem bler Delimiters
The most common delimiter is the space c haracter. Commas, p erio ds, semicolons, colons, slashes,
question marks, and other c haracters that w ould not otherwise b e used in assem bly language
programs also ma y serv e as delimiters. The general form of la y out for the ARM assem bler is:
Y ou will ha v e to exercise a little care with delimiters. Some assem blers are fussy ab out extra spaces
or the app earance of delimiters in commen ts or lab els. A w ell-written assem bler will handle these
minor problems, but man y assem blers are not w ell-written. Our recommendation is simple: a v oid
p oten tial problems if y ou can. The follo wing rules will help:
â€¢ Do not use extra spaces, in particular, do not put spaces after commas that separate
op erands, ev en though the ARM assem bler allo ws y ou to do this.
â€¢ Do not use delimiter c haracters in names or lab els.
â€¢ Include standard delimiters ev en if y our assem bler do es not require them. Then it will b e
more lik ely that y our programs are in correct form for another assem bler.
2.1.2 Lab els
The lab el eld is the rst eld in an assem bly language instruction; it ma y b e blank. If a lab el
is presen t, the assem bler denes the lab el as equiv alen t to the address in to whic h the rst b yte
of the ob ject co de generated for that instruction will b e loaded. Y ou ma y subsequen tly use the
lab el as an address or as data in another instruction's address eld. The assem bler will replace
the lab el with the assigned v alue when creating an ob ject program.
The ARM assem bler requires lab els to start at the rst c haracter of a line. Ho w ev er, some other
assem blers also allo w y ou to ha v e the lab el start an ywhere along a line, in whic h case y ou m ust
use a colon ( : ) as the delimiter to terminate the lab el eld. Colon delimiters are not used b y the
ARM assem bler.
Lab els are most frequen tly used in Branc h or SWI instructions. These instructions place a new
v alue in the program coun ter and so alter the normal sequen tial execution of instructions. B150 16
means  plac e the value 150 16 in the pr o gr am c ounter . The next instruction to b e executed will
b e the one in memory lo cation 150 16 . The instruction B START means  plac e the value assigne d
to the lab el START in the pr o gr am c ounter . The next instruction to b e executed will b e the on at
the address corresp onding to the lab el START . Figure 2.1 con tains an example.
Wh y use a lab el? Here are some reasons:
â€¢ A lab el mak es a program lo cation easier to nd and remem b er.
â€¢ The lab el can easily b e mo v ed, if required, to c hange or correct a program. The assem bler
will automatically c hange all instructions that use the lab el when the program is reassem bled.
2.1. FIELDS 13
Assem bly language Program
START MOV R0, VALUE1
.
. (Main Program)
.
BAL START
When the mac hine language v ersion of this program is executed, the instruction
B START causes the address of the instruction lab eled START to b e placed in the
program coun ter That instruction will then b e executed.
Figure 2.1: Assigning and Using a Lab el
â€¢ The assem bler can relo cate the whole program b y adding a constan t (a relo cation constan t)
to eac h address in whic h a lab el w as used. Th us w e can mo v e the program to allo w for the
insertion of other programs or simply to rearrange memory .
â€¢ The program is easier to use as a library program; that is, it is easier for someone else to
tak e y our program and add it to some totally dieren t program.
â€¢ Y ou do not ha v e to gure out memory addresses. Figuring out memory addresses is partic-
ularly dicult with micropro cessors whic h ha v e instructions that v ary in length.
Y ou should assign a lab el to an y instruction that y ou migh t w an t to refer to later.
The next question is ho w to c ho ose a lab el. The assem bler often places some restrictions on the
n um b er of c haracters (usually 5 or 6), the leading c haracter (often m ust b e a letter), and the
trailing c haracters (often m ust b e letters, n um b ers, or one of a few sp ecial c haracters). Bey ond
these restrictions, the c hoice is up to y ou.
Our o wn preference is to use lab els that suggest their purp ose, i.e., mnemonic lab els. T ypical
examples are ADDW in a routine that adds one w ord in to a sum, SRCHETX in a routine that searc hes
for the ASCI I c haracter ETX, or NKEYS for a lo cation in data memory that con tains the n um b er of
k ey en tries. Meaningful lab els are easier to remem b er and con tribute to program do cumen tation.
Some programmers use a standard format for lab els, suc h as starting with L0000 . These lab els are
self-sequencing (y ou can skip a few n um b ers to p ermit insertions), but they do not help do cumen t
the program.
Some lab el selection rules will k eep y ou out of trouble. W e recommend the follo wing:
â€¢ Do not use lab els that are the same as op eration co des or other mnemonics. Most assem blers
will not allo w this usage; others will, but it is confusing.
â€¢ Do not use lab els that are longer than the assem bler recognises. Assem blers ha v e v arious
rules, and often ignore some of the c haracters at the end of a long lab el.
â€¢ A v oid sp ecial c haracters (non-alphab etic and non-n umeric) and lo w er-case letters. Some
assem blers will not p ermit them; others allo w only certain ones. The simplest practice is to
stic k to capital letters and n um b ers.
â€¢ Start eac h lab el with a letter. Suc h lab els are alw a ys acceptable.
â€¢ Do not use lab els that could b e confused with eac h other. A v oid the letters I , O , and Z and
the n um b ers 0 , 1 , and 2 . Also a v oid things lik e XXXX and XXXXX . Assem bly programming is
dicult enough without tempting fate or Murph y's La w.
â€¢ When y ou are not sure if a lab el is legal, do not use it. Y ou will not get an y real b enet
from disco v ering exactly what the assem bler will accept.
14 CHAPTER 2. ASSEMBLERS
These are recommendations, not rules. Y ou do not ha v e to follo w them but don't blame us if y ou
w aste time on unnecessary problems.
2.2 Op eration Co des (Mnemonics)
One main task of the assem bler is the translation of mnemonic op eration co des in to their binary
equiv alen ts. The assem bler p erforms this task using a xed table m uc h as y ou w ould if y ou w ere
doing the assem bly b y hand.
The assem bler m ust, ho w ev er, do more than just translate the op eration co des. It m ust also
someho w determine ho w man y op erands the instruction requires and what t yp e they are. This
ma y b e rather complex  some instructions (lik e a Stop) ha v e no op erands, others (lik e a Jump
instruction) ha v e one, while still others (lik e a transfer b et w een registers or a m ultiple-bit shift)
require t w o. Some instructions ma y ev en allo w alternativ es; for example, some computers ha v e
instructions (lik e Shift or Clear) whic h can either apply to a register in the CPU or to a memory
lo cation. W e will not discuss ho w the assem bler mak es these distinctions; w e will just note that it
m ust do so.
2.3 Directiv es
Some assem bly language instructions are not directly translated in to mac hine language instruc-
tions. These instructions are directiv es to the assem bler; they assign the program to certain areas
in memory , dene sym b ols, designate areas of memory for data storage, place tables or other xed
data in memory , allo w references to other programs, and p erform minor housek eeping functions.
T o use these assem bler directiv es or pseudo-op erations a programmer places the directiv e's mnemonic
in the op eration co de eld, and, if the sp ecied directiv e requires it, an address or data in the
address eld.
The most common directiv es are:
DEFINE CONST ANT (Data)
EQUA TE (Dene)
AREA
DEFINE STORA GE (Reserv e)
Dieren t assem blers use dieren t names for those op erations but their functions are the same.
Housek eeping directiv es include:
END LIST F ORMA T TTL P A GE INCLUDE
W e will discuss these pseudo-op erations briey , although their functions are usually ob vious.
2.3.1 The DEFINE CONST ANT (Data) Directiv e
The DEFINE CONST ANT directiv e allo ws the programmer to en ter xed data in to program
memory . This data ma y include:
2.3. DIRECTIVES 15
â€¢ Names â€¢ Con v ersion factors
â€¢ Messages â€¢ Key iden tications
â€¢ Commands â€¢ Subroutine addresses
â€¢ T ax tables â€¢ Co de con v ersion tables
â€¢ Thresholds â€¢ Iden tication patterns
â€¢ T est patterns â€¢ State transition tables
â€¢ Lo okup tables â€¢ Sync hronisation patterns
â€¢ Standard forms â€¢ Co ecien ts for equations
â€¢ Masking patterns â€¢ Character generation patterns
â€¢ W eigh ting factors â€¢ Characteristic times or frequencies
The dene constan t directiv e treats the data as a p ermanen t part of the program.
The format of a dene constan t directiv e is usually quite simple. An instruction lik e:
DZCON DCW 12
will place the n um b er 12 in the next a v ailable memory lo cation and assign that lo cation the name
DZCON . Ev ery DC directiv e usually has a lab el, unless it is one of a series. The data and lab el ma y
tak e an y form that the assem bler p ermits.
More elab orate dene constan t directiv es that handle a large amoun t of data at one time are
pro vided, for example:
EMESS DCB 'ERROR'
SQRS DCW 1,4,9,16,25
A single directiv e ma y ll man y b ytes of program memory , limited p erhaps b y the length of a
line or b y the restrictions of a particular assem bler. Of course, y ou can alw a ys o v ercome an y
restrictions b y follo wing one dene constan t directiv e with another:
MESSG DCB "NOW IS THE "
DCB "TIME FOR ALL "
DCB "GOOD MEN "
DCB "TO COME TO THE "
DCB "AID OF THEIR "
DCB "COUNTRY", 0 ;note the '0' terminating the string
Micropro cessor assem blers t ypically ha v e some v ariations of standard dene constan t directiv es.
Dene Byte or DCB handles 8-bit n um b ers; Dene W ord or DCW handles 32-bit n um b ers or addresses.
Other sp ecial directiv es ma y handle c haracter-co ded data. The ARM assem bler also denes DCD
to (Dene Constan t Data) whic h ma y b e used in place of DCW .
2.3.2 The EQUA TE Directiv e
The EQUA TE directiv e allo ws the programmer to equate names with addresses or data. This
pseudo-op eration is almost alw a ys giv en the mnemonic EQU . The names ma y refer to device ad-
dresses, n umeric data, starting addresses, xed addresses, etc.
The EQUA TE directiv e assigns the n umeric v alue in its op erand eld to the lab el in its lab el eld.
Here are t w o examples:
TTY EQU 5
LAST EQU 5000
16 CHAPTER 2. ASSEMBLERS
Most assem blers will allo w y ou to dene one lab el in terms of another, for example:
LAST EQU FINAL
ST1 EQU START+1
The lab el in the op erand eld m ust, of course, ha v e b een previously dened. Often, the op erand
eld ma y con tain more complex expressions, as w e shall see later. Double name assignmen ts (t w o
names for the same data or address) ma y b e useful in patc hing together programs that use dieren t
names for the same v ariable (or dieren t sp ellings of what w as supp osed to b e the same name).
Note that an EQU directiv e do es not cause the assem bler to place an ything in memory . The as-
sem bler simply en ters an additional name in to a table (called a sym b ol table) whic h the assem bler
main tains.
When do y ou use a name? The answ er is: whenev er y ou ha v e a parameter that y ou migh t w an t to
c hange or that has some meaning b esides its ordinary n umeric v alue. W e t ypically assign names to
time constan ts, device addresses, masking patterns, con v ersion factors, and the lik e. A name lik e
DELAY , TTY , KBD , KROW , or OPEN not only mak es the parameter easier to c hange, but it also adds to
program do cumen tation. W e also assign names to memory lo cations that ha v e sp ecial purp oses;
they ma y hold data, mark the start of the program, or b e a v ailable for in termediate storage.
What name do y ou use? The b est rules are m uc h the same as in the case of lab els, except that
here meaningful names really coun t. Wh y not call the telet yp ewriter TTY instead of X15 , a bit
time dela y BTIME or BTDLY rather than WW , the n um b er of the GO k ey on a k eyb oard GOKEY
rather than HORSE ? This advice seems straigh tforw ard, but a surprising n um b er of programmers
do not follo w it.
Where do y ou place the EQUA TE directiv es? The b est place is at the start of the program, under
appropriate commen t headings suc h as i/o addresses , temporar y stora ge , time const ants ,
or pr ogram loca tions . This mak es the denitions easy to nd if y ou w an t to c hange them.
F urthermore, another user will b e able to lo ok up all the denitions in one cen tralised place.
Clearly this practice impro v es do cumen tation and mak es the program easier to use.
Denitions used only in a sp ecic subroutine should app ear at the start of the subroutine.
2.3.3 The AREA Directiv e
The AREA directiv e allo ws the programmer to sp ecify the memory lo cations where programs,
subroutines, or data will reside. Programs and data ma y b e lo cated in dieren t areas of memory
dep ending on the memory conguration. Startup routines in terrupt service routines, and other
required programs ma y b e scattered around memory at xed or con v enien t addresses.
The assem bler main tains a lo cation coun ter (comparable to the computer's program coun ter) whic h
con tains the lo cation in memory of the instruction or data item b eing pro cessed. An area directiv e
causes the assem bler to place a new v alue in the lo cation coun ter, m uc h as a Jump instruction
causes the CPU to place a new v alue in the program coun ter. The output from the assem bler
m ust not only con tain instructions and data, but m ust also indicate to the loader program where
in memory it should place the instructions and data.
Micropro cessor programs often con tain sev eral AREA statemen ts for the follo wing purp oses:
â€¢ Reset (startup) address â€¢ Stac k
â€¢ In terrupt service addresses â€¢ Main program
â€¢ T rap (soft w are in terrupt) addresses â€¢ Subroutines
â€¢ RAM storage â€¢ Input/Output
2.4. OPERANDS AND ADDRESSES 17
Still other origin statemen ts ma y allo w ro om for later insertions, place tables or data in memory ,
or assign v acan t memory space for data buers. Program and data memory in micro computers
ma y o ccup y widely separate addresses to simplify the hardw are. T ypical origin statemen ts are:
AREA RESET
AREA $1000
AREA INT3
The assem bler will assume a fak e address if the programmer do es not put in an AREA statemen t.
The AREA statemen t at the start of an ARM program is required, and its absence will cause the
assem bly to fail.
2.3.4 Housek eeping Directiv es
There are v arious assem bler directiv es that aect the op eration of the assem bler and its program
listing rather than the ob ject program itself. Common directiv es include:
END , marks the end of the assem bly language source program. This m ust app ear in the le or a
missing END directiv e error will o ccur.
INCLUDE will include the con ten ts of a named le in to the curren t le. When the included le
has b een pro cessed the assem bler will con tin ue with the next line in the original le. F or
example the follo wing line
INCLUDE MATH.S
will include the con ten t of the le math.s at that p oin t of the le.
Y ou should nev er use a lable with an include directiv e. An y lab els dened in the included le
will b e dened in the curren t le, hence an error will b e rep orted if the same lab el app ears
in b oth the source and include le.
An include le ma y itself include other les, whic h in turn could include other les, and so
on, ho w ev er, the lev el of includes the assem bler will accept is limited. It is not recommended
y ou go b ey ond three lev els for ev en the most complex of soft w are.
2.3.5 When to Use Lab els
Users often w onder if or when they can assign a lab el to an assem bler directiv e. These are our
recommendations:
1. All EQU directiv es m ust ha v e lab els; they are useless otherwise, since the purp ose of an EQU
is to dene its lab el.
2. Dene Constan t and Dene Storage directiv es usually ha v e lab els. The lab el iden ties the
rst memory lo cation used or assigned.
3. Other directiv es should not ha v e lab els.
2.4 Op erands and A ddresses
The assem bler allo w the programmer a lot of freedom in describing the con ten ts of the op erand or
address eld. But remem b er that the assem bler has built-in names for registers and instructions
and ma y ha v e other built-in names. W e will no w describ e some common options for the op erand
eld.
18 CHAPTER 2. ASSEMBLERS
2.4.1 Decimal Num b ers
The assem bler assume all n um b ers to b e decimal unless they are mark ed otherwise. So:
ADD 100
means add the con ten ts of memory lo cation 100 10 to the con ten ts of the A ccum ulator.
2.4.2 Other Num b er Systems
The assem bler will also accept hexadecimal en tries. But y ou m ust iden tify these n um b er systems
in some w a y: for example, b y preceding the n um b er with an iden tifying c haracter.
2_ nnn Binary Base 2
8_ nnn Octal Base 8
nnn Decimal Base 10
0x nnn Hexadecimal Base 16
It is go o d practice to en ter n um b ers in the base in whic h their meaning is the clearest: that is,
decimal constan ts in decimal; addresses and BCD n um b ers in hexadecimal; masking patterns or
bit outputs in hexadecimal.
2.4.3 Names
Names can app ear in the op erand eld; they will b e treated as the data that they represen t.
Remem b er, ho w ev er, that there is a dierence b et w een op erands and addresses. In an ARM
assem bly language program the sequence:
FIVE EQU 5
ADD R2, #FIVE
will add the con ten ts of memory lo cation FIVE (not necessarily the n um b er 5) to the con ten ts of
data register R2 .
2.4.4 Character Co des
The assem bler allo ws text to b e en tered as ASCI I strings. Suc h strings m ust b e surrounded with
double quotation marks, unless a single ASCI I c haracter is quoted, when single qoutes ma y b e
used exactly as in 'C'. W e recommend that y ou use c haracter strings for all text. It impro v es the
clarit y and readabilit y of the program.
2.4.5 Arithmetic and Logical Expressions
Assem blers p ermit com binations of the data forms describ ed ab o v e, connected b y arithmetic,
logical, or sp ecial op erators. These com binations are called expressions. Almost all assem blers
allo w simple arithmetic expressions suc h as START+1 . Some assem blers also p ermit m ultiplication,
division, logical functions, shifts, etc. Note that the assem bler ev aluates expressions at assem bly
time; if a sym b ol app ears in an expression, the address is used (i.e., the lo cation coun ter or
EQUA TE v alue).
Assem blers v ary in what expressions they accept and ho w they in terpret them. Complex expres-
sions mak e a program dicult to read and understand.
2.5. COMMENTS 19
2.4.6 General Recommendations
W e ha v e made some recommendations during this section but will rep eat them and add others
here. In general, the user should striv e for clarit y and simplicit y . There is no pa y o for b eing an
exp ert in the in tricacies of an assem bler or in ha ving the most complex expression on the blo c k.
W e suggest the follo wing approac h:
â€¢ Use the clearest n um b er system or c haracter co de for data.
â€¢ Masks and BCD n um b ers in decimal, ASCI I c haracters in o ctal, or ordinary n umerical
constan ts in hexadecimal serv e no purp ose and therefore should not b e used.
â€¢ Remem b er to distinguish data from addresses.
â€¢ Don't use osets from the lo cation coun ter.
â€¢ Keep expressions simple and ob vious. Don't rely on obscure features of the assem bler.
2.5 Commen ts
All assem blers allo w y ou to place commen ts in a source program. Commen ts ha v e no eect on the
ob ject co de, but they help y ou to read, understand, and do cumen t the program. Go o d commen ting
is an essen tial part of writing computer programs, programs without commen ts are v ery dicult
to understand.
W e will discuss commen ting along with do cumen tation in a later c hapter, but here are some
guidelines:
â€¢ Use commen ts to tell what application task the program is p erforming, not ho w the micro-
computer executes the instructions.
â€¢ Commen ts should sa y things lik e is temp erature ab o v e limit?, linefeed to TTY, or ex-
amine load switc h.
â€¢ Commen ts should not sa y things lik e add 1 to A ccum ulator, jump to Start, or lo ok at
carry . Y ou should describ e ho w the program is aecting the system; in ternal eects on the
CPU should b e ob vious from the co de.
â€¢ Keep commen ts brief and to the p oin t. Details should b e a v ailable elsewhere in the do cu-
men tation.
â€¢ Commen t all k ey p oin ts.
â€¢ Do not commen t standard instructions or sequences that c hange coun ters or p oin ters; pa y
sp ecial atten tion to instructions that ma y not ha v e an ob vious meaning.
â€¢ Do not use obscure abbreviations.
â€¢ Mak e the commen ts neat and readable.
â€¢ Commen t all denitions, describing their purp oses. Also mark all tables and data storage
areas.
â€¢ Commen t sections of the program as w ell as individual instructions.
â€¢ Be consisten t in y our terminology . Y ou can (should) b e rep etitiv e, y ou need not consult a
thesaurus.
20 CHAPTER 2. ASSEMBLERS
â€¢ Lea v e y ourself notes at p oin ts that y ou nd confusing: for example, remem b er carry w as set
b y last instruction. If suc h p oin ts get cleared up later in program dev elopmen t, y ou ma y
drop these commen ts in the nal do cumen tation.
A w ell-commen ted program is easy to use. Y ou will reco v er the time sp en t in commen ting man y
times o v er. W e will try to sho w go o d commen ting st yle in the programming examples, although
w e often o v er-commen t for instructional purp oses.
2.6 T yp es of Assem blers
Although all assem blers p erform the same tasks, their implemen tations v ary greatly . W e will not
try to describ e all the existing t yp es of assem blers, w e will merely dene the terms and indicate
some of the c hoices.
A cr oss-assembler is an assem bler that runs on a computer other than the one for whic h it assem bles
ob ject programs. The computer on whic h the cross-assem bler runs is t ypically a large computer
with extensiv e soft w are supp ort and fast p eripherals. The computer for whic h the cross-assem bler
assem bles programs is t ypically a micro lik e the 6809 or MC68000.
When a new micro computer is in tro duced, a cross-assem bler is often pro vided to run on existing
dev elopmen t systems. F or example, ARM pro vide the 'Arm ulator' cross-assem bler that will run
on a PC dev elopmen t system.
A self-assembler or r esident assembler is an assem bler that runs on the computer for whic h it
assem bles programs. The self-assem bler will require some memory and p eripherals, and it ma y
run quite slo wly compared to a cross-assem bler.
A macr o assembler is an assem bler that allo ws y ou to dene sequences of instructions as macros.
A micr o assembler is an assem bler used to write the microprograms whic h dene the instruction
set of a computer. Microprogramming has nothing sp ecically to do with programming micro-
computers, but has to do with the in ternal op eration of the computer.
A meta-assembler is an assem bler that can handle man y dieren t instruction sets. The user m ust
dene the particular instruction set b eing used.
A one-p ass assembler is an assem bler that go es through the assem bly language program only
once. Suc h an assem bler m ust ha v e some w a y of resolving forw ard references, for example, Jump
instructions whic h use lab els that ha v e not y et b een dened.
A two-p ass assembler is an assem bler that go es through the assem bly language source program
t wice. The rst time the assem bler simply collects and denes all the sym b ols; the second time
it replaces the references with the actual denitions. A t w o-pass assem bler has no problems with
forw ard references but ma y b e quite slo w if no bac kup storage (lik e a opp y disk) is a v ailable;
then the assem bler m ust ph ysically read the program t wice from a slo w input medium (lik e a
telet yp ewriter pap er tap e reader). Most micropro cessor-based assem blers require t w o passes.
2.7 Errors
Assem blers normally pro vide error messages, often consisting of an error co de n um b er. Some
t ypical errors are:
2.8. LO ADERS 21
Undened name Often a missp elling or an omitted denition
Illegal c haracter Suc h as a 2 in a binary n um b er
Illegal format A wrong delimiter or incorrect op erands
In v alid expression for example, t w o op erators in a ro w
Illegal v alue Usually the v alue is to o large
Missing op erand Prett y self explanatory
Double denition T w o dieren t v alues assigned to one name
Illegal lab el Suc h as a lab el on a pseudo-op eration that cannot ha v e one
Missing lab el Probably a miss sp elt lable name
Undened op eration co de
In in terpreting assem bler errors, y ou m ust remem b er that the assem bler ma y get on the wrong
trac k if it nds a stra y letter, an extra space, or incorrect punctuation. The assem bler will
then pro ceed to misin terpret the succeeding instructions and pro duce meaningless error messages.
Alw a ys lo ok at the rst error v ery carefully; subsequen t ones ma y dep end on it. Caution and
consisten t adherence to standard formats will eliminate man y anno ying mistak es.
2.8 Loaders
The loader is the program whic h actually tak es the output (ob ject co de) from the assem bler and
places it in memory . Loaders range from the v ery simple to the v ery complex. W e will describ e a
few dieren t t yp es.
A b o otstr ap lo ader is a program that uses its o wn rst few instructions to load the rest of itself
or another loader program in to memory . The b o otstrap loader ma y b e in R OM, or y ou ma y ha v e
to en ter it in to the computer memory using fron t panel switc hes. The assem bler ma y place a
b o otstrap loader at the start of the ob ject program that it pro duces.
A r elo c ating lo ader can load programs an ywhere in memory . It t ypically loads eac h program
in to the memory space immediately follo wing that used b y the previous program. The programs,
ho w ev er, m ust themselv es b e capable of b eing mo v ed around in this w a y; that is, they m ust b e
relo catable. An absolute lo ader, in con trast, will alw a ys place the programs in the same area of
memory .
A linking lo ader loads programs and subroutines that ha v e b een assem bled separately; it resolv es
cross-references  that is, instructions in one program that refer to a lab el in another program.
Ob ject programs loaded b y a linking loader m ust b e created b y an assem bler that allo ws external
references. An alternativ e approac h is to separate the linking and loading functions and ha v e the
linking p erformed b y a program called a link e ditor and the loading done b y a loader.
22 CHAPTER 2. ASSEMBLERS
3ARM Architecture
This c hapter outlines the ARM pro cessor's arc hitecture and describ es the syn tax rules of the ARM
assem bler. Later c hapters of this b o ok describ e the ARM's stac k and exception pro cessing system
in more detail.
Figure 3.1 on the follo wing page sho ws the in ternal structure of the ARM pro cessor. The ARM
is a R e duc e d Instruction Set Computer (RISC) system and includes the attributes t ypical to that
t yp e of system:
â€¢ A large arra y of uniform registers.
â€¢ A load/store mo del of data-pro cessing where op erations can only op erate on registers and not
directly on memory . This requires that all data b e loaded in to registers b efore an op eration
can b e preformed, the result can then b e used for further pro cessing or stored bac k in to
memory .
â€¢ A small n um b er of addressing mo des with all load/store addresses b egin determined from
registers and instruction elds only .
â€¢ A uniform xed length instruction (32-bit).
In addition to these traditional features of a RISC system the ARM pro vides a n um b er of additional
features:
â€¢ Separate A rithmetic L o gic Unit (ALU) and shifter giving additional con trol o v er data pro-
cessing to maximize execution sp eed.
â€¢ Auto-incremen t and Auto-decremen t addressing mo des to impro v e the op eration of program
lo ops.
â€¢ Conditional execution of instructions to reduce pip eline ushing and th us increase execution
sp eed.
3.1 Pro cessor mo des
The ARM supp orts the sev en pro cessor mo des sho wn in table 3.1.
Mo de c hanges can b e made under soft w are con trol, or can b e caused b y external in terrupts or
exception pro cessing.
Most application programs execute in User mo de. While the pro cessor is in User mo de, the
program b eing executed is unable to access some protected system resources or to c hange mo de,
other than b y causing an exception to o ccur (see 3.4 on page 29). This allo ws a suitably written
op erating system to con trol the use of system resources.
23
24 CHAPTER 3. ARM AR CHITECTURE
Figure 3.1: ARM Blo c k Diagram
3.2. REGISTERS 25
Pro cessor mo de Description
User usr Normal program execution mo de
FIQ q F ast In terrupt for high-sp eed data transfer
IR Q irq Used for general-purp ose in terrupt handling
Sup ervisor svc A protected mo de for the op erating system
Ab ort abt Implemen ts virtual memory and/or memory protection
Undened und Supp orts soft w are em ulation of hardw are copro cessors
System sys Runs privileged op erating system tasks
T able 3.1: ARM pro cessor mo des
The mo des other than User mo de are kno wn as privile ge d mo des . They ha v e full access to system
resources and can c hange mo de freely . Fiv e of them are kno wn as exc eption mo des : FIQ (F ast
In terrupt), IR Q (In terrupt), Sup ervisor, Ab ort, and Undened. These are en tered when sp ecic
exceptions o ccur. Eac h of them has some additional registers to a v oid corrupting User mo de state
when the exception o ccurs (see 3.2 for details).
The remaining mo de is System mo de, it is not en tered b y an y exception and has exactly the same
registers a v ailable as User mo de. Ho w ev er, it is a privileged mo de and is therefore not sub ject to
the User mo de restrictions. It is in tended for use b y op erating system tasks whic h need access to
system resources, but wish to a v oid using the additional registers asso ciated with the exception
mo des. A v oiding suc h use ensures that the task state is not corrupted b y the o ccurrence of an y
exception.
3.2 Registers
The ARM has a total of 37 registers. These comprise 30 general purp ose registers, 6 status registers
and a program coun ter. Figure 3.2 illustrates the registers of the ARM. Only fteen of the general
purp ose registers are a v ailable at an y one time dep ending on the pro cessor mo de.
There are a standard set of eigh t general purp ose registers that are alw a ys a v ailable ( R 0  R 7 ) no
matter whic h mo de the pro cessor is in. These registers are truly general-purp ose, with no sp ecial
uses b eing placed on them b y the pro cessors' arc hitecture.
A few registers ( R 8  R 12 ) are common to all pro cessor mo des with the exception of the q
mo de. This means that to all in ten t and purp ose these are general registers and ha v e no sp ecial
use. Ho w ev er, when the pro cessor is in the fast in terrupt mo de these registers and replaced with
dieren t set of registers ( R 8_q - R 12_q ). Although the pro cessor do es not giv e an y sp ecial
purp ose to these registers they can b e used to hold information b et w een fast in terrupts. Y ou can
consider they to b e static registers. The idea is that y ou can mak e a fast in terrupt ev en faster
b y holding information in these registers.
The general purp ose registers can b e used to handle 8-bit b ytes, 16-bit half-w ords1, or 32-bit
w ords. When w e use a 32-bit register in a b yte instruction only the least signican t 8 bits are
used. In a half-w ord instruction only the least signican t 16 bits are used. Figure 3.3 demonstrates
this.
The remaining registers ( R 13  R 15 ) are sp ecial purp ose registers and ha v e v ery sp ecic roles:
R 13 is also kno wn as the Stac k P oin ter, while R 14 is kno wn as the Link Register, and R 15 is
the Program Coun ter. The user ( usr ) and System ( sys ) mo des share the same registers. The
exception mo des all ha v e their o wn v ersion of these registers. Making a reference to register R 14
will assume y ou are referring to the register for the curren t pro cessor mo de. If y ou wish to refer
1Although the ARM do es allo w for Half-W ord instructions, the em ulator w e are using do es not.
26 CHAPTER 3. ARM AR CHITECTURE
Mo des
Privileged Mo des
Exception Mo des
User System Sup ervisor Ab ort Undened In terrupt F ast In terrupt
R0 R0 R0 R0 R0 R0 R0
R1 R1 R1 R1 R1 R1 R1
R2 R2 R2 R2 R2 R2 R2
R3 R3 R3 R3 R3 R3 R3
R4 R4 R4 R4 R4 R4 R4
R5 R5 R5 R5 R5 R5 R5
R6 R6 R6 R6 R6 R6 R6
R7 R7 R7 R7 R7 R7 R7
R8 R8 R8 R8 R8 R8 R8_q
R9 R9 R9 R9 R9 R9 R9_q
R10 R10 R10 R10 R10 R10 R10_q
R11 R11 R11 R11 R11 R11 R11_q
R12 R12 R12 R12 R12 R12 R12_q
R13 R13 R13_sv c R13_abt R13_und R13_irq R13_q
R14 R14 R14_sv c R14_abt R14_und R14_irq R14_q
PC PC PC PC PC PC PC
CPSR CPSR CPSR CPSR CPSR CPSR CPSR
SPSR_sv c SPSR_abt SPSR_und SPSR_irq SPSR_q
Figure 3.2: Register Organization
Bit: 31Â·Â·Â· 23 24Â·Â·Â· 16 15Â·Â·Â· 8 7Â·Â·Â· 0
8-Bit Byte
16-Bit Half W ord
32-Bit W ord
Figure 3.3: Byte/Half W ord/W ord
to the user mo de v ersion of this register y ou ha v e refer to the R 14_usr register. Y ou ma y only
refer to register from other mo des when the pro cessor is in one of the privileged mo des, i.e., an y
mo de other than user mo de.
There are also one or t w o status registers dep ending on whic h mo de the pro cessor is in. The Cur-
ren t Pro cessor Status Register ( CPSR ) holds information ab out the curren t status of the pro cessor
(including its curren t mo de). In the exception mo des there is an additional Sa v ed Pro cessor Status
Register ( SPSR ) whic h holds information on the pro cessors state b efore the system c hanged in to
this mo de, i.e., the pro cessor status just b efore an exception.
3.2.1 The stac k p oin ter, SP or R 13
Register R 13 is used as a stac k p oin ter and is also kno wn as the SP register. Eac h exception mo de
has its o wn v ersion of R 13 , whic h p oin ts to a stac k dedicated to that exception mo de.
The stac k is t ypically used to store temp orary v alues. It is normal to store the con ten ts of an y
registers a function is going to use on the stac k on en try to a subroutine. This lea v es the register
free for use during the function. The routine can then reco v er the register v alues from the stac k
3.2. REGISTERS 27
on exit from the subroutine. In this w a y the subroutine can preserv e the v alue of the register and
not corrupt the v alue as w ould otherwise b e the case.
See Chapter 15 for more information on using the stac k.
3.2.2 The Link Register, LR or R 14
Register R 14 is also kno wn as the Link R e gister or LR .
It is used to hold the return address for a subroutine. When a subroutine call is p erformed via a
BL instruction, R 14 is set to the address of the next instruction. T o return from a subroutine y ou
need to cop y the Link Register in to the Program Coun ter. This is t ypically done in one of the t w o
w a ys:
â€¢ Execute either of these instructions:
MOV PC, LR or BAL LR
â€¢ On en try to the subroutine store R 14 to the stac k with an instruction of the form:
STMFD SP!,{/angbracketleft r e gisters/angbracketright , LR}
and use a matc hing instruction to return from the subroutine:
LDMFD SP!,{/angbracketleft r e gisters/angbracketright , PC}
This sa v es the Link Register on the stac k at the start of the subroutine. On exit from the
subroutine it collects all the v alues it placed on the stac k, including the return address that
w as in the Link Register, except it returns this address directly in to the Program Coun ter
instead.
See Chapter ?? on page ?? for further details of using the stac k, and Chapter 15 on page 113 for
further details on using subroutines.
When an exception o ccurs, the exception mo de's v ersion of R 14 is set to the address after the
instruction whic h has just b een completed. The SPSR is a cop y of the CPSR just b efore the
exception o ccurred. The return from an exception is p erformed in a similar w a y to a subroutine
return, but using sligh tly dieren t instructions to ensure full restoration of the state of the program
that w as b eing executed when the exception o ccurred. See 3.4 on page 29 for more details.
3.2.3 The program coun ter, PC or R 15
Register R 15 holds the Pr o gr am Counter kno wn as the PC . It is used to iden tify whic h instruction
is to b e preformed next . As the PC holds the address of the next instruction it is often referred
to as an instruction p ointer . The name program coun ter dates bac k to the times when program
instructions where read in o of punc hed cards, it refers to the card p osition within a stac k of
cards. In spite of its name it do es not actually coun t an ything!
Reading the program coun ter
When an instruction reads the PC the v alue returned is the address of the curren t instruction plus
8 b ytes. This is the address of the instruction after the next instruction to b e executed2.
2This is caused b y the pro cessor ha ving already fetc hed the next instruction from memory while it w as deciding
what the curren t instruction w as. Th us the PC is still the next instruction to b e executed, but that is not the
instruction immediately after the curren t one.
28 CHAPTER 3. ARM AR CHITECTURE
This w a y of reading the PC is primarily used for quic k, p osition-indep enden t addressing of nearb y
instructions and data, including p osition-indep enden t branc hing within a program.
An exception to this rule o ccurs when an STR (Store Register) or STM (Store Multiple Registers)
instruction stores R 15 . The v alue stored is UNKNO WN and it is b est to a v oid the use of these
instructions that store R 15 .
W riting the program coun ter
When an instruction writes to R 15 the normal result is that the v alue written is treated as an
instruction address and the system starts to execute the instruction at that address3.
3.2.4 Curren t Pro cessor Status Registers: CPSR
Rather surprisingly the curr ent pr o c essor status r e gister ( CPSR ) con tains the curren t status of the
pro cessor. This includes v arious condition co de ags, in terrupt status, pro cessor mo de and other
status and con trol information.
The exception mo des also ha v e a save d pr o c essor status r e gister ( SPSR ), that is used to preserv e
the v alue of the CPSR when the asso ciated exception o ccurs. Because the User and System mo des
are not exception mo des, there is no SPSR a v ailable.
Figure 3.4 sho ws the format of the CPSR and the SPSR registers.
31 30 29 28 27 Â·Â·Â· 8 7 6 5 4 Â·Â·Â· 0
N Z C V SBZ I F SBZ Mo de
Figure 3.4: Structure of the Pro cessor Status Registers
The pro cessors' status is split in to t w o distinct parts: the User ags and the Systems Con trol
ags. The upp er halfw ord is accessible in User mo de and con tains a set of ags whic h can b e
used to eect the op eration of a program, see section 3.3. The lo w er halfw ord con tains the System
Con trol information.
An y bit not curren tly used is reserv ed for future use and should b e zero, and are mark ed SBZ in
the gure. The I and F bits indicate if In terrupts ( I ) or F ast In terrupts ( F ) are allo w ed. The Mo de
bits indicate whic h op erating mo de the pro cessor is in (see 3.1 on page 23).
The system ags can only b e altered when the pro cessor is in protected mo de. User mo de programs
can not alter the status register except for the condition co de ags.
3.3 Flags
The upp er four bits of the status register con tains a set of four ags, collectiv ely kno wn at the
c ondition c o de . The condition co de ags are:
Negativ e (N)
Zero (Z)
Carry (C)
Ov ero w (V)
3As the pro cessor has already fetc hed the instruction after the curren t instruction it is required to ush the
instruction cac he and start again. This will cause a short, but not signican t, dela y .
3.4. EX CEPTIONS 29
The condition co de can b e used to con trol the o w of the program execution. The is often
abbreviated to just /angbracketleft c c/angbracketright .
N The Negativ e (sign) ag tak es on the v alue of the most signican t bit of a result. Th us
when an op eration pro duces a negativ e result the negativ e ag is set and a p ositiv e
result results in a the negativ e ag b eing reset. This assumes the v alues are in standard
t w o's complemen t form. If the v alues are unsigned the negativ e ag can b e ignored or
used to iden tify the v alue of the most signican t bit of the result.
Z The Zero ag is set when an op eration pro duces a zero result. It is reset when an
op eration pro duces a non-zero result.
C The Carry ag holds the carry from the most signican t bit pro duced b y arithmetic op-
erations or shifts. As with most pro cessors, the carry ag is in v erted after a subtraction
so that the ag acts as a b orro w ag after a subtraction.
V The Ov ero w ag is set when an arithmetic result is greater than can b e represen ted in
a register.
Man y instructions can mo dify the ags, these include comparison, arithmetic, logical and mo v e
instructions. Most of the instructions ha v e an S qualier whic h instructs the pro cessor to set the
condition co de ags or not.
3.4 Exceptions
Exceptions are generated b y in ternal and external sources to cause the pro cessor to handle an ev en t,
suc h as an externally generated in terrupt or an attempt to execute an undened instruction. The
ARM supp orts sev en t yp es of exception, and a pro vides a privileged pro cessing mo de for eac h
t yp e. T able 3.2 lists the t yp e of exception and the pro cessor mo de asso ciated with it.
When an exception o ccurs, some of the standard registers are replaced with registers sp ecic to the
exception mo de. All exception mo des ha v e their o wn Stac k P oin ter ( SP ) and Link ( LR ) registers.
The fast in terrupt mo de has more registers ( R 8_q  R 12_q ) for fast in terrupt pro cessing.
Exception T yp e Pro cessor Mo de
Reset Sup ervisor svc
Soft w are In terrupt Sup ervisor svc
Undened Instruction Undened und
Prefetc h Ab ort Ab ort abt
Data Ab ort Ab ort abt
In terrupt IR Q irq
F ast In terrupt FIQ q
T able 3.2: Exception pro cessing mo des
The sev en exceptions are:
Reset when the Reset pin is held lo w, this is normally when the system is rst turned on or when
the reset button is pressed.
Soft w are In terrupt is generally used to allo w user mo de programs to call the op erating system.
The user program executes a soft w are in terrupt ( SWI , A.18 on page 135) instruction with a
argumen t whic h iden ties the function the user wishes to preform.
30 CHAPTER 3. ARM AR CHITECTURE
Undened Instruction is when an attempt is made to preform an undened instruction. This
normally happ ens when there is a logical error in the program and the pro cessor starts to
execute data rather than program co de.
Prefetc h Ab ort o ccurs when the pro cessor attempts to access memory that do es not exist.
Data Ab ort o ccurs when attempting to access a w ord on a non-w ord aligned b oundary . The
lo w er t w o bits of a memory m ust b e zero when accessing a w ord.
In terrupt o ccurs when an external device asserts the IR Q (in terrupt) pin on the pro cessor. This
can b e used b y external devices to request atten tion from the pro cessor. An in terrupt can
not b e in terrupted with the exception of a fast in terrupt.
F ast In terrupt o ccurs when an external device asserts the FIQ (fast in terrupt) pin. This is
designed to supp ort data transfer and has sucien t priv ate registers to remo v e the need for
register sa ving in suc h applications. A fast in terrupt can not b e in terrupted.
When an exception o ccurs, the pro cessor halts execution after the curren t instruction. The state
of the pro cessor is preserv ed in the Save d Pr o c essor Status R e gister ( SPSR ) so that the original
program can b e resumed when the exception routine has completed. The address of the instruction
the pro cessor w as just ab out to execute is placed in to the Link Register of the appropriate pro cessor
mo de. The pro cessor is no w ready to b egin execution of the exception handler.
The exception handler are lo cated a pre-dened lo cations kno wn as exc eption ve ctors . It is the
resp onsibilit y of an op erating system to pro vide suitable exception handling.
3.5 Instruction Set
Wh y are a micropro cessor's instructions referred to as an instruction set? Because the micropro-
cessor designer selects the instruction complemen t with great care; it m ust b e easy to execute
complex op erations as a sequence of simple ev en ts, eac h of whic h is represen ted b y one instruction
from a w ell-designed instruction set.
Assem bler often frigh ten users who are new to programming. Y et tak en in isolation, the op erations
in v olv ed in the execution of a single instruction are usually easy to follo w. F urthermore, y ou need
not attempt to understand all the instructions at once. As y ou study eac h of the programs in
these notes y ou will learn ab out the sp ecic instructions in v olv ed.
T able 4.1 lists the instruction mnemonics. This pro vides a surv ey of the pro cessors capabilities,
and will also b e useful when y ou need a certain kind of op eration but are either unsure of the
sp ecic mnemonics or not y et familiar with what instructions are a v ailable.
See Chapter ?? and App endix ?? for a detailed description of the individual instructions and
c hapters 7 through to 15 for a discussion on ho w to use them.
The ARM instruction set can b e divided in to six broad classes of instruction.
â€¢ Data Mo v emen t â€¢ Logical and Bit Manipulation
â€¢ Arithmetic â€¢ Flo w Con trol
â€¢ Memory A ccess â€¢ System Con trol / Privileged
Before w e lo ok at eac h of these groups in a little more detail there are a few ideas whic h b elong
to all groups w orth y of in v estigation.
3.5. INSTR UCTION SET 31
Op eration Op eration
Mnemonic Meaning Mnemonic Meaning
ADC A dd with Carry MVN Logical NOT
ADD A dd ORR Logical OR
AND Logical AND RSB Rev erse Subtract
BAL Unconditional Branc h RSC Rev erse Subtract with Carry
B/angbracketleft c c/angbracketright Branc h on Condition SBC Subtract with Carry
BIC Bit Clear SMLAL Mult A ccum Signed Long
BLAL Unconditional Branc h and Link SMULL Multiply Signed Long
BL/angbracketleft c c/angbracketright Conditional Branc h and Link STM Store Multiple
CMP Compare STR Store Register (W ord)
EOR Exclusiv e OR STRB Store Register (Byte)
LDM Load Multiple SUB Subtract
LDR Load Register (W ord) SWI Soft w are In terrupt
LDRB Load Register (Byte) SWP Sw ap W ord V alue
MLA Multiply A ccum ulate SWPB Sw ap Byte V alue
MOV Mo v e TEQ T est Equiv alence
MRS Load SPSR or CPSR TST T est
MSR Store to SPSR or CPSR UMLAL Mult A ccum Unsigned Long
MUL Multiply UMULL Multiply Unsigned Long
T able 3.3: Instruction Mnemonics
Mnemonic Condition Mnemonic Condition
CS C arry S et CC C arry C lear
EQ Eq ual (Zero Set) NE N ot E qual (Zero Clear)
VS O v ero w S et VC O v ero w C lear
GT G reater T han LT L ess T han
GE G reater Than or E qual LE L ess Than or E qual
PL Pl us (P ositiv e) MI Mi n us (Negativ e)
HI Hi gher Than LO L o w er Than (ak a CC )
HS H igher or S ame (ak a CS ) LS L o w er or S ame
T able 3.4:/angbracketleft c c/angbracketright (Condition co de) Mnemonics
3.5.1 Conditional Execution: /angbracketleft c c/angbracketright
Almost all ARM instructions con tain a c ondition eld whic h allo ws it to b e executed conditionally
dep enden t on the condition co de ags (3.3 on page 28). If the ags indicate that the corresp onding
condition is true when the instruction starts executing, it executes normally . Otherwise, the
instruction do es nothing.
T able 4.2 on page 42 sho ws a list of the condition co des and their mnemonics. T o indicate that an
instruction is conditional w e simply place the mnemonic for the condition co de after the mnemonic
for the instruction. If no condition co de mnemonic is used the instruction will alw a ys b e executed.
F or example the follo wing instruction will mo v e the v alue of the register R 1 in to the R 0 register
only when the Carry ag has b een set, R 0 will remain unaected if the C ag w as clear.
MOVCS R0, R1
Note that the Gr e ater and the L ess conditions are for use with signed n um b ers while the Higher
and L ower conditions are for use with unsigned n um b ers. These condition co des only really mak e
seance after a comparison ( CMP ) instruction, see A.5 on page 129.
32 CHAPTER 3. ARM AR CHITECTURE
Most data-pro cessing instructions can also up date the condition co des according to their result.
Placing an  S  after the mnemonic will cause the ags to b e up dated. F or example there are t w o
v ersions of the MOV instruction:
MOV R0, #0 Will mo v e the v alue 0 in to the register R 0 without setting the ags.
MOVS R0, #0 Will do the same, mo v e the v alue 0 in to the register R 0 , but it will also set
the condition co de ags accordingly , the Zero ag will b e set, the Negativ e ag
will b e reset and the Carry and oV ero w ags will not b e eected.
If an instruction has this abilit y w e denote it using /angbracketleft S/angbracketright in our description of the instruction. The
/angbracketleft S/angbracketright alw a ys comes after the /angbracketleft c c/angbracketright (conditional execution) mo dication if it is giv en. Th us the full
description of the mo v e instruction w ould b e:
MOV/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d ,/angbracketleft op1/angbracketright
With all this in mind what do es the follo wing co de fragmen t do?
MOVS R0, R1
MOVEQS R0, R2
MOVEQ R0, R3
The rst instruction will mo v e R 1 in to R 0 unconditionally , but it will also set the N and Z ags
accordingly . Th us the second instruction is only executed if the Z ag is set, i.e., the v alue of R 1
w as zero. If the v alue of R 1 w as not zero the instruction is skipp ed. If the second instruction is
executed it will cop y the v alue of R 2 in to R 0 and it will also set the N and Z ags according to
the v alue of R 2 . Th us the third instruction is only executed if b oth R 1 and R 2 are b oth zero.
3.5.2 Data Pro cessing Op erands: /angbracketleft op1/angbracketright
The ma jorit y of the instructions relate to data pro cessing of some form. One of the op erands
to these instructions is routed through the Barrel Shifter. This means that the op erand can b e
mo died b efore it is used. This can b e v ery useful when dealing with lists, tables and other
complex data structures. W e denote instructions of this t yp e as taking one of its argumen ts from
/angbracketleft op1/angbracketright .
An/angbracketleft op1/angbracketright argumen t ma y come from one of t w o sources, a constan t v alue or a register, and b e
mo died in v e dieren t w a ys. See Chapter ?? for more detailed information.
Unmo died V alue
Y ou can use a v alue or a register unmo died b y simply giving the v alue or the register name. F or
example the follo wing instructions will demonstrate the t w o metho ds:
MOV R0, #1234 Will mo v e the immediate constan t v alue 1234 10 in to the register R 0
MOV R0, R1 Will mo v e the v alue in the register R 1 in to the register R 0
Logical Shift Left
This will tak e the v alue of a register and shift the v alue up, to w ards the most signican t bit, b y n
bits. The n um b er of bits to shift is sp ecied b y either a constan t v alue or another register. The
lo w er bits of the v alue are replaced with a zero. This is a simple w a y of p erforming a m ultiply b y
a p o w er of 2 (Ã—2n).
3.5. INSTR UCTION SET 33
MOV R0, R1, LSL #2 R 0 will b ecome the v alue of R 1 shifted left b y 2 bits. The v alue of R 1
is not c hanged.
MOV R0, R1, LSL R2 R 0 will b ecome the v alue of R 1 shifted left b y the n um b er of bits
sp ecied in the R 2 register. R 0 is the only register to c hange, b oth R 1
and R 2 are not eected b y this op eration.
If the instruction is to set the status register, the carry ag ( C ) is the last bit that w as shifted out
of the v alue.
Logical Shift Righ t
Logical Shift Righ t is v ery similar to Logical Shift Left except it will shift the v alue to the righ t,
to w ards the lest signican t bit, b y n bits. It will replace the upp er bits with zeros, th us pro viding
an ecien t unsigned divide b y 2nfunction (|Ã·2n| ). The n um b er of bits to shift ma y b e sp ecied
b y either a constan t v alue or another register.
MOV R0, R1, LSR #2 R 0 will tak e on the v alue of R 1 shifted to the righ t b y 2 bits. The
v alue of R 1 is not c hanged.
MOV R0, R1, LSR R2 As b efore R 0 will b ecome the v alue of R 1 shifted to the righ t b y the
n um b er of bits sp ecied in the R 2 register. R 1 and R 2 are not altered
b y this op eration.
If the instruction is to set the status register, the carry ag ( C ) is the last bit to b e shifted out of
the v alue.
Arithmetic Shift Righ t
The Arithmetic Shift Righ t is rather similar to the Logical Shift Righ t, but rather than replacing
the upp er bits with a zero, it main tains the v alue of the most signican t bit. As the most signican t
bit is used to hold the sign, this means the sign of the v alue is main tained, th us pro viding a signed
divide b y 2nop eration (Ã·2n).
MOV R0, R1, ASR #2 Register R 0 will b ecome the v alue of register R 1 shifted to the righ t
b y 2 bits, with the sign main tained.
MOV R0, R1, ASR R2 Register R 0 will b ecome the v alue of the register R 1 shifted to the
righ t b y the n um b er of bits sp ecied b y the R 2 register. R 1 and R 2
are not altered b y this op eration.
Giv en the distinction b et w een the Logical and Arithmetic Shift Righ t, wh y is there no Arithmetic
Shift Left op eration?
As a signed n um b er is stored in t w o's complemen t the upp er most bits hold the sign of the n um b er.
These bits can b e considered insignican t unless the n um b er is of a sucien t size to require their
use. Th us an Arithmetic Shift Left is not required as the sign is automatically preserv ed b y the
Logical Shift.
Rotate Righ t
In the Rotate Righ t op eration, the lest signican t bit is copied in to the carry ( C ) ag, while the
v alue of the C ag is copied in to the most signican t bit of the v alue. In this w a y none of the bits
in the v alue are lost, but are simply mo v ed from the lo w er bits to the upp er bits of the v alue.
34 CHAPTER 3. ARM AR CHITECTURE
MOV R0, R1, ROR #2 This will rotate the v alue of R 1 b y t w o bits. The most signican t bit
of the resulting v alue will b e the same as the least signican t bit of
the original v alue. The second most signican t bit will b e the same
as the Carry ag. In the S v ersion the Carry ag will b e set to the
second least signican t bit of the original v alue. The v alue of R 1 is
not c hanged b y this op eration.
MOV R0, R1, ROR R2 Register R 0 will b ecome the v alue of the register R 1 rotated to the
righ t b y the n um b er of bits sp ecied b y the R 2 register. R 1 and R 2
are not altered b y this op eration.
Wh y is there no corresp onding Rotate Left op eration?
An A dd With Carry ( ADC , A.1 on page 127) to a zero v alue pro vides this service for a single bit.
The designers of the instruction set b eliev e that a Rotate Left b y more than one bit w ould nev er
b e required, th us they ha v e not pro vided a R OL function.
Rotate Righ t Extended
This is similar to a Rotate Righ t b y one bit. The extende d section of the fact that this function
mo v es the v alue of the Carry ( C ) ag in to the most signican t bit of the v alue, and the least
signican t bit of the v alue in to the Carry ( C ) ag. Th us it allo ws the Carry ag to b e propagated
though m ulti-w ord v alues, thereb y allo wing v alues larger than 32-bits to b e used in calculations.
MOV R0, R1 RRX The register R 0 b ecome the same as the v alue of the register R 1 rotated
though the carry ag b y one bit. The most signican t bit of the v alue
b ecomes the same as the curren t Carry ag, while the Carry ag will b e the
same as the least signican t bit or R 1 . The v alue of R 1 will not b e c hanged.
3.5.3 Memory A ccess Op erands: /angbracketleft op2/angbracketright
The memory address used in the memory access instructions ma y also mo died b y the barrel
shifter. This pro vides for more adv anced access to memory whic h is particularly useful when
dealing with more adv anced data structures. It allo ws pre- and p ost-incremen t instructions that
up date memory p oin ters as a side eect of the instruction. This mak es lo ops whic h pass though
memory more ecien t. W e denote instructions of this t yp e as taking one of its argumen ts from
/angbracketleft op2/angbracketright . F or a full discussion of the /angbracketleft op2/angbracketright addressing mo de w e refer the reader to Chapter ?? on
page ?? .
There are three main metho ds of sp ecifying a memory address ( /angbracketleft op2/angbracketright ), all of whic h include an
oset v alue of some form. This oset can b e sp ecied in one of three w a ys:
Constan t V alue
An immediate constan t v alue can b e pro vided. If no oset is sp ecied an immediate constan t
v alue of zero is assumed.
Register
The oset can b e sp ecied b y another register. The v alue of the register is added to the
address held in another register to form the nal address.
Scaled
The oset is sp ecied b y another register whic h can b e scaled b y one of the shift op erators
used for/angbracketleft op1/angbracketright . More sp ecically b y the Logical Shift Left ( LSL ), Logical Shift Righ t ( LSR ),
Arithmetic Shift Righ t ( ASR ), R Otate Righ t ( ROR ) or Rotate Righ t Extended ( RRX ) shift
op erators, where the n um b er of bits to shift is sp ecied as a constan t v alue.
3.5. INSTR UCTION SET 35
Oset A ddressing
In oset addr essing the memory address is formed b y adding (or subtracting) an oset to or from
the v alue held in a base register.
LDR R0, [R1] Will load the register R 0 with the 32-bit w ord at the memory
address held in the register R 1 . In this instruction there is no
oset sp ecied, so an oset of zero is assumed. The v alue of
R 1 is not c hanged in this instruction.
LDR R0, [R1, #4] Will load the register R 0 with the w ord at the memory ad-
dress calculated b y adding the constan t v alue 4 to the memory
address con tained in the R 1 register. The register R 1 is not
c hanged b y this instruction.
LDR R0, [R1, R2] Loads the register R 0 with the v alue at the memory address
calculated b y adding the v alue in the register R 1 to the v alue
held in the register R 2 . Both R 1 and R 2 are not altered b y
this op eration.
LDR R0, [R1, R2, LSL #2] Will load the register R 0 with the 32-bit v alue at the memory
address calculated b y adding the v alue in the R 1 register to the
v alue obtained b y shifting the v alue in R 2 left b y 2 bits. Both
registers, R 1 and R 2 are not eected b y this op eration.
This is particularly useful for indexing in to a complex data structure. The start of the data
structure is held in a b ase register, R 1 in this case, and the oset to access a particular eld within
the structure is then added to the base address. Placing the oset in a register allo ws it to b e
calculated at run time rather than xed. This allo ws for lo oping though a table.
A scaled v alue can also b e used to access a particular item of a table, where the size of the item
is a p o w er of t w o. F or example, to lo cate item 7 in a table of 32-bit v alues w e need only shift the
index v alue 6 left b y 2 bits ( 6Ã—22) to calculate the v alue w e need to add as an oset to the start
of the table held in a register, R 1 in our example. Remem b er that the computer coun t from zero,
th us w e use an index v alue of 6 rather than 7. A 32-bit n um b er requires 4 b ytes of storage whic h
is22, th us w e only need a 2-bit left shift.
Pre-Index A ddressing
In pr e-index addr essing the memory address if formed in the same w a y as for oset addressing.
The address is not only used to access memory , but the base register is also mo died to hold
the new v alue. In the ARM system this is kno wn as a write-b ack and is denoted b y placing a
exclamation mark after at the end of the /angbracketleft op2/angbracketright co de.
Pre-Index address can b e particularly useful in a lo op as it can b e used to automatically incremen t
or decremen t a coun ter or memory p oin ter.
36 CHAPTER 3. ARM AR CHITECTURE
LDR R0, [R1, #4]! Will load the register R 0 with the w ord at the memory address
calculated b y adding the constan t v alue 4 to the memory ad-
dress con tained in the R 1 register. The new memory address
is placed bac k in to the base register, register R 1 .
LDR R0, [R1, R2]! Loads the register R 0 with the v alue at the memory address
calculated b y adding the v alue in the register R 1 to the v alue
held in the register R 2 . The oset register, R 2 , is not altered
b y this op eration, the register holding the base address, R 1 ,
is mo died to hold the new address.
LDR R0, [R1, R2, LSL #2]! First calculates the new address b y adding the v alue in the
base address register, R 1 , to the v alue obtained b y shifting
the v alue in the oset register, R 2 , left b y 2 bits. It will then
load the 32-bit at this address in to the destination register, R 0 .
The new address is also written bac k in to the base register, R 1 .
The oset register, R 2 , will not b e eected b y this op eration.
P ost-Index A ddressing
In p ost-index addr ess the memory address is the base register v alue. As a side-eect, an oset
is added to or subtracted from the base register v alue and the result is written bac k to the base
register.
P ost-index addressing uses the v alue of the base register without mo dication. It then applies the
mo dication to the address and writes the new address bac k in to the base register. This can b e
used to automatically incremen t or decremen t a memory p oin ter after it has b een used, so it is
p oin ting to the next lo cation to b e used.
As the instruction m ust preform a write-bac k w e do not need to include an exclamation mark.
Rather w e mo v e the closing brac k et to include only the base register, as that is the register holding
the memory address w e are going to access.
LDR R0, [R1], #4 Will load the register R 0 with the w ord at the memory address
con tained in the base register, R 1 . It will then calculate the
new v alue of R 1 b y adding the constan t v alue 4 to the curren t
v alue of R 1 .
LDR R0, [R1], R2 Loads the register R 0 with the v alue at the memory address
held in the base register, R 1 . It will then calculate the new
v alue for the base register b y adding the v alue in the oset
register, R 2 , to the curren t v alue of the base register. The
oset register, R 2 , is not altered b y this op eration.
LDR R0, [R1], R2, LSL #2 First loads the 32-bit v alue at the memory address con tained in
the base register, R 1 , in to the destination register, R 0 . It will
then calculate the new v alue for the base register b y adding the
curren t v alue to the v alue obtained b y shifting the v alue in the
oset register, R 2 , left b y 2 bits. The oset register, R 2 , will
not b e eected b y this op eration.
4Instruction Set
Wh y are a micropro cessor's instructions referred to as an instruction set? Because the micropro-
cessor designer selects the instruction complemen t with great care; it m ust b e easy to execute
complex op erations as a sequence of simple ev en ts, eac h of whic h is represen ted b y one instruction
from a w ell-designed instruction set.
Assem bler often frigh ten users who are new to programming. Y et tak en in isolation, the op erations
in v olv ed in the execution of a single instruction are usually easy to follo w. F urthermore, y ou need
not attempt to understand all the instructions at once. As y ou study eac h of the programs in
these notes y ou will learn ab out the sp ecic instructions in v olv ed.
T able 4.1 lists the instruction mnemonics. This pro vides a surv ey of the pro cessors capabilities,
and will also b e useful when y ou need a certain kind of op eration but are either unsure of the
sp ecic mnemonics or not y et familiar with what instructions are a v ailable.
The app endix A giv es a detailed description of the individual instructions while c hapters 7 through
to 15 pro vide a discussion on ho w to use them.
The ARM instruction set can b e divided in to six broad classes of instruction.
â€¢ Data Mo v emen t â€¢ Logical and Bit Manipulation
â€¢ Arithmetic â€¢ Flo w Con trol
â€¢ Memory A ccess â€¢ System Con trol / Privileged
Before w e lo ok at eac h of these groups in a little more detail there are a few ideas whic h b elong
to all groups w orth y of in v estigation.
Imp ortan t Note:
The ARM instruction set can b e divided in to six broad classes of instruction:
â€¢ Data-pro cessing instructions (Data Mo v emen t)
â€¢ Branc h instructions (Flo w Con trol)
â€¢ Status register transfer instructions (Logic/Bit Bashing)
â€¢ Load and store instructions (Memory A ccess)
â€¢ Copro cessor instructions (System Con trol)
â€¢ Exception-generating instructions (Privileged)
37
38 CHAPTER 4. INSTR UCTION SET
Op eration Op eration
Mnemonic Meaning Mnemonic Meaning
ADC A dd with Carry MVN Logical NOT
ADD A dd ORR Logical OR
AND Logical AND RSB Rev erse Subtract
BAL Unconditional Branc h RSC Rev erse Subtract with Carry
B/angbracketleft c c/angbracketright Branc h on Condition SBC Subtract with Carry
BIC Bit Clear SMLAL Mult A ccum Signed Long
BLAL Unconditional Branc h and Link SMULL Multiply Signed Long
BL/angbracketleft c c/angbracketright Conditional Branc h and Link STM Store Multiple
CMP Compare STR Store Register (W ord)
EOR Exclusiv e OR STRB Store Register (Byte)
LDM Load Multiple SUB Subtract
LDR Load Register (W ord) SWI Soft w are In terrupt
LDRB Load Register (Byte) SWP Sw ap W ord V alue
MLA Multiply A ccum ulate SWPB Sw ap Byte V alue
MOV Mo v e TEQ T est Equiv alence
MRS Load SPSR or CPSR TST T est
MSR Store to SPSR or CPSR UMLAL Mult A ccum Unsigned Long
MUL Multiply UMULL Multiply Unsigned Long
T able 4.1: Instruction Mnemonics
4.0.4 Branc h instructions
As w ell as allo wing man y data-pro cessing or load instructions to c hange con trol o w b y writing
the PC, a standard Branc h instruction is pro vided with a 24-bit signed oset, allo wing forw ard
and bac kw ard branc hes of up to 32MB.
There is a Branc h and Link (BL) option that also preserv es the address of the instruction after
the branc h in R14, the LR. This pro vides a subroutine call whic h can b e returned from b y cop ying
the LR in to the PC.
4.0.5 Data-pro cessing instructions
The data-pro cessing instructions p erform calculations on the general-purp ose registers. There are
four t yp es of data-pro cessing instructions:
â€¢ Arithmetic/logic instructions
â€¢ Comparison instructions
â€¢ Multiply instructions
â€¢ Coun t Leading Zeros instruction
Arithmetic/logic instructions
There are t w elv e arithmetic/logic instructions whic h share a common instruction format. These
p erform an arithmetic or logical op eration on up to t w o source op erands, and write the result to a
destination register. They can also optionally up date the condition co de ags based on the result.
Of the t w o source op erands:
â€¢ one is alw a ys a register
39
â€¢ the other has t w o basic forms:
 an immediate v alue
 a register v alue, optionally shifted.
If the op erand is a shifted register, the shift amoun t can b e either an immediate v alue or the
v alue of another register. F our t yp es of shift can b e sp ecied. Ev ery arithmetic/logic instruction
can therefore p erform an arithmetic/logic and a shift op eration. As a result, ARM do es not ha v e
dedicated shift instructions.
Because the Pr o gr am Counter (PC) is a general-purp ose register, arithmetic/logic instructions
can write their results directly to the PC. This allo ws easy implemen tation of a v ariet y of jump
instructions.
Comparison instructions
There are four comparison instructions whic h use the same instruction format as the arith-
metic/logic instructions. These p erform an arithmetic or logical op eration on t w o source op erands,
but do not write the result to a register. They alw a ys up date the condition ags based on the
result.
The source op erands of comparison instructions tak e the same forms as those of arithmetic/logic
instructions, including the abilit y to incorp orate a shift op eration.
Multiply instructions
Multiply instructions come in t w o classes. Both t yp es m ultiply t w o 32-bit register v alues and store
their result:
32-bit result Normal. Stores the 32-bit result in a register.
64-bit result Long. Stores the 64-bit result in t w o separate registers.
Both t yp es of m ultiply instruction can optionally p erform an accum ulate op eration.
Coun t Leading Zeros instruction
The Coun t Leading Zeros (CLZ) instruction determines the n um b er of zero bits at the most
signican t end of a register v alue, up to the rst 1 bit. This n um b er is written to the destination
register of the CLZ instruction.
4.0.6 Status register transfer instructions
The status register transfer instructions transfer the con ten ts of the CPSR or an SPSR to or from
a general-purp ose register. W riting to the CPSR can:
â€¢ set the v alues of the condition co de ags
â€¢ set the v alues of the in terrupt enable bits
â€¢ set the pro cessor mo de
40 CHAPTER 4. INSTR UCTION SET
4.0.7 Load and store instructions
The follo wing load and store instructions are a v ailable:
â€¢ Load and Store Register
â€¢ Load and Store Multiple registers
â€¢ Sw ap register and memory con ten ts
Load and Store Register
Load Register instructions can load a 32-bit w ord, a 16-bit halfw ord or an 8-bit b yte from memory
in to a register. Byte and halfw ord loads can b e automatically zero-extended or sign-extended as
they are loaded.
Store Register instructions can store a 32-bit w ord, a 16-bit halfw ord or an 8-bit b yte from a
register to memory .
Load and Store Register instructions ha v e three primary addressing mo des, all of whic h use a b ase
r e gister and an oset sp ecied b y the instruction:
â€¢ In oset addr essing , the memory address is formed b y adding or subtracting an oset to or
from the base register v alue.
â€¢ In pr e-indexe d addr essing , the memory address is formed in the same w a y as for oset
addressing. As a side-eect, the memory address is also written bac k to the base register.
â€¢ In p ost-indexe d addr essing , the memory address is the base register v alue. As a side-eect,
an oset is added to or subtracted from the base register v alue and the result is written bac k
to the base register.
In eac h case, the oset can b e either an immediate or the v alue of an index r e gister . Register-based
osets can also b e scaled with shift op erations.
As the PC is a general-purp ose register, a 32-bit v alue can b e loaded directly in to the PC to
p erform a jump to an y address in the 4GB memory space.
Load and Store Multiple registers
Load Multiple (LDM) and Store Multiple (STM) instructions p erform a blo c k transfer of an y
n um b er of the general-purp ose registers to or from memory . F our addressing mo des are pro vided:
â€¢ pre-incremen t
â€¢ p ost-incremen t
â€¢ pre-decremen t
â€¢ p ost-decremen t
The base address is sp ecied b y a register v alue, whic h can b e optionally up dated after the
transfer. As the subroutine return address and PC v alues are in general-purp ose registers, v ery
ecien t subroutine en try and exit sequences can b e constructed with LDM and STM :
41
â€¢ A single STM instruction at subroutine en try can push register con ten ts and the return address
on to the stac k, up dating the stac k p oin ter in the pro cess.
â€¢ A single LDM instruction at subroutine exit can restore register con ten ts from the stac k, load
the PC with the return address, and up date the stac k p oin ter.
LDM and STM instructions also allo w v ery ecien t co de for blo c k copies and similar data mo v emen t
algorithms.
Sw ap register and memory con ten ts
A sw ap ( SWP ) instruction p erforms the follo wing sequence of op erations:
1. It loads a v alue from a register-sp ecied memory lo cation.
2. It stores the con ten ts of a register to the same memory lo cation.
3. It writes the v alue loaded in step 1 to a register.
By sp ecifying the same register for steps 2 and 3, the con ten ts of a memory lo cation and a register
are in terc hanged.
The sw ap op eration p erforms a sp ecial indivisible bus op eration that allo ws atomic up date of
semaphores. Both 32-bit w ord and 8-bit b yte semaphores are supp orted.
4.0.8 Copro cessor instructions
There are three t yp es of copro cessor instructions:
Data-pro cessing instructions These start a copro cessor-sp ecic in ternal op eration.
Data transfer instructions These transfer copro cessor data to or from memory . The address
of the transfer is calculated b y the ARM pro cessor.
Register transfer instructions These allo w a copro cessor v alue to b e transferred to or from an
ARM register.
4.0.9 Exception-generating instructions
T w o t yp es of instruction are designed to cause sp ecic exceptions to o ccur.
Soft w are in terrupt instructions SWI instructions cause a soft w are in terrupt exception to o c-
cur. These are normally used to mak e calls to an op erating system, to request an OS-dened
service. The exception en try caused b y a SWI instruction also c hanges to a privileged pro ces-
sor mo de. This allo ws an unprivileged task to gain access to privileged functions, but only
in w a ys p ermitted b y the OS.
Soft w are breakp oin t instructions BKPT instructions cause an ab ort exception to o ccur. If
suitable debugger soft w are is installed on the ab ort v ector, an ab ort exception generated in
this fashion is treated as a breakp oin t. If debug hardw are is presen t in the system, it can
instead treat a BKPT instruction directly as a breakp oin t, prev en ting the ab ort exception
from o ccurring.
42 CHAPTER 4. INSTR UCTION SET
Mnemonic Condition Mnemonic Condition
CS C arry S et CC C arry C lear
EQ Eq ual (Zero Set) NE N ot E qual (Zero Clear)
VS O v ero w S et VC O v ero w C lear
GT G reater T han LT L ess T han
GE G reater Than or E qual LE L ess Than or E qual
PL Pl us (P ositiv e) MI Mi n us (Negativ e)
HI Hi gher Than LO L o w er Than (ak a CC )
HS H igher or S ame (ak a CS ) LS L o w er or S ame
T able 4.2:/angbracketleft c c/angbracketright (Condition co de) Mnemonics
In addition to the ab o v e, the follo wing t yp es of instruction cause an Undened Instruction excep-
tion to o ccur:
â€¢ copro cessor instructions whic h are not recognized b y an y hardw are copro cessor
â€¢ most instruction w ords that ha v e not y et b een allo cated a meaning as an ARM instruction.
In eac h case, this exception is normally used either to generate a suitable error or to initiate
soft w are em ulation of the instruction.
4.0.10 Conditional Execution: /angbracketleft c c/angbracketright
Almost all ARM instructions con tain a c ondition eld whic h allo ws it to b e executed conditionally
dep enden t on the condition co de ags (3.3 on page 28). If the ags indicate that the corresp onding
condition is true when the instruction starts executing, it executes normally . Otherwise, the
instruction do es nothing.
T able 4.2 sho ws a list of the condition co des and their mnemonics. T o indicate that an instruction
is conditional w e simply place the mnemonic for the condition co de after the mnemonic for the
instruction. If no condition co de mnemonic is used the instruction will alw a ys b e executed.
F or example the follo wing instruction will mo v e the v alue of the register R 1 in to the R 0 register
only when the Carry ag has b een set, R 0 will remain unaected if the C ag w as clear.
MOVCS R0, R1
Note that the Gr e ater and the L ess conditions are for use with signed n um b ers while the Higher
and L ower conditions are for use with unsigned n um b ers. These condition co des only really mak e
seance after a comparison ( CMP ) instruction, see A.5 on page 129.
Most data-pro cessing instructions can also up date the condition co des according to their result.
Placing an  S  after the mnemonic will cause the ags to b e up dated. F or example there are t w o
v ersions of the MOV instruction:
MOV R0, #0 Will mo v e the v alue 0 in to the register R 0 without setting the ags.
MOVS R0, #0 Will do the same, mo v e the v alue 0 in to the register R 0 , but it will also set
the condition co de ags accordingly , the Zero ag will b e set, the Negativ e ag
will b e reset and the Carry and oV ero w ags will not b e eected.
If an instruction has this abilit y w e denote it using /angbracketleft S/angbracketright in our description of the instruction. The
/angbracketleft S/angbracketright alw a ys comes after the /angbracketleft c c/angbracketright (conditional execution) mo dication if it is giv en. Th us the full
description of the mo v e instruction w ould b e:
43
MOV/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d ,/angbracketleft op1/angbracketright
With all this in mind what do es the follo wing co de fragmen t do?
MOVS R0, R1
MOVEQS R0, R2
MOVEQ R0, R3
The rst instruction will mo v e R 1 in to R 0 unconditionally , but it will also set the N and Z ags
accordingly . Th us the second instruction is only executed if the Z ag is set, i.e., the v alue of R 1
w as zero. If the v alue of R 1 w as not zero the instruction is skipp ed. If the second instruction is
executed it will cop y the v alue of R 2 in to R 0 and it will also set the N and Z ags according to
the v alue of R 2 . Th us the third instruction is only executed if b oth R 1 and R 2 are b oth zero.
44 CHAPTER 4. INSTR UCTION SET
5Addressing Modes
5.1 Data Pro cessing Op erands: /angbracketleft op1/angbracketright
The ma jorit y of the instructions relate to data pro cessing of some form. One of the op erands
to these instructions is routed through the Barrel Shifter. This means that the op erand can b e
mo died b efore it is used. This can b e v ery useful when dealing with lists, tables and other
complex data structures. W e denote instructions of this t yp e as taking one of its argumen ts from
/angbracketleft op1/angbracketright .
An/angbracketleft op1/angbracketright argumen t ma y come from one of t w o sources, a constan t v alue or a register, and b e
mo died in v e dieren t w a ys. See Chapter ?? for more detailed information.
5.1.1 Unmo died V alue
Y ou can use a v alue or a register unmo died b y simply giving the v alue or the register name. F or
example the follo wing instructions will demonstrate the t w o metho ds:
MOV R0, #1234 Will mo v e the immediate constan t v alue 1234 10 in to the register R 0
MOV R0, R1 Will mo v e the v alue in the register R 1 in to the register R 0
5.1.2 Logical Shift Left
This will tak e the v alue of a register and shift the v alue up, to w ards the most signican t bit, b y n
bits. The n um b er of bits to shift is sp ecied b y either a constan t v alue or another register. The
lo w er bits of the v alue are replaced with a zero. This is a simple w a y of p erforming a m ultiply b y
a p o w er of 2 (Ã—2n).
MOV R0, R1, LSL #2 R 0 will b ecome the v alue of R 1 shifted left b y 2 bits. The v alue of R 1
is not c hanged.
MOV R0, R1, LSL R2 R 0 will b ecome the v alue of R 1 shifted left b y the n um b er of bits
sp ecied in the R 2 register. R 0 is the only register to c hange, b oth R 1
and R 2 are not eected b y this op eration.
If the instruction is to set the status register, the carry ag ( C ) is the last bit that w as shifted out
of the v alue.
45
46 CHAPTER 5. ADDRESSING MODES
5.1.3 Logical Shift Righ t
Logical Shift Righ t is v ery similar to Logical Shift Left except it will shift the v alue to the righ t,
to w ards the lest signican t bit, b y n bits. It will replace the upp er bits with zeros, th us pro viding
an ecien t unsigned divide b y 2nfunction (|Ã·2n| ). The n um b er of bits to shift ma y b e sp ecied
b y either a constan t v alue or another register.
MOV R0, R1, LSR #2 R 0 will tak e on the v alue of R 1 shifted to the righ t b y 2 bits. The
v alue of R 1 is not c hanged.
MOV R0, R1, LSR R2 As b efore R 0 will b ecome the v alue of R 1 shifted to the righ t b y the
n um b er of bits sp ecied in the R 2 register. R 1 and R 2 are not altered
b y this op eration.
If the instruction is to set the status register, the carry ag ( C ) is the last bit to b e shifted out of
the v alue.
5.1.4 Arithmetic Shift Righ t
The Arithmetic Shift Righ t is rather similar to the Logical Shift Righ t, but rather than replacing
the upp er bits with a zero, it main tains the v alue of the most signican t bit. As the most signican t
bit is used to hold the sign, this means the sign of the v alue is main tained, th us pro viding a signed
divide b y 2nop eration (Ã·2n).
MOV R0, R1, ASR #2 Register R 0 will b ecome the v alue of register R 1 shifted to the righ t
b y 2 bits, with the sign main tained.
MOV R0, R1, ASR R2 Register R 0 will b ecome the v alue of the register R 1 shifted to the
righ t b y the n um b er of bits sp ecied b y the R 2 register. R 1 and R 2
are not altered b y this op eration.
Giv en the distinction b et w een the Logical and Arithmetic Shift Righ t, wh y is there no Arithmetic
Shift Left op eration?
As a signed n um b er is stored in t w o's complemen t the upp er most bits hold the sign of the n um b er.
These bits can b e considered insignican t unless the n um b er is of a sucien t size to require their
use. Th us an Arithmetic Shift Left is not required as the sign is automatically preserv ed b y the
Logical Shift.
5.1.5 Rotate Righ t
In the Rotate Righ t op eration, the lest signican t bit is copied in to the carry ( C ) ag, while the
v alue of the C ag is copied in to the most signican t bit of the v alue. In this w a y none of the bits
in the v alue are lost, but are simply mo v ed from the lo w er bits to the upp er bits of the v alue.
5.2. MEMOR Y A CCESS OPERANDS: /angbracketleft OP2/angbracketright 47
MOV R0, R1, ROR #2 This will rotate the v alue of R 1 b y t w o bits. The most signican t bit
of the resulting v alue will b e the same as the least signican t bit of
the original v alue. The second most signican t bit will b e the same
as the Carry ag. In the S v ersion the Carry ag will b e set to the
second least signican t bit of the original v alue. The v alue of R 1 is
not c hanged b y this op eration.
MOV R0, R1, ROR R2 Register R 0 will b ecome the v alue of the register R 1 rotated to the
righ t b y the n um b er of bits sp ecied b y the R 2 register. R 1 and R 2
are not altered b y this op eration.
Wh y is there no corresp onding Rotate Left op eration?
An A dd With Carry ( ADC , A.1 on page 127) to a zero v alue pro vides this service for a single bit.
The designers of the instruction set b eliev e that a Rotate Left b y more than one bit w ould nev er
b e required, th us they ha v e not pro vided a R OL function.
5.1.6 Rotate Righ t Extended
This is similar to a Rotate Righ t b y one bit. The extende d section of the fact that this function
mo v es the v alue of the Carry ( C ) ag in to the most signican t bit of the v alue, and the least
signican t bit of the v alue in to the Carry ( C ) ag. Th us it allo ws the Carry ag to b e propagated
though m ulti-w ord v alues, thereb y allo wing v alues larger than 32-bits to b e used in calculations.
MOV R0, R1 RRX The register R 0 b ecome the same as the v alue of the register R 1 rotated
though the carry ag b y one bit. The most signican t bit of the v alue
b ecomes the same as the curren t Carry ag, while the Carry ag will b e the
same as the least signican t bit or R 1 . The v alue of R 1 will not b e c hanged.
5.2 Memory A ccess Op erands: /angbracketleft op2/angbracketright
The memory address used in the memory access instructions ma y also mo died b y the barrel
shifter. This pro vides for more adv anced access to memory whic h is particularly useful when
dealing with more adv anced data structures. It allo ws pre- and p ost-incremen t instructions that
up date memory p oin ters as a side eect of the instruction. This mak es lo ops whic h pass though
memory more ecien t. W e denote instructions of this t yp e as taking one of its argumen ts from
/angbracketleft op2/angbracketright . F or a full discussion of the /angbracketleft op2/angbracketright addressing mo de w e refer the reader to Chapter ?? on
page ?? .
There are three main metho ds of sp ecifying a memory address ( /angbracketleft op2/angbracketright ), all of whic h include an
oset v alue of some form. This oset can b e sp ecied in one of three w a ys:
Constan t V alue
An immediate constan t v alue can b e pro vided. If no oset is sp ecied an immediate constan t
v alue of zero is assumed.
Register
The oset can b e sp ecied b y another register. The v alue of the register is added to the
address held in another register to form the nal address.
48 CHAPTER 5. ADDRESSING MODES
Scaled
The oset is sp ecied b y another register whic h can b e scaled b y one of the shift op erators
used for/angbracketleft op1/angbracketright . More sp ecically b y the Logical Shift Left ( LSL ), Logical Shift Righ t ( LSR ),
Arithmetic Shift Righ t ( ASR ), R Otate Righ t ( ROR ) or Rotate Righ t Extended ( RRX ) shift
op erators, where the n um b er of bits to shift is sp ecied as a constan t v alue.
5.2.1 Oset A ddressing
In oset addr essing the memory address is formed b y adding (or subtracting) an oset to or from
the v alue held in a base register.
LDR R0, [R1] Will load the register R 0 with the 32-bit w ord at the memory
address held in the register R 1 . In this instruction there is no
oset sp ecied, so an oset of zero is assumed. The v alue of
R 1 is not c hanged in this instruction.
LDR R0, [R1, #4] Will load the register R 0 with the w ord at the memory ad-
dress calculated b y adding the constan t v alue 4 to the memory
address con tained in the R 1 register. The register R 1 is not
c hanged b y this instruction.
LDR R0, [R1, R2] Loads the register R 0 with the v alue at the memory address
calculated b y adding the v alue in the register R 1 to the v alue
held in the register R 2 . Both R 1 and R 2 are not altered b y
this op eration.
LDR R0, [R1, R2, LSL #2] Will load the register R 0 with the 32-bit v alue at the memory
address calculated b y adding the v alue in the R 1 register to the
v alue obtained b y shifting the v alue in R 2 left b y 2 bits. Both
registers, R 1 and R 2 are not eected b y this op eration.
This is particularly useful for indexing in to a complex data structure. The start of the data
structure is held in a b ase register, R 1 in this case, and the oset to access a particular eld within
the structure is then added to the base address. Placing the oset in a register allo ws it to b e
calculated at run time rather than xed. This allo ws for lo oping though a table.
A scaled v alue can also b e used to access a particular item of a table, where the size of the item
is a p o w er of t w o. F or example, to lo cate item 7 in a table of 32-bit v alues w e need only shift the
index v alue 6 left b y 2 bits ( 6Ã—22) to calculate the v alue w e need to add as an oset to the start
of the table held in a register, R 1 in our example. Remem b er that the computer coun t from zero,
th us w e use an index v alue of 6 rather than 7. A 32-bit n um b er requires 4 b ytes of storage whic h
is22, th us w e only need a 2-bit left shift.
5.2. MEMOR Y A CCESS OPERANDS: /angbracketleft OP2/angbracketright 49
5.2.2 Pre-Index A ddressing
In pr e-index addr essing the memory address if formed in the same w a y as for oset addressing.
The address is not only used to access memory , but the base register is also mo died to hold
the new v alue. In the ARM system this is kno wn as a write-b ack and is denoted b y placing a
exclamation mark after at the end of the /angbracketleft op2/angbracketright co de.
Pre-Index address can b e particularly useful in a lo op as it can b e used to automatically incremen t
or decremen t a coun ter or memory p oin ter.
LDR R0, [R1, #4]! Will load the register R 0 with the w ord at the memory address
calculated b y adding the constan t v alue 4 to the memory ad-
dress con tained in the R 1 register. The new memory address
is placed bac k in to the base register, register R 1 .
LDR R0, [R1, R2]! Loads the register R 0 with the v alue at the memory address
calculated b y adding the v alue in the register R 1 to the v alue
held in the register R 2 . The oset register, R 2 , is not altered
b y this op eration, the register holding the base address, R 1 ,
is mo died to hold the new address.
LDR R0, [R1, R2, LSL #2]! First calculates the new address b y adding the v alue in the
base address register, R 1 , to the v alue obtained b y shifting
the v alue in the oset register, R 2 , left b y 2 bits. It will then
load the 32-bit at this address in to the destination register, R 0 .
The new address is also written bac k in to the base register, R 1 .
The oset register, R 2 , will not b e eected b y this op eration.
5.2.3 P ost-Index A ddressing
In p ost-index addr ess the memory address is the base register v alue. As a side-eect, an oset
is added to or subtracted from the base register v alue and the result is written bac k to the base
register.
P ost-index addressing uses the v alue of the base register without mo dication. It then applies the
mo dication to the address and writes the new address bac k in to the base register. This can b e
used to automatically incremen t or decremen t a memory p oin ter after it has b een used, so it is
p oin ting to the next lo cation to b e used.
50 CHAPTER 5. ADDRESSING MODES
As the instruction m ust preform a write-bac k w e do not need to include an exclamation mark.
Rather w e mo v e the closing brac k et to include only the base register, as that is the register holding
the memory address w e are going to access.
LDR R0, [R1], #4 Will load the register R 0 with the w ord at the memory address
con tained in the base register, R 1 . It will then calculate the
new v alue of R 1 b y adding the constan t v alue 4 to the curren t
v alue of R 1 .
LDR R0, [R1], R2 Loads the register R 0 with the v alue at the memory address
held in the base register, R 1 . It will then calculate the new
v alue for the base register b y adding the v alue in the oset
register, R 2 , to the curren t v alue of the base register. The
oset register, R 2 , is not altered b y this op eration.
LDR R0, [R1], R2, LSL #2 First loads the 32-bit v alue at the memory address con tained in
the base register, R 1 , in to the destination register, R 0 . It will
then calculate the new v alue for the base register b y adding the
curren t v alue to the v alue obtained b y shifting the v alue in the
oset register, R 2 , left b y 2 bits. The oset register, R 2 , will
not b e eected b y this op eration.
6Programs
The only w a y to learn assem bly language programming is through exp erience. Throughout the rest
of this b o ok eac h c hapter will in tro duce v arious asp ects of assem bly programming. The c hapter
will start with a general discussion, then mo v e on to a n um b er of example programs whic h will
demonstrate the topic under discussion. The c hapter will end with a n um b er of programming
problems for y ou to try .
6.1 Example Programs
Eac h of the program examples con tains sev eral parts:
Title that describ es the general problem
Purp ose statemen t of purp ose that describ es the task the program p erforms
and the memory lo cations used.
Problem A sample problem complete with data and results.
Algorithm if the program logic is complex.
Source co de for the assem bly program.
Notes Explanatry notes that discusses the instructions and metho ds used
in the program.
Eac h example is written and assem bled as a stand-alone program. They can b e do wnloaded from
the w eb site1.
6.1.1 Program Listing F ormat
The examples in the b o ok are the actual source co de used to generate the programs. Sometimes
y ou ma y need to use the listing output of the ARM assem bler (the .list le), and in an y case y ou
should b e a w are of the fact that y ou can generate a listing le. See the section on the ARMulator
en vironmen t whic h follo ws for details of ho w to generate a .list listing le.
6.1.2 Guidelines for Examples
W e ha v e used the follo wing guidelines in construction of the examples:
1. Standard ARM assem bler notation is used, as summarized in Chapter 2.
2. The forms in whic h data and addresses app ear are selected for clarit y rather than for con-
sistency . W e use hexadecimal n um b ers for memory addresses, instruction co des, and BCD
data; decimal for n umeric constan ts; binary for logical masks; and ASCI I for c haracters.
1h ttp://dec.b ournemouth.ac.uk/supp ort/sem/sysarc h/examples.zip
51
52 CHAPTER 6. PR OGRAMS
3. F requen tly used instructions and programming tec hniques are emphasized.
4. Examples illustrate tasks that micropro cessors p erform in comm unication, instrumen tation,
computers, business equipmen t, industrial, and military applications.
5. Detailed commen ts are included.
6. Simple and clear structures are emphasised, but programs are written as ecien tly as p ossible
within this guideline. Notes accompan ying programs often describ e more ecien t pro cedures.
7. Program are written as an indep enden t pro cedures or subroutines although no assumptions
are made concerning the state of the micropro cessor on en try to the pro cedure.
8. Program end with a SWI &11 (Soft w are In terrupt) instruction. Y ou ma y prefer to mo dify
this b y replacing the SWI &11 instruction with an endless lo op instruction suc h as:
HERE BAL HERE
9. Programs use standard ARM assem bler directiv es. W e in tro duced assem bler directiv es con-
ceptually in Chapter 2. When rst examining programming examples, y ou can ignore the
assem bler directiv es if y ou do not understand them. Assem bler directiv es do not con tribute
to program logic, whic h is what y ou will b e trying to understand initially; but they are a nec-
essary part of ev ery assem bly language program, so y ou will ha v e to learn ho w to use them
b efore y ou write an y executable programs. Including assem bler directiv es in all program
examples will help y ou b ecome familiar with the functions they p erform.
6.2 T rying the examples
T o test one of the example programs, rst obtain a cop y of the source co de. The b est w a y of doing
this is to t yp e in the source co de presen ted in this b o ok, as this will help y ou to understand the
co de. Alternativ ely y ou can do wnload the source from the w eb site, although y ou w on't gain the
same kno wledge of the co de.
Go to the start men u and call up the Arm ulate program. Next op en the source le using the
normal File | Op en men u option. This will op en y our program source in a separate windo w
within the Arm ulate en vironmen t.
The next step is to create a new Pro ject within the en vironmen t. Select the Pro ject men u option,
then New. Giv e y our pro ject the same name as the source le that y ou are using (there is no
need to use a le extension  it will automatically b e sa v ed as a .apj le).
Once y ou ha v e giv en the le a name, a further dialog will op en as sho wn in the gure 6.1 on the
next page.
Clic k the A dd button, and y ou will again b e presen ted with a le dialog, whic h will displa y the
source les in the curren t directory . Select the relev an t source le and OK the dialog. Y ou will
b e returned to the previous dialog, but y ou will see no w that y our source le is included in the
pro ject. OK the Edit Pro ject dialog, and y ou will b e returned to the Arm ulate en vironmen t,
no w with t w o windo ws op en within it, one for the source co de and one for the pro ject.
W e recommend that y ou alw a ys create a .list listing le for eac h pro ject that y ou create. Do
this b y selecting the Options men u with the pro ject windo w in fo cus, then the Assem bler item.
This will op en the dialog sho wn in gure 6.2 on the facing page.
En ter -list [yourfilename].list in to the Other text b o x and OK the dialog.
Y ou ha v e no w created y our pro ject and are ready to assem ble and debug y our co de.
A dditional information on the Arm ulator is a v ailable via the help men u item.
6.3. TR YING THE EXAMPLES FR OM THE COMMAND LINE 53
Figure 6.1: New Pro ject Dialog
Figure 6.2: Assem bler Options Dialog
6.3 T rying the examples from the command line
When dev eloping the example programs, w e found the Arm ulate en vironmen t to o clumsy . W e
used the T extP ad editor and assem bled the programs from the command line. The Arm ulate
en vironmen t pro vides commands for use from the command line:
1. Assem bler
The command line assem bler is used to create an ob ject le from the program source co de.
During the dev elopmen t of the add program (program 7.3a) w e used the command line:
ARMASM -LI -CPU ARM6 -g -list add.list add.s
2. Link er
It is necessary to p osition the program at a xed lo cation in memory . This is done using the
link er. In our add example w e used the command:
ARMLINK -o add add.o
Whic h resolv es the relativ e addresses in the add.o le, pro ducing the add load image.
3. Debugger
Finally it is necessary to debug the load image. This can b e done in one of t w o w a ys, using
a command line debugger or the windo ws debugger. In either case they require a load image
( add in our example). T o use the command line debugger (kno wn as the source debugger)
the follo wing command is used:
ARMSD add
Ho w ev er, the command driv en nature of this system is confusing and hard to use for ev en
the most exp erienced of dev elop ers. Th us w e suggest y ou use the windo ws based debugger
program:
54 CHAPTER 6. PR OGRAMS
WINDBG add
Whic h will pro vide y ou with the same debugger y ou w ould ha v e seen had y ou used the
Windo w based Arm ulate en vironmen t.
6.3.1 Setting up T extP ad
T o set up this en vironmen t simply do wnload the T extP ad editor and the ARM Assem bler syn tax
le. Y ou can do wnload the editor from the do wnload page of the T extP ad w eb site2.
Do wnload Derek La w's ARM Assem bler Syn tax Denition le from the T extP ad w eb site. Y ou
can nd this under the Syntax Denition sub-section of the A dd-ons section of the Downlo ad page.
Unpac k the armasm.syn from the arm.zip le in to the T extP ad Samples directory .
Ha ving installed the Syn tax Denitions y ou should no w add a new Do cumen t Class to T extP ad.
Run T extP ad and select the New Do cument Class. . . wizard from the Congure men u. The wizard
will no w tak e y ou though the follo wing steps:
1. The Do cumen t Class requires a name. W e ha v e used the name  ARM Assembler .
2. The Class Mem b ers, the le name extension to asso ciate with this do cumen t class. W e
asso ciate all .s and .list les with this class:  *.s,*.list 
3. Syn tax Highligh ting. The next dialog is where w e tell T extP ad to use syn tax highligh ting,
simply c hec k the Enable Syn tax Highligh ting b o x. W e no w need to tell it whic h syn tax
denition le to use. If the armasm.syn le w as placed in the Samples directory , this will
app ear in the drop do wn list, and should b e selected.
While this will create the new do cumen t class, y ou will almost certainly w an t to c hange the colour
settings for this do cumen t class. This class uses the dieren t lev els of Keyw ord colouring for
dieren t asp ects of the syn tax as follo ws:
Keyw ords 1 Instructions
Keyw ords 2 Co-pro cessor and pseudo-instructions
Keyw ords 3 Shift-addresses and logical directiv es
Keyw ords 4 Registers
Keyw ords 5 Directiv es
Keyw ords 6 Argumen ts and built-in names
Y ou will probably w an t to set the color ( sic ) setting for all of these t yp es to the same settings.
W e ha v e set all but Keyw ords 2 to the same colour sc heme. T o alter the color setting y ou should
select the Preferences. . . option from the Congure men u.
In the Preference dialog (sho wn in gure 6.4 on the next page), op en the Do cument Classes
section and then y our new do cumen t class ( ARM Assembler ). No w y ou should select the colo rs
section. This will no w allo w y ou to c hange the colours for an y of the giv en color settings.
Finally y ou ma y lik e to consider adding a File T yp e Filter to the Op en File dialog. This
can b e done b y selecting the File T yp e Filter en try in the Preference dialog. Simply clic k on the
New button, add the description (ARM Assem bler (*.s, *.list)) and wildcard (*.s;*.list) details.
Finally clic k on the OK button.
Note the use of a comma to sep erate the wildcards in the description, and the use of a semi-colon
(without spaces) in the wildcard en try .
2h ttp://www.textpad.com
6.4. PR OGRAM INITIALIZA TION 55
Figure 6.3: T extP ad Colour Preferences Dialog
Figure 6.4: T extP ad File Name Filters Preferences Dialog
6.4 Program Initialization
All of the programming examples presen ted in these notes pa y particular atten tion to the correct
initialization of constan ts and op erands. Often this requires additional instructions that ma y
app ear sup eruous, in that they do not con tribute directly to the solution of the stated problem.
Nev ertheless, correct initialization is imp ortan t in order to ensure the prop er execution of the
program ev ery time.
W e w an t to stress correct initialization; that is wh y w e are going to emphasize this asp ect of
problems.
6.5 Sp ecial Conditions
F or the same reasons that w e pa y particular atten tion to sp ecial conditions that can cause a pro-
gram to fail. Empt y lists and zero indexes are t w o of the most common circumstances o v erlo ok ed
in sample problems. It is critically imp ortan t when using micropro cessors that y ou learn with y our
v ery rst program to an ticipate un usual circumstances; they frequen tly cause y our program to fail.
Y ou m ust build in the necessary programming steps to accoun t for these p oten tial problems.
6.6 Problems
Eac h c hapter will no w end with a n um b er of programming problems for y our to try . They ha v e
b een pro vided to help y ou understand the ideas presen ted in the c hapter. Y ou should use the
56 CHAPTER 6. PR OGRAMS
programming examples as guidelines for solving the problems. Don't forget to run y our solutions
on the ARMulator to ensure that they are correct.
The follo wing guidelines will help in solving the problems:
1. Commen t eac h program so that others can understand it. The commen ts can b e brief and
ungrammatical. They should explain the purp ose of a section or instruction in the program,
but should not describ e the op eration of instructions, that description is a v ailable in man uals.
F or example the follo wing line:
ADD R1, R1, #1
could b e giv en the commen t A dd one to R1 or Incremen t R1, b oth of whic h pro vide no
indication as to why the line is there. They tell us what the instruction is doing, but w e can
tell that b y lo oking at the instruction itself. W e are more in terested in wh y the instruction
is there. A commen t suc h as Incremen t lo op coun ter is m uc h more useful as it explains
wh y y ou are adding one to R 1 , the lo op coun ter.
Y ou do not ha v e to commen t eac h statemen t or explain the ob vious. Y ou ma y follo w the
format of the examples but pro vide less detail.
2. Emphasise clarit y , simplicit y , and go o d structure in programs. While programs should b e
reasonably ecien t, do not w orry ab out sa ving a single b yte of program memory or a few
microseconds.
3. Mak e programs reasonably general. Do not confuse parameters (suc h as the n um b er of
elemen ts in an y arra y) with xed constan ts (suc h as the co de for the letter C).
4. Nev er assume xed initial v alues for parameters.
5. Use assem bler notation as sho wn in the examples and dened in Chapter 2.
6. Use sym b olic notation for address and data references. Sym b olic notation should also b e
used ev en for constan ts (suc h as DATA_SELECT instead of 2_00000100 ). Also use the clearest
p ossible form for data (suc h as 'C' instead of 0x43 ).
7. Use meaningful names for lab els and v ariables, e.g., SUM or CHECK rather than X or Z .
8. Execute eac h program with the em ulator. There is no other w a y of ensuring that y our
program is correct. W e ha v e pro vided sample data with eac h problem. Be sure that the
program w orks for sp ecial cases.
7Data Movement
This c hapter con tains some v ery elemen tary programs. They will in tro duce some fundamen tal
features of the ARM. In addition, these programs demonstrate some primitiv e tasks that are
common to assem bly language programs for man y dieren t applications.
7.1 Program Examples
7.1.1 16-Bit Data T ransfer
Mo v e the con ten ts of one 16-bit v ariable Value to another 16-bit v ariable Result .
Sample Problems
Input: Value = C123
Output: Result = C123
Program 7.1: move16.s  16bit data tr ansfer
1 ; 16-Bit data transfer
2
3 TTL Ch4ex1 - move16
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDRB R1, Value ; Load the value to be moved
9 STR R1, Result ; Store it back in a different location
10 SWI &11
11
12 Value DCW &C123 ; Value to be moved
13 ALIGN ; Need to do this because working with 16bit value
14 Result DCW 0 ; Storage space
15
16 END
This program solv es the problem in t w o simple steps. The rst instruction loads data register R 1
with the 16-bit v alue in lo cation Value . The next instruction sa v es the 16-bit con ten ts of data
register R 1 in lo cation Result .
As a reminder of the necessary elemen ts of an assem bler program for the ARMulator, notice that
this, and all the other example programs ha v e the follo wing elemen ts. Firstly there m ust b e an
ENTRY directiv e. This tells the assem bler where the rst executable instruction is lo cated. Next
there m ust b e at least one AREA directiv e, at the start of the program, and there ma y b e other
AREA directiv es to dene data storage areas. Finally there m ust b e an END directiv e, to sho w where
the co de ends. The absence of an y of these will cause the assem bly to fail with an error.
Another limitation to b ear in mind is that ARMulator instructions will only deal with BYTE (8
bits) or WORD (32 bit) data sizes. It is p ossible to declare HALF-WORD (16 bit) v ariables b y the use
57
58 CHAPTER 7. D A T A MO VEMENT
of the DCW directiv e, but it is necessary to ensure consistency of storage of HALF-WORD b y the use
of the ALIGN directiv e. Y ou can see the use of this in the rst w ork ed example.
In addition, under the RISC arc hitecture of the ARM, it is not p ossible to directly manipulate
data in storage. Ev en if no actual manipulation of the data is taking place, as in this rst example,
it is necessary to use the LDR or LDRB and STR or STRB to mo v e data to a dieren t area of memory .
This v ersion of the LDR instruction mo v es the 32-bit w ord con tained in memory lo cation Value
in to a register and then stores it using the STR instruction at the memory lo cation sp ecied b y
Result .
Notice that, b y default, ev ery program is allo cated a literal p o ol (a storage area) after the last
executable line. In the case of this, and most of the other programs, w e ha v e formalised this b y
the use of the AREA Data1, DATA directiv e. Instruction on ho w to nd addresses of v ariables
will b e giv en in the seminars.
7.1.2 One's Complemen t
F rom the bit wise complemen t of the con ten ts of the 16-bit v ariable Value .
Sample Problems
Input: Value = C123
Output: Result = FFFF3EDC
Program 7.2: invert.s  Find the one's c ompliment (inverse) of a numb er
1 ; Find the one's compliment (inverse) of a number
2
3 TTL Ch4Ex2 - invert
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value ; Load the number to be complimented
9 MVN R1, R1 ; NOT the contents of R1
10 STR R1, Result ; Store the result
11 SWI &11
12
13 Value DCD &C123 ; Value to be complemented
14 Result DCD 0 ; Storage for result
15
16 END
This program solv es the problem in three steps. The rst instruction mo v es the con ten ts of
lo cation Value in to data register R 1 . The next instruction MVN tak es the logical complemen t of
data register R 1 . Finally , in the third instruction the result of the logical complemen t is stored in
Value .
Note that an y data register ma y b e referenced in an y instruction that uses data registers, but note
the use of R 15 for the program coun ter, R 14 for the link register and R 13 for the stac k p oin ter.
Th us, in the LDR instruction w e'v e just illustrated, an y of the general purp ose registers could ha v e
b een used.
The LDR and STR instructions in this program, lik e those in Program 7.1, demonstrate one of
the ARM's addressing mo des. The data reference to Value as a source op erand is an example
of immediate addressing. In immediate addressing the oset to the address of the data b eing
referenced (less 8 b y es) is con tained in the extension w ord(s) follo wing the op eration w ord of the
instruction. As sho wn in the assem bly listing, the oset to the address corresp onding to Value is
found in the extension w ord for the LDR and STR instructions.
7.1. PR OGRAM EXAMPLES 59
7.1.3 32-Bit A ddition
A dd the con ten ts of the 32-bit v ariable Value1 to the con ten ts of the 32-bit v ariable Value2 and
place the result in the 32-bit v ariable Result .
Sample Problems
Input: Value1 = 37E3C123
Value2 = 367402AA
Output: Result = 6E57C3CD
Program 7.3a: add.s  A dd two numb ers
1 ; Add two (32-Bit) numbers
2
3 TTL Ch4Ex3 - add
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value1 ; Load the first number
9 LDR R2, Value2 ; Load the second number
10 ADD R1, R1, R2 ; ADD them together into R1 (x = x + y)
11 STR R1, Result ; Store the result
12 SWI &11
13
14 Value1 DCD &37E3C123 ; First value to be added
15 Value2 DCD &367402AA ; Second value to be added
16 Result DCD 0 ; Storage for result
17
18 END
The ADD instruction in this program is an example of a three-op erand instruction. Unlik e the LDR
instruction, this instruction's third op erand not only represen ts the instruction's destination but
ma y also b e used to calculate the result. The format:
DESTINA TIONâ† SOUR CE1 op er ation SOUR CE2
is common to man y of the instructions.
As with an y micropro cessor, there are man y instruction sequences y ou can execute whic h will solv e
the same problem. Program 7.3b, for example, is a mo dication of Program 7.3a and uses oset
addressing instead of immediate addressing.
Program 7.3b: add2.s  A dd two numb ers and stor e the r esult
1 ; Add two numbers and store the result
2
3 TTL Ch4Ex4 - add2
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Value1 ; Load the address of first value
9 LDR R1, [R0] ; Load what is at that address
10 ADD R0, R0, #0x4 ; Adjust the pointer
11 LDR R2, [R0] ; Load what is at the new addr
12 ADD R1, R1, R2 ; ADD together
13 LDR R0, =Result ; Load the storage address
14 STR R1, [R0] ; Store the result
15 SWI &11 ; All done
16
60 CHAPTER 7. D A T A MO VEMENT
17 Value1 DCD &37E3C123 ; First value
18 Value2 DCD &367402AA ; Second value
19 Result DCD 0 ; Space to store result
20
21 END
The ADR pseudo-instruction in tro duces a new addressing mo de  oest addressing, whic h w e
ha v e not used previously . Immediate addressing lets y ou dene a data constan t and include that
constan t in the instruction's asso ciated ob ject co de. The assem bler format iden ties immediate
addressing with a # preceding the data constan t. The size of the data constan t v aries dep ending
on the instruction. Immediate addressing is extremely useful when small data constan ts m ust b e
referenced.
The ADR pseudo-instruction could b e replaced b y the use of the instruction LDR together with the
use of the = to indicate that the address of the data should b e loaded rather than the data itself.
The second addressing mo de  oset addressing  uses immediate addressing to load a p oin ter
to a memory address in to one of the general purp ose registers.
Program 7.3b also demonstrates the use of base register plus oset addressing. In this example
w e ha v e p erformed this op eration man ually on line 10 ( ADD R0, R0, #0x4 ), whic h incremen ts the
address stored in R 0 b y 4 b ytes or one WORD . There are m uc h simpler and more ecien t w a ys of
doing this, suc h as pre-index or p ost-index addressing whic h w e will see in later examples.
Another adv an tage of this addressing mo de is its faster execution time as compared to immediate
addressing. This impro v emen t o ccurs b ecause the address extension w ord(s) do es not ha v e to b e
fetc hed from memory prior to the actual data reference, after the initial fetc h.
A nal adv an tage is the exibilit y pro vided b y ha ving R 0 hold an address instead of b eing xed as
part of the instruction. This exibilit y allo ws the same co de to b e used for more than one address.
Th us if y ou w an ted to add the v alues con tained in consecutiv e v ariables Value3 and Value4 , y ou
could simply c hange the con ten ts of R 0 .
7.1.4 Shift Left One Bit
Shift the con ten ts of the 16-bit v ariable Value to the left one bit. Store the result bac k in Result .
Sample Problems
Input: Value = 4242 (0100 0010 0100 0010 2 )
Output: Result = 8484 (1000 0100 1000 0100 2 )
Program 7.4: shiftleft.s  Shift L eft one bit
1 ; Shift Left one bit
2
3 TTL Ch4Ex5 - shiftleft
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value ; Load the value to be shifted
9 MOV R1, R1, LSL #0x1 ; SHIFT LEFT one bit
10 STR R1, Result ; Store the result
11 SWI &11
12
13 Value DCD &4242 ; Value to be shifted
14 Result DCD 0 ; Space to store result
15
16 END
7.1. PR OGRAM EXAMPLES 61
The MOV instruction is used to p erform a logical shift left. Using the op erand format of the MOV
instruction sho wn in Program 7.4, a data register can b e shifted from 1 to 25 bits on either a b yte,
w ord or longw ord basis. Another form of the LSL op eration allo ws a shift coun ter to b e sp ecied
in another data register.
7.1.5 Byte Disassem bly
Divide the least signican t b yte of the 8-bit v ariable Value in to t w o 4-bit nibbles and store one
nibble in eac h b yte of the 16-bit v ariable Result . The lo w-order four bits of the b yte will b e stored
in the lo w-order four bits of the least signican t b yte of Result . The high-order four bits of the
b yte will b e stored in the lo w-order four bits of the most signican t b yte of Result .
Sample Problems
Input: Value = 5F
Output: Result = 050F
Program 7.5: nibble.s  Disassemble a byte into its high and low or der nibbles
1 ; Disassemble a byte into its high and low order nibbles
2
3 TTL Ch4Ex6 - nibble
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value ; Load the value to be disassembled
9 LDR R2, Mask ; Load the bitmask
10 MOV R3, R1, LSR #0x4 ; Copy just the high order nibble into R3
11 MOV R3, R3, LSL #0x8 ; Now left shift it one byte
12 AND R1, R1, R2 ; AND the original number with the bitmask
13 ADD R1, R1, R3 ; Add the result of that to
14 ; What we moved into R3
15 STR R1, Result ; Store the result
16 SWI &11
17
18 Value DCB &5F ; Value to be shifted
19 ALIGN ; Keep the memory boundaries
20 Mask DCW &000F ; Bitmask = %0000000000001111
21 ALIGN
22 Result DCD 0 ; Space to store result
23
24 END
This is an example of b yte manipulation. The ARM allo ws most instructions whic h op erate on
w ords also to op erate on b ytes. Th us, b y using the B sux, all the LDR instructions in Program 7.5
b ecome LDRB instructions, therefore p erforming b yte op erations. The STR instruction m ust remain,
since w e are storing a halfwor d v alue. If w e w ere only dealing with a one b yte result, w e could use
the STRB b yte v ersion of the store instruction.
Remem b er that the MOV instruction p erforms register-to-register transfers. This use of the MOV
instruction is quite frequen t.
Generally , it is more ecien t in terms of program memory usage and execution time to minimise
references to memory .
62 CHAPTER 7. D A T A MO VEMENT
7.1.6 Find Larger of T w o Num b ers
Find the larger of t w o 32-bit v ariables Value1 and Value2 . Place the result in the v ariable Result .
Assume the v alues are unsigned.
Sample Problems
a b
Input: Value1 = 12345678 12345678
Value2 = 87654321 0ABCDEF1
Output: Result = 87654321 12345678
Program 7.6: bigger.s  Find the lar ger of two numb ers
1 ; Find the larger of two numbers
2
3 TTL Ch4Ex7 - bigger
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value1 ; Load the first value to be compared
9 LDR R2, Value2 ; Load the second value to be compared
10 CMP R1, R2 ; Compare them
11 BHI Done ; If R1 contains the highest
12 MOV R1, R2 ; otherwise overwrite R1
13 Done
14 STR R1, Result ; Store the result
15 SWI &11
16
17 Value1 DCD &12345678 ; Value to be compared
18 Value2 DCD &87654321 ; Value to be compared
19 Result DCD 0 ; Space to store result
20
21 END
The Compare instruction, CMP , sets the status register ags as if the destination, R 1 , w ere sub-
tracted from the source R 2 . The order of the op erands is the same as the op erands in the subtract
instruction, SUB .
The conditional transfer instruction BHI transfers con trol to the statemen t lab eled Done if the
unsigned con ten ts of R 2 are greater than or equal to the con ten ts of R 1 . Otherwise, the next
instruction (on line 12) is executed. A t Done , register R 2 will alw a ys con tain the larger of the t w o
v alues.
The BHI instruction is one of sev eral conditional branc h instructions. T o c hange the program to
op erate on signed n um b ers, simply c hange the BHI to BGE (Branc h if Greater than or Equal to):
...
CMP R1, R2
BGE Done
...
Y ou can use the follo wing table 7.1 to use when p erforming signed and unsigned comparisons.
Note that the same instructions are used for signal and unsigned addition, subtraction, or com-
parison; ho w ev er, the comparison op erations are dieren t.
The conditional branc h instructions are an example of program coun ter relativ e addressing. In
other w ords, if the branc h condition is satised, con trol will b e transfered to an address relativ e
7.1. PR OGRAM EXAMPLES 63
Compare Condition Signed Unsigned
greater than or equal BGE BHS
greater than BGT BHI
equal BEQ BEQ
not equal BNE BNE
less than or equal BLE BLS
less than BLT BLO
T able 7.1: Signed/Unsigned Comparisons
to the curren t v alue of the program coun ter. Dealing with compares and branc hes is an imp ortan t
part of programming. Don't confuse the sense of the CMP instruction. After a compare, the relation
tested is:
DESTINA TION c ondition SOUR CE
F or examp e, if the condition is less than, then y ou test for destination less than source. Become
familiar with all of the conditions and their meanings. Unsigned compares are v ery useful when
comparing t w o addresses.
7.1.7 64-Bit A dition
A dd the con ten ts of t w o 64-bit v ariables Value1 and Value2 . Store the result in Result .
Sample Problems
Input: Value1 = 12A2E640, F2100123
Value2 = 001019BF, 40023F51
Output: Result = 12B30000, 32124074
Program 7.7: add64.s  64 bit addition
1 ; 64 bit addition
2
3 TTL Ch4Ex8 - add64
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Value1 ; Pointer to first value
9 LDR R1, [R0] ; Load first part of value1
10 LDR R2, [R0, #4] ; Load lower part of value1
11 LDR R0, =Value2 ; Pointer to second value
12 LDR R3, [R0] ; Load upper part of value2
13 LDR R4, [R0, #4] ; Load lower part of value2
14 ADDS R6, R2, R4 ; Add lower 4 bytes and set carry flag
15 ADC R5, R1, R3 ; Add upper 4 bytes including carry
16 LDR R0, =Result ; Pointer to Result
17 STR R5, [R0] ; Store upper part of result
18
19 STR R6, [R0, #4] ; Store lower part of result
20 SWI &11
21
22 Value1 DCD &12A2E640, &F2100123 ; Value to be added
23 Value2 DCD &001019BF, &40023F51 ; Value to be added
24 Result DCD 0 ; Space to store result
25
26 END
64 CHAPTER 7. D A T A MO VEMENT
Here w e in tro duce sev eral imp ortan t and p o w erful instructions from the ARM instruction set. As
b efore, at line 8 w e use the LDR instruction whic h causes register R 0 to hold the starting address
of Value1 . A t line 9 the instruction LDR R1, [R0] fetc hes the rst 4 b ytes (32-bits) of the 64-bit
v alue, starting at the lo cation p oin ted to b y R 0 and places them in the R 1 register. Line 10 loads
the second 4 b ytes or the lo w er half of the 64-bit v alue from the memro y address p oin ted to b y
R 0 plus 4 b ytes ( [R0, #4] . Bet w een them R 1 and R 2 no w hold the rst 64-bit v alue, R 1 has
the upp er half while R 2 has the lo w er half. Lines 1113 rep eat this pro cess for the second 64-bit
v alue, reading it in to R 3 and R 4 .
Next, the t w o lo w order wor d s, held in R 2 and R 4 are added, and the result stored in R 6 .
This is all straigh tforw ard, but note no w the use of the S sux to the ADD instruction. This forces
the up date of the ags as a result of the ADD op eration. In other w ords, if the result of the addition
results in a carry , the carry ag bit will b e set.
No w the ADC (add with carry) instruction is used to add the t w o high order wor d s, held in R 1 and
R 3 , but taking in to accoun t an y carry resulting from the previous addition.
Finally , the result is stored using the same tec hnique as w e used the load the v alues (lines 1618).
7.1.8 T able of F actorials
Calculate the factorial of the 8-bit v ariable Value from a table of factorials DataTable . Store the
result in the 16-bit v ariable Result . Assume Value has a v alue b et w een 0 and 7.
Sample Problems
Input: FTABLE = 0001 (0! = 1 10 )
= 0001 (1! = 1 10 )
= 0002 (2! = 2 10 )
= 0006 (3! = 6 10 )
= 0018 (4! = 24 10 )
= 0078 (5! = 120 10 )
= 02D0 (6! = 720 10 )
= 13B0 (7! = 5040 10 )
Value = 05
Output: Result = 0078 (5! = 120 10 )
Program 7.8: factorial.s  L o okup the factorial fr om a table by using the addr ess of the memory
lo c ation
1 ; Lookup the factorial from a table using the address of the memory location
2
3 TTL Ch4Ex9 - factorial
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =DataTable ; Load the address of the lookup table
9 LDR R1, Value ; Offset of value to be looked up
10 MOV R1, R1, LSL #0x2 ; Data is declared as 32bit - need
11 ; to quadruple the offset to point at the
12 ; correct memory location
13 ADD R0, R0, R1 ; R0 now contains memory address to store
14 LDR R2, [R0]
15 LDR R3, =Result ; The address where we want to store the answer
16 STR R2, [R3] ; Store the answer
17
18 SWI &11
7.2. PR OBLEMS 65
19
20 AREA DataTable, DATA
21
22 DCD 1 ;0! = 1 ; The data table containing the factorials
23 DCD 1 ;1! = 1
24 DCD 2 ;2! = 2
25 DCD 6 ;3! = 6
26 DCD 24 ;4! = 24
27 DCD 120 ;5! = 120
28 DCD 720 ;6! = 720
29 DCD 5040 ;7! = 5040
30 Value DCB 5
31 ALIGN
32 Result DCW 0
33
34 END
The approac h to this table lo okup problem, as implemen ted in this program, demonstrates the
use of oset addressing. The rst t w o LDR instructions, load register R 0 with the start address of
the lo okup table1, and register R 1 con ten ts of Value .
The actual calculation of the en try in the table is determined b y the rst op erand of the R1, R1,
LSL #0x2 instruction. The long w ord con ten ts of address register R 1 are added to the long w ord
con ten ts of data register R 0 to form the eectiv e address used to index the table en try . When R 0
is used in this manner, it is referred to as an index register.
7.2 Problems
7.2.1 64-Bit Data T ransfer
Mo v e the con ten ts of the 64-bit v ariable VALUE to the 64-bit v ariable RESULT .
Sample Problems
Input: VALUE 3E2A42A1
21F260A0
Output: RESULT 3E2A42A1
21F260A0
7.2.2 32-Bit Subtraction
Subtract the con ten ts of the 32-bit v ariable VALUE1 from the con ten ts of the 32-bit v ariable VALUE2
and store the result bac k in VALUE1 .
Sample Problems
Input: VALUE1 12343977
VALUE2 56782182
Output: VALUE1 4443E80B
7.2.3 Shift Righ t Three Bits
Shift the con ten ts of the 32-bit v ariable VALUE righ t three bits. Clear the three most signican t
bit p ostition.
1Note that w e are using a LDR instruction as the data table is sucen tly far a w a y from the instruction that an
ADR instruction is not v alid.
66 CHAPTER 7. D A T A MO VEMENT
Sample Problems
T est A T est B
Input: VALUE 415D7834 9284C15D
Output: VALUE 082BAF06 1250982B
7.2.4 Halfw ord Assem bly
Com bine the lo w four bits of eac h of the four consecutiv e b ytes b eginning at LIST in to one 16-bit
halfw ord. The v alue at LIST go es in to the most signican t nibble of the result. Store the result
in the 32-bit v ariable RESULT .
Sample Problems
Input: LIST 0C
02
06
09
Output: RESULT 0000C269
7.2.5 Find Smallest of Three Num b ers
The three 32-bit v ariables VALUE1 , VALUE2 and VALUE3 , eac h con tain an unsigned n um b er. Store
the smallest of these n um b ers in the 32-bit v ariable RESULT .
Sample Problems
Input: VALUE1 91258465
VALUE2 102C2056
VALUE3 70409254
Output: RESULT 102C2056
7.2.6 Sum of Squares
Calculate the squares of the con ten ts of w ord VALUE1 and w ord VALUE2 then add them together.
Please the result in to the w ord RESULT .
Sample Problems
Input: VALUE1 00000007
VALUE2 00000032
Output: RESULT 000009F5
That is 72+ 502= 49 + 2500 = 2549 (decimal)
or72+ 322= 31 + 9 C4 = 9F5 (hexadecimal)
7.2.7 Shift Left n bits
Shift the con ten ts of the w ord VALUE left. The n um b er of bits to shift is con tained in the w ord
COUNT . Assume that the shift coun t is less than 32. The lo w-order bits should b e cleared.
Sample Problems
T est A T est B
Input: VALUE 182B 182B
COUNT 0003 0020
Output: VALUE C158 0000
7.2. PR OBLEMS 67
In the rst case the v alue is to b e shifted left b y three bits, while in the second case the same
v alue is to b e shifted b y thirt y t w o bits.
68 CHAPTER 7. D A T A MO VEMENT
8Logic
Program 8.7a: bigger.s  Find the lar ger of two numb ers
1 ; Find the larger of two numbers
2
3 TTL Ch4Ex7 - bigger
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value1 ; Load the first value to be compared
9 LDR R2, Value2 ; Load the second value to be compared
10 CMP R1, R2 ; Compare them
11 BHI Done ; If R1 contains the highest
12 MOV R1, R2 ; otherwise overwrite R1
13 Done
14 STR R1, Result ; Store the result
15 SWI &11
16
17 Value1 DCD &12345678 ; Value to be compared
18 Value2 DCD &87654321 ; Value to be compared
19 Result DCD 0 ; Space to store result
20
21 END
Program 8.7a: add64.s  64 bit addition
1 ; 64 bit addition
2
3 TTL Ch4Ex8 - add64
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Value1 ; Pointer to first value
9 LDR R1, [R0] ; Load first part of value1
10 LDR R2, [R0, #4] ; Load lower part of value1
11 LDR R0, =Value2 ; Pointer to second value
12 LDR R3, [R0] ; Load upper part of value2
13 LDR R4, [R0, #4] ; Load lower part of value2
14 ADDS R6, R2, R4 ; Add lower 4 bytes and set carry flag
15 ADC R5, R1, R3 ; Add upper 4 bytes including carry
16 LDR R0, =Result ; Pointer to Result
17 STR R5, [R0] ; Store upper part of result
18
19 STR R6, [R0, #4] ; Store lower part of result
20 SWI &11
21
22 Value1 DCD &12A2E640, &F2100123 ; Value to be added
23 Value2 DCD &001019BF, &40023F51 ; Value to be added
24 Result DCD 0 ; Space to store result
25
26 END
69
70 CHAPTER 8. LOGIC
Program 8.7a: factorial.s  L o okup the factorial fr om a table by using the addr ess of the
memory lo c ation
1 ; Lookup the factorial from a table using the address of the memory location
2
3 TTL Ch4Ex9 - factorial
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =DataTable ; Load the address of the lookup table
9 LDR R1, Value ; Offset of value to be looked up
10 MOV R1, R1, LSL #0x2 ; Data is declared as 32bit - need
11 ; to quadruple the offset to point at the
12 ; correct memory location
13 ADD R0, R0, R1 ; R0 now contains memory address to store
14 LDR R2, [R0]
15 LDR R3, =Result ; The address where we want to store the answer
16 STR R2, [R3] ; Store the answer
17
18 SWI &11
19
20 AREA DataTable, DATA
21
22 DCD 1 ;0! = 1 ; The data table containing the factorials
23 DCD 1 ;1! = 1
24 DCD 2 ;2! = 2
25 DCD 6 ;3! = 6
26 DCD 24 ;4! = 24
27 DCD 120 ;5! = 120
28 DCD 720 ;6! = 720
29 DCD 5040 ;7! = 5040
30 Value DCB 5
31 ALIGN
32 Result DCW 0
33
34 END
9Program Loops
The program lo op is the basic structure that forces the CPU to rep eat a sequence of instructions.
Lo ops ha v e four sections:
1. The initialisation section, whic h establishes the starting v alues of coun ters, p oin ters, and
other v ariables.
2. The pro cessing section, where the actual data manipulation o ccurs. This is the section that
do es the w ork.
3. The lo op con trol section, whic h up dates coun ters and p oin ters for the next iteration.
4. The concluding section, that ma y b e needed to analyse and store the results.
The computer p erforms Sections 1 and 4 only once, while it ma y p erform Sections 2 and 3 man y
times. Therefore, the execution time of the lo op dep ends mainly on the execution time of Sections
2 and 3. Those sections should execute as quic kly as p ossible, while the execution times of Sections
1 and 4 ha v e less eect on o v erall program sp eed.
There are t ypically t w o metho ds of programming a lo op, these are
Algorithm 9.1a
Initialisation Section
Rep eat
Pro cessing Section
Lo op Con trol Section
Until task completed
Concluding Sectionthe rep eat . . . un til lo op (Algorithm 9.1a) and the while lo op
(Algorithm 9.1b). The rep eat-un til lo op results in the computer
alw a ys executing the pro cessing section of the lo op at least once.
On the other hand, the computer ma y not execute the pro cessing
section of the while lo op at all. The rep eat-un til lo op is more
natural, but the while lo op is often more ecien t and eliminates
the problem of going through the pro cessing sequence once ev en
where there is no data for it to handle.
The computer can use the lo op structure to pro cess large sets of
Algorithm 9.1b
Initialisation Section
While task incomplete
Pro cessing Section
Rep eatdata (usually called arra ys). The simplest w a y to use one se-
quence of instructions to handle an arra y of data is to ha v e the
program incremen t a register (usually an index register or stac k
p oin ter) after eac h iteration. Then the register will con tain the
address of the next elemen t in the arra y when the computer re-
p eats the sequence of instructions. The computer can then handle
arra ys of an y length with a single program.
Register indirect addressing is the k ey to the pro cessing arra ys since it allo ws y ou to v ary the
actual address of the data (the  ee ctive addr ess ) b y c hanging the con ten ts of a register. The
autoincremen ting mo de is particularly con v enien t for pro cessing arra ys since it automatically up-
dates the register for the next iteration. No additional instruction is necessary . Y ou can ev en ha v e
an automatic incremen t b y 2 or 4 if the arra y con tains 16-bit or 32-bit data or addresses.
Although our examples sho w the pro cessing of arra ys with autoincremen ting (adding 1, 2, or 4 after
eac h iteration), the pro cedure is equally v alid with auto decremen ting (subtracting 1, 2, or 4 b efore
eac h iteration). Man y programmers nd mo ving bac kw ard through an arra y somewhat a wkw ard
71
72 CHAPTER 9. PR OGRAM LOOPS
and dicult to follo w, but it is more ecien t in man y situations. The computer ob viously do es
not kno w bac kw ard from forw ard. The programmer, ho w ev er, m ust remem b er that the pro cessor
incremen ts an address register after using it but decremen ts an address register b efore using it.
This dierence aects initialisation as follo ws:
1. When mo ving forw ard through an arra y (autoincremen ting), start the register p oin ting to
the lo w est address o ccupied b y the arra y .
2. When mo ving bac kw ard through an arra y (auto decremen ting), start the register p oin ting
one step (1, 2, or 4) b ey ond the highest address o ccupied b y the arra y .
9.1 Program Examples
9.1.1 Sum of n um b ers
16-bit
Program 9.1a: sum16.s  A dd a series of 16 bit numb ers by using a table addr ess
1 * Add a series of 16 bit numbers by using a table address look-up
2
3 TTL Ch5Ex1
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Data1 ;load the address of the lookup table
9 EOR R1, R1, R1 ;clear R1 to store sum
10 LDR R2, Length ;init element count
11 Loop
12 LDR R3, [R0] ;get the data
13 ADD R1, R1, R3 ;add it to r1
14 ADD R0, R0, #+4 ;increment pointer
15 SUBS R2, R2, #0x1 ;decrement count with zero set
16 BNE Loop ;if zero flag is not set, loop
17 STR R1, Result ;otherwise done - store result
18 SWI &11
19
20 AREA Data1, DATA
21
22 Table DCW &2040 ;table of values to be added
23 ALIGN ;32 bit aligned
24 DCW &1C22
25 ALIGN
26 DCW &0242
27 ALIGN
28 TablEnd DCD 0
29
30 AREA Data2, DATA
31 Length DCW (TablEnd - Table) / 4 ;because we're having to align
32 ALIGN ;gives the loop count
33 Result DCW 0 ;storage for result
34
35 END
Program 9.1b: sum16b.s  A dd a series of 16 bit numb ers by using a table addr ess lo ok-up
1 * Add a series of 16 bit numbers by using a table address look-up
9.1. PR OGRAM EXAMPLES 73
2 * This example has nothing in the lookup table, and the program handles this
3
4 TTL Ch5Ex2
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, =Data1 ;load the address of the lookup table
10 EOR R1, R1, R1 ;clear R1 to store sum
11 LDR R2, Length ;init element count
12 CMP R2, #0
13 BEQ Done
14 Loop
15 LDR R3, [R0] ;get the data that R0 points to
16 ADD R1, R1, R3 ;add it to r1
17 ADD R0, R0, #+4 ;increment pointer
18 SUBS R2, R2, #0x1 ;decrement count with zero set
19 BNE Loop ;if zero flag is not set, loop
20 Done
21 STR R1, Result ;otherwise done - store result
22 SWI &11
23
24 AREA Data1, DATA
25
26 Table ;Table is empty
27 TablEnd DCD 0
28
29 AREA Data2, DATA
30 Length DCW (TablEnd - Table) / 4 ;because we're having to align
31 ALIGN ;gives the loop count
32 Result DCW 0 ;storage for result
33
34 END
32-bit
64-bit
9.1.2 Num b er of negativ e elemen ts
Program 9.2a: countneg.s  Sc an a series of 32 bit numb ers to nd how many ar e ne gative
1 * Scan a series of 32 bit numbers to find how many are negative
2
3 TTL Ch5Ex3
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Data1 ;load the address of the lookup table
9 EOR R1, R1, R1 ;clear R1 to store count
10 LDR R2, Length ;init element count
11 CMP R2, #0
12 BEQ Done ;if table is empty
13 Loop
14 LDR R3, [R0] ;get the data
15 CMP R3, #0
16 BPL Looptest ;skip next line if +ve or zero
17 ADD R1, R1, #1 ;increment -ve number count
18 Looptest
19 ADD R0, R0, #+4 ;increment pointer
20 SUBS R2, R2, #0x1 ;decrement count with zero set
74 CHAPTER 9. PR OGRAM LOOPS
21 BNE Loop ;if zero flag is not set, loop
22 Done
23 STR R1, Result ;otherwise done - store result
24 SWI &11
25
26 AREA Data1, DATA
27
28 Table DCD &F1522040 ;table of values to be added
29 DCD &7F611C22
30 DCD &80000242
31 TablEnd DCD 0
32
33 AREA Data2, DATA
34 Length DCW (TablEnd - Table) / 4 ;because we're having to align
35 ALIGN ;gives the loop count
36 Result DCW 0 ;storage for result
37
38 END
Program 9.2b: countneg16.s  Sc an a series of 16 bit numb ers to nd how many ar e ne gative
1 * Scan a series of 16 bit numbers to find how many are negative
2
3 TTL Ch5Ex4
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Data1 ;load the address of the lookup table
9 EOR R1, R1, R1 ;clear R1 to store count
10 LDR R2, Length ;init element count
11 CMP R2, #0
12 BEQ Done ;if table is empty
13 Loop
14 LDR R3, [R0] ;get the data
15 AND R3, R3, #0x8000 ;bit wise AND to see if the 16th
16 CMP R3, #0x8000 ;bit is 1
17 BEQ Looptest ;skip next line if zero
18 ADD R1, R1, #1 ;increment -ve number count
19 Looptest
20 ADD R0, R0, #+4 ;increment pointer
21 SUBS R2, R2, #0x1 ;decrement count with zero set
22 BNE Loop ;if zero flag is not set, loop
23 Done
24 STR R1, Result ;otherwise done - store result
25 SWI &11
26
27 AREA Data1, DATA
28
29 Table DCW &F152 ;table of values to be tested
30 ALIGN
31 DCW &7F61
32 ALIGN
33 DCW &8000
34 ALIGN
35 TablEnd DCD 0
36
37 AREA Data2, DATA
38 Length DCW (TablEnd - Table) / 4 ;because we're having to align
39 ALIGN ;gives the loop count
40 Result DCW 0 ;storage for result
41
42 END
9.1. PR OGRAM EXAMPLES 75
9.1.3 Find Maxim um V alue
Program 9.3: largest16.s  Sc an a series of 16 bit numb ers to nd the lar gest
1 * Scan a series of 16 bit numbers to find the largest
2
3 TTL Ch5Ex5
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Data1 ;load the address of the lookup table
9 EOR R1, R1, R1 ;clear R1 to store largest
10 LDR R2, Length ;init element count
11 CMP R2, #0
12 BEQ Done ;if table is empty
13 Loop
14 LDR R3, [R0] ;get the data
15 CMP R3, R1 ;bit is 1
16 BCC Looptest ;skip next line if zero
17 MOV R1, R3 ;increment -ve number count
18 Looptest
19 ADD R0, R0, #+4 ;increment pointer
20 SUBS R2, R2, #0x1 ;decrement count with zero set
21 BNE Loop ;if zero flag is not set, loop
22 Done
23 STR R1, Result ;otherwise done - store result
24 SWI &11
25
26 AREA Data1, DATA
27
28 Table DCW &A152 ;table of values to be tested
29 ALIGN
30 DCW &7F61
31 ALIGN
32 DCW &F123
33 ALIGN
34 DCW &8000
35 ALIGN
36 TablEnd DCD 0
37
38 AREA Data2, DATA
39
40 Length DCW (TablEnd - Table) / 4 ;because we're having to align
41 ALIGN ;gives the loop count
42 Result DCW 0 ;storage for result
43
44 END
9.1.4 Normalize A Binary Num b er
Program 9.4: normalize.s  Normalize a binary numb er
1 * normalize a binary number
2
3 TTL Ch5Ex6
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Data1 ;load the address of the lookup table
9 EOR R1, R1, R1 ;clear R1 to store shifts
76 CHAPTER 9. PR OGRAM LOOPS
10 LDR R3, [R0] ;get the data
11 CMP R3, R1 ;bit is 1
12 BEQ Done ;if table is empty
13 Loop
14 ADD R1, R1, #1 ;increment pointer
15 MOVS R3, R3, LSL#0x1 ;decrement count with zero set
16 BPL Loop ;if negative flag is not set, loop
17 Done
18 STR R1, Shifted ;otherwise done - store result
19 STR R3, Normal
20 SWI &11
21
22 AREA Data1, DATA
23
24 Table
25 * DCD &30001000 ;table of values to be tested
26 * DCD &00000001
27 * DCD &00000000
28 DCD &C1234567
29
30 AREA Result, DATA
31
32 Number DCD Table
33 Shifted DCB 0 ;storage for shift
34 ALIGN
35 Normal DCD 0 ;storage for result
36
37 END
9.2 Problems
9.2.1 Chec ksum of data
Calculate the c hec ksum of a series of 8-bit n um b ers. The length of the series is dened b y the
v ariable LENGTH . The lab el START indicates the start of the table. Store the c hec ksum in the
v ariable CHECKSUM . The c hec ksum is formed b y adding all the n um b ers in the list, ignoring the
carry o v er (or o v ero w).
Note: Chec ksums are often used to ensure that data has b een correctly read. A c hec ksum calcu-
lated when reading the data is compared to a c hec ksum that is stored with the data. If the t w o
c hec ksums do not agree, the system will usually indicate an error, or automatically read the data
again.
Sample Problem:
Input: LENGTH 00000003 ( Numb er of items )
START 28 ( Start of data table )
55
26
Output: CHECKSUM 28 + 55 + 26 ( Data Che cksum )
= 00101000 (28)
+ 01010101 (55)
= 01111101 (7D)
+ 00100110 (26)
= 10100011 (A3)
9.2. PR OBLEMS 77
9.2.2 Num b er of Zero, P ositiv e, and Negativ e n um b ers
Determine the n um b er of zero, p ositiv e (most signican t bit zero, but en tire n um b er not zero),
and negativ e (most signican t bit set) elemen ts in a series of signed 32-bit n um b ers. The length of
the series is dened b y the v ariable LENGTH and the starting series of n um b ers start with the START
lab el. Place the n um b er of negativ e elemen ts in v ariable NUMNEG , the n um b er of zero elemen ts in
v ariable NUMZERO and the n um b er of p ositiv e elemen ts in v ariable NUMPOS .
Sample Problem:
Input: LENGTH 6 ( Numb er of items )
START 76028326 ( Start of data table  Positive )
8D489867 ( Ne gative )
21202549 ( Positive )
00000000 ( Zer o )
E605546C ( Ne gative )
00000004 ( Positive )
Output: NUMNEG 2 ( 2 ne gative numb ers: 8D489867 and E605546C )
NUMZERO 1 ( 1 zer o value )
NUMPOS 3 ( 3 p ositive numb ers: 76028326, 21202549 and 00000004 )
9.2.3 Find Minim um
Find the smallest elemen t in a series of unsigned b ytes. The length of the series is dened b y the
v ariable LENGTH with the series starting at the START lab el. Store the minim um b yte v alue in the
NUMMIN v ariable.
Sample Problem:
Input: LENGTH 5 ( Numb er of items )
START 65 ( Start of data table )
79
15
E3
72
Output: NUMMIN 15 ( Smal lest of the ve )
9.2.4 Coun t 1 Bits
Determine the n um b er of bits whic h are set in the 32-bit v ariable NUM , storing the result in the
NUMBITS v ariable.
Sample Problem:
Input: NUM 2866B794 = 0011 1000 0110 0110 1011 0111 1001 0100
Output: NUMBITS 0F = 15
9.2.5 Find elemen t with most 1 bits
Determine whic h elemen t in a series of 32-bit n um b ers has the largest n um b er of bits set. The
length of the series is dened b y the LENGTH v ariable and the series starts with the START lab el.
Store the v alue with the most bits set in the NUM v ariable.
Sample Problem:
78 CHAPTER 9. PR OGRAM LOOPS
Input: LENGTH 5 ( Numb er of items )
START 205A15E3 (0010 0000 0101 1010 0001 0101 1101 0011  13)
256C8700 (0010 0101 0110 1100 1000 0111 0000 0000  11)
295468F2 (0010 1001 0101 0100 0110 1000 1111 0010  14)
29856779 (0010 1001 1000 0101 0110 0111 0111 1001  16)
9147592A (1001 0001 0100 0111 0101 1001 0010 1010  14)
Output: NUM 29856779 ( Numb er with most 1-bits )
10 Strings
Micropro cessors often handle data whic h represen ts prin ted c haracters rather than n umeric quan-
tities. Not only do k eyb oards, prin ters, comm unications devices, displa ys, and computer terminals
exp ect or pro vide c haracter-co ded data, but man y instrumen ts, test systems, and con trollers also
require data in this form. ASCI I (American Standard Co de for Information In terc hange) is the
most commonly used co de, but others exist.
W e use the standard sev en-bit ASCI I c haracter co des, as sho wn in T able 10.1; the c haracter co de
o ccupies the lo w-order sev en bits of the b yte, and the most signican t bit of the b yte holds a 0 or
a parit y bit.
10.1 Handling data in ASCI I
Here are some principles to remem b er in handling ASCI I-co ded data:
â€¢ The co des for the n um b ers and letters form ordered sequences. Since the ASCI I co des for
the c haracters  0  through  9  are 30 16 through 39 16 y ou can con v ert a decimal digit to the
equiv alen t ASCI I c haracters (and ASCI I to decimal) b y simple adding the ASCI I oset: 30 16
= ASCI I  0 . Since the co des for letters (41 16 through 5A 16 and 61 16 through 7A 16 ) are in
order, y ou can alphab etises strings b y sorting them according to their n umerical v alues.
â€¢ The computer do es not distinguish b et w een prin ting and non-prin ting c haracters. Only the
I/0 devices mak e that distinction.
â€¢ An ASCI I I/0 device handles data only in ASCI I. F or example, if y ou w an t an ASCI I prin ter
to prin t the digit  7 , y ou m ust send it 37 16 as the data; 07 16 will ring the b ell. Similarly ,
if a user presses the  9  k ey on an ASCI I k eyb oard, the input data will b e 39 16 ; 09 16 is the
tab k ey .
â€¢ Man y ASCI I devices do not use the en tire c haracter set. F or example, devices ma y ignore
man y con trol c haracters and ma y not prin t lo w er-case letters.
â€¢ Despite the denition of the con trol c haracters man y devices in terpret them dieren tly . F or
example they t ypically uses con trol c haracters in a sp ecial w a y to pro vide features suc h as
cursor con trol on a displa y , and to allo w soft w are con trol of c haracteristics suc h as rate of
data transmission, prin t width, and line length.
â€¢ Some widely used ASCI I con trol c haracters are:
0A16 LF line feed
0D16 CR carriage return
0816 BS bac kspace
7F16 DEL rub out or delete c haracter
79
80 CHAPTER 10. STRINGS
MSB
LSB 0 1 2 3 4 5 6 7 Con trol Characters
0 NUL DLE SP 0 @ P ` p NUL Null DLE Data link escap e
1 SOH DC1 ! 1 A Q a q SOH Start of heading DC1 Device con trol 1
2 STX DC2 " 2 B R b r STX Start of text DC2 Device con trol 2
3 ETX DC3 # 3 C S c s ETX End of text DC3 Device con trol 3
4 EOT DC4 $ 4 D T d t EOT End of tx DC4 Device con trol 4
5 ENQ NAK % 5 E U e u ENQ Enquiry NAK Negativ e ac k
6 A CK SYN & 6 F V f v A CK A c kno wledge SYN Sync hronous idle
7 BEL ETB ' 7 G W g w BEL Bell, or alarm ETB End of tx blo c k
8 BS CAN ( 8 H X h x BS Bac kspace CAN Cancel
9 HT EM ) 9 I Y i y HT Horizon tal tab EM End of medium
A LF SUB * : J Z j z LF Line feed SUB Substitute
B VT ESC + ; K [ k { VT V ertical tab ESC Escap e
C FF FS , < L \ l | FF F orm feed FS File separator
D CR GS - = M ] m } CR Carriage return GS Group separator
E SO RS . > N ^ n ~ SO Shift out RS Record separator
F SI US / ? 0 _ o DEL SI Shift in US Unit separator
SP Space DEL Delete
T able 10.1: Hexadecimal ASCI I Character Co des
â€¢ Eac h ASCI I c haracter o ccupies eigh t bits. This allo ws a large c haracter set but is w asteful
when only a few c haracters are actually b eing used. If, for example, the data consists en tirely
of decimal n um b ers, the ASCI I format (allo wing one digit p er b yte) requires t wice as m uc h
storage, comm unications capacit y , and pro cessing time as the BCD format (allo wing t w o
digits p er b yte).
The assem bler includes a feature to mak e c haracter-co ded data easy to handle, single quotation
marks around a c haracter indicate the c haracter's ASCI I v alue. F or example,
MOV R3, #'A'
is the same as
MOV R3, #0x41
The rst form is preferable for sev eral reasons. It increases the readabilit y of the instruction, it
also a v oids errors that ma y result from lo oking up a v alue in a table. The program do es not
dep end on ASCI I as the c haracter set, since the assem bler handles the con v ersion using whatev er
co de has b een designed for.
10.2 A string of c haracters
Individual c haracters on there o wn are not really all that helpful. As h umans w e need a string
of c haracters in order to form meaningful text. In assem bly programming it is normal to ha v e
to pro cess one c haracter at a time. Ho w ev er, the assem bler do es at least allo w us to store a
string of b y es (c haracters) in a friendly manner with the DCB directiv e. F or example, line 26 of
program 10.1a is:
DCB "Hello, World", CR
whic h will pro duce the follo wing binary data:
10.2. A STRING OF CHARA CTERS 81
Binary: 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 0D
T ext: H e l l o , SP W o r l d CR
Use table 10.1 to c hec k that this is correct. In order to mak e the program just that little bit more
readable, line 5 denes the lab el CR to ha v e the v alue for a Carriage Return (0D 16 ).
There are three main metho ds for handling strings: Fixed Length, T erminated, and Coun ted. It
is normal for a high lev el language to supp ort just one metho d. C / C++ and Java all supp ort the
use of Zero-T erminated strings, while P ascal and A da use coun ted strings. Although it is p ossible
to pro vide y our o wn supp ort for the alternativ e string t yp e it is seldom done. A go o d programmer
will use a mix of metho ds dep ending of the nature of the strings concerned.
10.2.1 Fixed Length Strings
A xed length string is where the string is of a predened and xed size. F or example, in a system
where it is kno wn that all strings are going to b e ten c haracters in length, w e can simply reserv e
10 b ytes for the string.
This has an immediate adv an tages in that the managemen t of the strings is simple when compared
to the alternativ e metho ds. F or example w e only need one lab el for an arra y of strings, and w e
can calculate the starting p osition of the nthstring b y a simple m ultiplication.
This adv an tage is ho w ev er also a ma jor disadv an tage. F or example a p ersons name can b e an ything
from t w o c haracters to an y n um b er of c haracters. Although it w ould b e p ossible to reserv e sucien t
space for the longest of names this amoun t of memory w ould b e required for all names, including
the t w o letter ones. This is a signican t w aist of memory .
It w ould b e p ossible to reserv e just ten c haracters for eac h name. When a t w o letter name app ears
it w ould ha v e to b e padded out with spaces in order to mak e the name ten c haracters in length.
When a name longer than ten c haracters app ears it w ould ha v e to b e truncated do wn to just ten
c haracters th us c hopping o part of the name. This requires extra pro cessing and is not en tirely
friendly to users who happ en to ha v e a long name.
When there is little memory and all the strings are kno wn in adv ance it ma y b e a go o d idea to
use xed length strings. F or example, command driv en systems tend to use a xed length strings
for the list of commands.
10.2.2 T erminated Strings
A terminated string is one that can b e of an y length and uses a sp ecial c haracter to mark the end
of the string, this c haracter is kno wn at the sentinel . F or example program 10.1a uses the carriage
return as it's sen tinel.
Ov er the y ears sev eral dieren t sen tinels ha v e b een used, these include $ (26 16 ), EOT (End of
T ext  04 16 ), CR (Carriage Return  0D 16 ), LF (Line F eed  0A 16 ) and NUL (No c haracter 
0016 ). T o da y the most commonly used sen tinel is the NUL c haracter, primarily b ecause it is used
b y C / C++ . The NUL c haracter also has a go o d feeling ab out it, as it is represen ted b y the v alue
0, has no other meaning and it is easier to detected than an y other c haracter. This is frequen tly
referred to as a Null- or Zero-T erminated string or simply as an ASCI IZ string.
The terminated string has the adv an tage that it can b e of an y length. Pro cessing the string is
fairly simply , y ou en ter in to a lo op pro cessing eac h c haracter at a time un til y ou reac h the sen tinel.
The disadv an tage is that the sen tinel c haracter can not app ear in the string. This is another reason
wh y the NUL c haracter is suc h a go o d c hoice for the sen tinel.
82 CHAPTER 10. STRINGS
10.2.3 Coun ted Strings
A coun ted string is one in whic h the rst one or t w o b yte holds the length of the string in c haracters.
Th us a coun ted string can b e of an y n um b er of c haracters up to the largest unsigned n um b er that
can b e stored in the rst b yte/w ord.
A coun ted string ma y app ear rather clumsy at rst. Ha ving the length of the string as a binary
v alue has a distinct adv an tage o v er the terminated string. It allo w the use of the coun ting instruc-
tions that ha v e b een included in man y instruction sets. This means w e can ignore the testing for
a sen tinel c haracter and simply decremen t our coun ter, this is a far faster metho d of w orking.
T o scan through an arra y of strings w e simply p oin t to the rst string, and add the length coun t
to our p oin ter to obtain the start of the next string. F or a terminated string w e w ould ha v e to
scan for the sen tinel for eac h string.
There are t w o disadv an tages with the coun ted string. The string do es ha v e a maxim um length,
255 c haracters or 64K dep ending on the size of the coun t v alue (8- or 16-bit). Although it is
normally felt that 64K should b e sucien t for most strings. The second disadv an tage is their
p erceiv ed complexit y . Man y p eople feel that the complexit y of the coun ted string out w eighs the
sp eed adv an tage.
10.3 In ternational Characters
As computing expands outside of the English sp eaking w orld w e ha v e to pro vide supp ort for
languages other than standard American. Man y Europ ean languages use letters that are not
a v ailable in standard ASCI I, for example: Ã·, Ã—, Ã¸, Ã˜, Ã¦, Ã†, Âª, ÂŠ, Ã¿, Â½, and Â¾. This is particularly
imp ortan t when dealing with names: Ã…ngstrÃ¸m, KarlstraÃ¿e or ÂŠuk asiewicz.
The ASCI I c haracter set is not ev en capable of handling English correctly . When w e b orro w a
w ord from another language w e also use it's diacritic marks (or ac c ents ). F or example I w ould
rather see pÃ¢tÃ© on a men u rather than pate. ASCI I do es not pro vide supp ort for suc h accen ts.
T o o v ercome this limitation the in ternational comm unit y has pro duced a new c haracter enco ding,
kno wn as Unic o de . In Unico de the c haracter co de is t w o b ytes long, the rst b yte indicates whic h
char acter set the c haracter comes from, while the second b yte indicates the c haracter p osition
within the c haracter set. The traditional ASCI I c haracter set is incorp orated in to Unico de as
c haracter set zero. In the revised C standard a new data t yp e of wchar w as dened to cater for
this new wide c haracter.
While Unico de is sucien t to represen t the c haracters from most mo dern languages, it is not
sucien t to represen t all the written languages of the w orld, ancien t and mo dern. Hence an
extended v ersion, kno wn as Unico de-32 is b eing dev elop ed where the c haracter set is a 23-bit
v alue (three b ytes). Unico de is a subset of Unico de-32, while ASCI I is a subset of Unico de.
Although w e do not consider Unico de y ou should b e a w are of the problem of in ternational c haracter
sets and the solution Unico de pro vides.
10.4 Program Examples
10.4.1 Length of a String of Characters
Program 10.1a: strlencr.s  Find the length of a Car age R eturn terminate d string
10.4. PR OGRAM EXAMPLES 83
1 ; Find the length of a CR terminated string
2
3 TTL Ch6Ex1 - strlencr
4
5 CR EQU 0x0D
6
7 AREA Program, CODE, READONLY
8 ENTRY
9
10 Main
11 LDR R0, =Data1 ; Load the address of the lookup table
12 EOR R1, R1, R1 ; Clear R1 to store count
13 Loop
14 LDRB R2, [R0], #1 ; Load the first byte into R2
15 CMP R2, #CR ; Is it the terminator ?
16 BEQ Done ; Yes => Stop loop
17 ADD R1, R1, #1 ; No => Increment count
18 BAL Loop ; Read next char
19
20 Done
21 STR R1, CharCount ; Store result
22 SWI &11
23
24 AREA Data1, DATA
25
26 Table
27 DCB "Hello, World", CR
28 ALIGN
29
30 AREA Result, DATA
31 CharCount
32 DCB 0 ; Storage for count
33
34 END
Program 10.1b: strlen.s  Find the length of a nul l terminate d string
1 ; Find the length of a null terminated string
2
3 TTL Ch6Ex1 - strlen
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Data1 ; Load the address of the lookup table
9 MOV R1, #-1 ; Start count at -1
10 Loop
11 ADD R1, R1, #1 ; Increment count
12 LDRB R2, [R0], #1 ; Load the first byte into R2
13 CMP R2, #0 ; Is it the terminator ?
14 BNE Loop ; No => Next char
15
16 STR R1, CharCount ; Store result
17 SWI &11
18
19 AREA Data1, DATA
20
21 Table
22 DCB "Hello, World", 0
23 ALIGN
24
25 AREA Result, DATA
26 CharCount
27 DCB 0 ; Storage for count
28
29 END
84 CHAPTER 10. STRINGS
10.4.2 Find First Non-Blank Character
Program 10.2: skipblanks.s  Find rst non-blank
1 * find the length of a string
2
3 TTL Ch6Ex3
4
5 Blank EQU " "
6 AREA Program, CODE, READONLY
7 ENTRY
8
9 Main
10 ADR R0, Data1 ;load the address of the lookup table
11 MOV R1, #Blank ;store the blank char in R1
12 Loop
13 LDRB R2, [R0], #1 ;load the first byte into R2
14 CMP R2, R1 ;is it a blank
15 BEQ Loop ;if so loop
16
17 SUB R0, R0, #1 ;otherwise done - adjust pointer
18 STR R0, Pointer ;and store it
19 SWI &11
20
21 AREA Data1, DATA
22
23 Table
24 DCB " 7 "
25 ALIGN
26
27 AREA Result, DATA
28 Pointer DCD 0 ;storage for count
29 ALIGN
30
31 END
10.4.3 Replace Leading Zeros with Blanks
Program 10.3: padzeros.s  Supr ess le ading zer os in a string
1 * supress leading zeros in a string
2
3 TTL Ch6Ex4
4
5 Blank EQU ' '
6 Zero EQU '0'
7 AREA Program, CODE, READONLY
8 ENTRY
9
10 Main
11 LDR R0, =Data1 ;load the address of the lookup table
12 MOV R1, #Zero ;store the zero char in R1
13 MOV R3, #Blank ;and the blank char in R3
14 Loop
15 LDRB R2, [R0], #1 ;load the first byte into R2
16 CMP R2, R1 ;is it a zero
17 BNE Done ;if not, done
18
10.4. PR OGRAM EXAMPLES 85
19 SUB R0, R0, #1 ;otherwise adjust the pointer
20 STRB R3, [R0] ;and store it blank char there
21 ADD R0, R0, #1 ;otherwise adjust the pointer
22 BAL Loop ;and loop
23
24 Done
25 SWI &11 ;all done
26
27 AREA Data1, DATA
28
29 Table
30 DCB "000007000"
31 ALIGN
32
33 AREA Result, DATA
34 Pointer DCD 0 ;storage for count
35 ALIGN
36
37 END
10.4.4 A dd Ev en P arit y to ASCI I Chatacters
Program 10.4: setparity.s  Set the p arity bit on a series of char acters stor e the amende d
string in R esult
1 ; Set the parity bit on a series of characters store the amended string in Result
2
3 TTL Ch6Ex5
4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, =Data1 ;load the address of the lookup table
10 LDR R5, =Pointer
11 LDRB R1, [R0], #1 ;store the string length in R1
12 CMP R1, #0
13 BEQ Done ;nothing to do if zero length
14 MainLoop
15 LDRB R2, [R0], #1 ;load the first byte into R2
16 MOV R6, R2 ;keep a copy of the original char
17 MOV R2, R2, LSL #24 ;shift so that we are dealing with msb
18 MOV R3, #0 ;zero the bit counter
19 MOV R4, #7 ;init the shift counter
20
21 ParLoop
22 MOVS R2, R2, LSL #1 ;left shift
23 BPL DontAdd ;if msb is not a one bit, branch
24 ADD R3, R3, #1 ;otherwise add to bit count
25 DontAdd
26 SUBS R4, R4, #1 ;update shift count
27 BNE ParLoop ;loop if still bits to check
28 TST R3, #1 ;is the parity even
29 BEQ Even ;if so branch
30 ORR R6, R6, #0x80 ;otherwise set the parity bit
31 STRB R6, [R5], #1 ;and store the amended char
32 BAL Check
33 Even STRB R6, [R5], #1 ;store the unamended char if even pty
34 Check SUBS R1, R1, #1 ;decrement the character count
35 BNE MainLoop
36
37 Done SWI &11
38
86 CHAPTER 10. STRINGS
39 AREA Data1, DATA
40
41 Table DCB 6 ;data table starts with byte length of string
42 DCB 0x31 ;the string
43 DCB 0x32
44 DCB 0x33
45 DCB 0x34
46 DCB 0x35
47 DCB 0x36
48
49 AREA Result, DATA
50 ALIGN
51 Pointer DCD 0 ;storage for parity characters
52
53 END
10.4.5 P attern Matc h
Program 10.5a: cstrcmp.s  Comp ar e two c ounte d strings for e quality
1 * compare two counted strings for equality
2
3 TTL Ch6Ex6
4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, =Data1 ;load the address of the lookup table
10 LDR R1, =Data2
11 LDR R2, Match ;assume strings not equal - set to -1
12 LDR R3, [R0], #4 ;store the first string length in R3
13 LDR R4, [R1], #4 ;store the second string length in R4
14 CMP R3, R4
15 BNE Done ;if they are different lengths,
16 ;they can't be equal
17 CMP R3, #0 ;test for zero length if both are
18 BEQ Same ;zero length, nothing else to do
19
20 * if we got this far, we now need to check the string char by char
21 Loop
22 LDRB R5, [R0], #1 ;character of first string
23 LDRB R6, [R1], #1 ;character of second string
24 CMP R5, R6 ;are they the same
25 BNE Done ;if not the strings are different
26 SUBS R3, R3, #1 ;use the string length as a counter
27 BEQ Same ;if we got to the end of the count
28 ;the strings are the same
29 B Loop ;not done, loop
30
31 Same MOV R2, #0 ;clear the -1 from match (0 = match)
32 Done STR R2, Match ;store the result
33 SWI &11
34
35 AREA Data1, DATA
36 Table1 DCD 3 ;data table starts with byte length of string
37 DCB "CAT" ;the string
38
39 AREA Data2, DATA
40 Table2 DCD 3 ;data table starts with byte length of string
41 DCB "CAT" ;the string
42
43 AREA Result, DATA
10.4. PR OGRAM EXAMPLES 87
44 ALIGN
45 Match DCD &FFFF ;storage for parity characters
46
47 END
Program 10.5b: strcmp.s  Comp ar e nul l terminate d strings for e quality assume that we have
no know le dge of the data structur e so we must assess the individual strings
1 ; Compare two null terminated strings for equality
2
3 TTL Ch6Ex7
4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, =Data1 ;load the address of the lookup table
10 LDR R1, =Data2
11 LDR R2, Match ;assume strings not equal, set to -1
12 MOV R3, #0 ;init register
13 MOV R4, #0
14 Count1
15 LDRB R5, [R0], #1 ;load the first byte into R5
16 CMP R5, #0 ;is it the terminator
17 BEQ Count2 ;if not, Loop
18 ADD R3, R3, #1 ;increment count
19 BAL Count1
20 Count2
21 LDRB R5, [R1], #1 ;load the first byte into R5
22 CMP R5, #0 ;is it the terminator
23 BEQ Next ;if not, Loop
24 ADD R4, R4, #1 ;increment count
25 BAL Count2
26
27 Next CMP R3, R4
28 BNE Done ;if they are different lengths,
29 ;they can't be equal
30 CMP R3, #0 ;test for zero length if both are
31 BEQ Same ;zero length, nothing else to do
32 LDR R0, =Data1 ;need to reset the lookup table
33 LDR R1, =Data2
34
35 * if we got this far, we now need to check the string char by char
36 Loop
37 LDRB R5, [R0], #1 ;character of first string
38 LDRB R6, [R1], #1 ;character of second string
39 CMP R5, R6 ;are they the same
40 BNE Done ;if not the strings are different
41 SUBS R3, R3, #1 ;use the string length as a counter
42 BEQ Same ;if we got to the end of the count
43 ;the strings are the same
44 BAL Loop ;not done, loop
45
46 Same
47 MOV R2, #0 ;clear the -1 from match (0 = match)
48 Done
49 STR R2, Match ;store the result
50 SWI &11
51
52 AREA Data1, DATA
53 Table1 DCB "Hello, World", 0 ;the string
54 ALIGN
55
56 AREA Data2, DATA
57 Table2 DCB "Hello, worl", 0 ;the string
58
88 CHAPTER 10. STRINGS
59 AREA Result, DATA
60 ALIGN
61 Match DCD &FFFF ;flag for match
62
63 END
10.5 Problems
10.5.1 Length of a T elet yp ewriter Message
Determine the length of an ASCI I message. All c haracters are 7-bit ASCI I with MSB = 0. The
string of c haracters in whic h the message is em b edded has a starting address whic h is con tained
in the START v ariable. The message itself starts with an ASCI I STX (Start of T ext) c haracter
(0216 ) and ends with ETX (End of T ext) c haracter (03 16 ). Sa v e the length of the message, the
n um b er of c haracters b et w een the STX and the ETX mark ers (but not including the mark ers) in
the LENGTH v ariable.
Sample Problem:
Input: START String ( L o c ation of string )
String 02 (STX  Start T ext )
47 ( G )
4F ( O )
03 (ETX  End T ext )
Output: LENGTH 02 (GO)
10.5.2 Find Last Non-Blank Character
Searc h a string of ASCI I c haracters for the last non-blank c haracter. Starting address of the string
is con tained in the START v ariable and the string ends with a carriage return c haracter ( 0D16 ).
Place the address of the last non-blank c haracter in the POINTER v ariable.
Sample Problems:
T est A T est B
Input: START String String
String 37 ( 7 ) 41 ( A )
0D (CR) 20 (Space)
48 ( H )
41 ( A )
54 ( T )
20 (Space)
20 (Space)
0D (CR)
Output: POINTER First Char F ourth Char
10.5.3 T runcate Decimal String to In teger F orm
Edit a string of ASCI I decimal c haracters b y replacing all digits to the righ t of the decimal p oin t
with ASCI I blanks (20 16 ). The starting address of the string is con tained in the START v ariable
and the string is assumed to consist en tirely of ASCI I-co ded decimal digits and a p ossible decimal
p oin t (2E 16 ). The length of the string is stored in the LENGTH v ariable. If no decimal p oin t app ears
in the string, assume that the decimal p oin t is at the far righ t.
10.5. PR OBLEMS 89
Sample Problems:
T est A T est B
Input: START String String
LENGTH 4 3
String 37 ( 7 ) 36 ( 6 )
2E ( . ) 37 ( 7 )
38 ( 8 ) 31 ( 1 )
31 ( 1 )
Output: 37 ( 7 ) 36 ( 6 )
2E ( . ) 37 ( 7 )
20 (Space) 31 ( 1 )
20 (Space)
Note that in the second case (T est B) the output is unc haged, as the n um b er is assumed to b e
671..
10.5.4 Chec k Ev en P arit y and ASCI I Characters
Cheek for ev en parit y in a string of ASCI I c haracters. A string's starting address is con tained in
the START v ariable. The rst w ord of the string is its length whic h is follo w ed b y the string itself.
If the parit y of all the c haracters in the string are correct, clear the PARITY v ariable; otherwise
place all ones (FFFFFFFF 16 ) in to the v ariable.
Sample Problems:
T est A T est B
Input: START String String
String 3 03
B1 (1011 0001) B1 (1011 0001)
B2 (1011 0010) B6 (1011 0110)
33 (0011 0011) 33 (0011 0011)
Output: PARITY 00000000 (T rue) FFFFFFFF (F alse)
10.5.5 String Comparison
Compare t w o strings of ASCI I c haracters to see whic h is larger (that is, whic h follo ws the other in
alphab etical ordering). Both strings ha v e the same length as dened b y the LENGTH v ariable. The
strings' starting addresses are dened b y the START1 and START2 v ariables. If the string dened
b y START1 is greater than or equal to the other string, clear the GREATER v ariable; otherwise set
the v ariable to all ones (FFFFFFFF 16 ).
Sample Problems:
T est A T est B T est C
Input: LENGTH 3 3 3
START1 String1 String1 String1
START2 String2 String2 String2
String1 43 ( C ) 43 ( C ) 43 ( C )
41 ( A ) 41 ( A ) 41 ( A )
54 ( T ) 54 ( T ) 54 ( T )
String2 42 ( B ) 52 ( C ) 52 ( C )
41 ( A ) 41 ( A ) 55 ( U )
54 ( T ) 54 ( T ) 54 ( T )
Output: GREATER 00000000 00000000 FFFFFFFF
(CA T > BA T) (CA T = CA T) (CA T < CUT)
90 CHAPTER 10. STRINGS
11 Code Conversion
Co de con v ersion is a con tin ual problem in micro computer applications. P eripherals pro vide data
in ASCI I, BCD or v arious sp ecial co des. The micro computer m ust con v ert the data in to some
standard form for pro cessing. Output devices ma y require data in ASCI I, BCD, sev en-segmen t or
other co des. Therefore, the micro computer m ust con v ert the results to the prop er form after it
completes the pro cessing.
There are sev eral w a ys to approac h co de con v ersion:
1. Some con v ersions can easily b e handled b y algorithms in v olving arithmetic or logical func-
tions. The program ma y , ho w ev er, ha v e to handle sp ecial cases separately .
2. More complex con v ersions can b e handled with lo okup tables. The lo okup table metho d
requires little programming and is easy to apply . Ho w ev er the table ma y o ccup y a large
amoun t of memory if the range of input v alues is large.
3. Hardw are is readily a v ailable for some con v ersion tasks. T ypical examples are deco ders
for BCD to sev en-segmen t con v ersion and Univ ersal Async hronous Receiv er/T ransmitters
(UAR T s) for con v ersion b et w een parallel and serial formats.
In most applications, the program should do as m uc h as p ossible of the co de con v ersion w ork.
Most co de con v ersions are easy to program and require little execution time.
11.1 Program Examples
11.1.1 Hexadecimal to ASCI I
Program 11.1a: nibtohex.s  Convert a single hex digit to its ASCII e quivalent
1 * convert a single hex digit to its ASCII equivalent
2
3 TTL Ch7Ex1
4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, Digit ;load the digit
10 LDR R1, =Result ;load the address for the result
11 CMP R0, #0xA ;is the number < 10 decimal
12 BLT Add_0 ;then branch
13
14 ADD R0, R0, #"A"-"0"-0xA ;add offset for 'A' to 'F'
15 Add_0
16 ADD R0, R0, #"0" ;convert to ASCII
17 STR R0, [R1] ;store the result
18 SWI &11
91
92 CHAPTER 11. CODE CONVERSION
19
20 AREA Data1, DATA
21 Digit
22 DCD &0C ;the hex digit
23
24 AREA Data2, DATA
25 Result DCD 0 ;storage for result
26
27 END
Program 11.1b: wordtohex.s  Convert a 32 bit hexade cimal numb er to an ASCII string and
output to the terminal
1 * now something a little more adventurous - convert a 32 bit
2 * hexadecimal number to an ASCII string and output to the terminal
3
4 TTL Ch7Ex2
5
6 AREA Program, CODE, READONLY
7 ENTRY
8 Mask EQU 0x0000000F
9
10 start
11 LDR R1, Digit ;load the digit
12 MOV R4, #8 ;init counter
13 MOV R5, #28 ;control right shift
14 MainLoop
15 MOV R3, R1 ;copy original word
16 MOV R3, R3, LSR R5 ;right shift the correct number of bits
17 SUB R5, R5, #4 ;reduce the bit shift
18 AND R3, R3, #Mask ;mask out all but the ls nibble
19 CMP R3, #0xA ;is the number < 10 decimal
20 BLT Add_0 ;then branch
21
22 ADD R3, R3, #"A"-"0"-0xA ;add offset for 'A' to 'F'
23
24 Add_0 ADD R3, R3, #"0" ;convert to ASCII
25 MOV R0, R3 ;prepare to output
26 SWI &0 ;output to console
27 SUBS R4, R4, #1 ;decrement counter
28 BNE MainLoop
29
30 MOV R0, #&0D ;add a CR character
31 SWI &0 ;output it
32 SWI &11 ;all done
33
34 AREA Data1, DATA
35 Digit DCD &DEADBEEF ;the hex word
36
37 END
11.1.2 Decimal to Sev en-Segmen t
Program 11.2: nibtoseg.s  Convert a de cimal numb er to seven se gment binary
1 * convert a decimal number to seven segment binary
2
3 TTL Ch7Ex3
4
5 AREA Program, CODE, READONLY
6 ENTRY
11.1. PR OGRAM EXAMPLES 93
7
8 Main
9 LDR R0, =Data1 ;load the start address of the table
10 EOR R1, R1, R1 ;clear register for the code
11 LDRB R2, Digit ;get the digit to encode
12 CMP R2, #9 ;is it a valid digit?
13 BHI Done ;clear the result
14
15 ADD R0, R0, R2 ;advance the pointer
16 LDRB R1, [R0] ;and get the next byte
17 Done
18 STR R1, Result ;store the result
19 SWI &11 ;all done
20
21 AREA Data1, DATA
22 Table DCB &3F ;the binary conversions table
23 DCB &06
24 DCB &5B
25 DCB &4F
26 DCB &66
27 DCB &6D
28 DCB &7D
29 DCB &07
30 DCB &7F
31 DCB &6F
32 ALIGN
33
34 AREA Data2, DATA
35 Digit DCB &05 ;the number to convert
36 ALIGN
37
38 AREA Data3, DATA
39 Result DCD 0 ;storage for result
40
41 END
11.1.3 ASCI I to Decimal
Program 11.3: dectonib.s  Convert an ASCII numeric char acter to de cimal
1 * convert an ASCII numeric character to decimal
2
3 TTL Ch7Ex4
4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 MOV R1, #-1 ;set -1 as error flag
10 LDRB R0, Char ;get the character
11 SUBS R0, R0, #"0" ;convert and check if character is < 0
12 BCC Done ;if so do nothing
13 CMP R0, #9 ;check if character is > 9
14 BHI Done ;if so do nothing
15 MOV R1, R0 ;otherwise....
16 Done
17 STR R1, Result ;.....store the decimal no
18 SWI &11 ;all done
19
20 AREA Data1, DATA
21 Char DCB &37 ;ASCII representation of 7
22 ALIGN
23
94 CHAPTER 11. CODE CONVERSION
24 AREA Data2, DATA
25 Result DCD 0 ;storage for result
26
27 END
11.1.4 Binary-Co ded Decimal to Binary
Program 11.4a: ubcdtohalf.s  Convert an unp acke d BCD numb er to binary
1 * convert an unpacked BCD number to binary
2
3 TTL Ch7Ex5
4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, =BCDNum ;load address of BCD number
10 MOV R5, #4 ;init counter
11 MOV R1, #0 ;clear result register
12 MOV R2, #0 ;and final register
13
14 Loop
15 ADD R1, R1, R1 ;multiply by 2
16 MOV R3, R1
17 MOV R3, R3, LSL #2 ;mult by 8 (2 x 4)
18 ADD R1, R1, R3 ;= mult by 10
19
20 LDRB R4, [R0], #1 ;load digit and incr address
21 ADD R1, R1, R4 ;add the next digit
22 SUBS R5, R5, #1 ;decr counter
23 BNE Loop ;if counter != 0, loop
24
25 STR R1, Result ;store the result
26 SWI &11 ;all done
27
28 AREA Data1, DATA
29 BCDNum DCB &02,&09,&07,&01 ;an unpacked BCD number
30 ALIGN
31
32 AREA Data2, DATA
33 Result DCD 0 ;storage for result
34
35 END
Program 11.4b: ubcdtohalf2.s  Convert an unp acke d BCD numb er to binary using MUL
1 * convert an unpacked BCD number to binary using MUL
2
3 TTL Ch7Ex6
4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, =BCDNum ;load address of BCD number
10 MOV R5, #4 ;init counter
11 MOV R1, #0 ;clear result register
12 MOV R2, #0 ;and final register
13 MOV R7, #10 ;multiplication constant
14
11.1. PR OGRAM EXAMPLES 95
15 Loop
16 MOV R6, R1
17 MUL R1, R6, R7 ;mult by 10
18 LDRB R4, [R0], #1 ;load digit and incr address
19 ADD R1, R1, R4 ;add the next digit
20 SUBS R5, R5, #1 ;decr counter
21 BNE Loop ;if count != 0, loop
22
23 STR R1, Result ;store the result
24 SWI &11 ;all done
25
26 AREA Data1, DATA
27 BCDNum DCB &02,&09,&07,&01 ;an unpacked BCD number
28 ALIGN
29
30 AREA Data2, DATA
31 Result DCD 0 ;storage for result
32
33 END
11.1.5 Binary Num b er to ASCI I String
Program 11.5: halftobin.s  Stor e a 16bit binary numb er as an ASCII string of '0's and '1's
1 * store a 16bit binary number as an ASCII string of '0's and '1's
2
3 TTL Ch7Ex7
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =String ;load startr address of string
9 ADD R0, R0, #16 ;adjust for length of string
10 LDRB R6, String ;init counter
11 MOV R2, #"1" ;load character '1' to register
12 MOV R3, #"0"
13 LDR R1, Number ;load the number to process
14
15 Loop
16 MOVS R1, R1, ROR #1 ;rotate right with carry
17 BCS Loopend ;if carry set branch (LSB was a '1' bit)
18 STRB R3, [R0], #-1 ;otherwise store "0"
19 BAL Decr ;and branch to counter code
20 Loopend
21 STRB R2, [R0], #-1 ;store a "1"
22 Decr
23 SUBS R6, R6, #1 ;decrement counter
24 BNE Loop ;loop while not 0
25
26 SWI &11
27
28 AREA Data1, DATA
29 Number DCD &31D2 ;a 16 bit binary number number
30 ALIGN
31
32 AREA Data2, DATA
33 String DCB 16 ;storage for result
34 ALIGN
35
36 END
96 CHAPTER 11. CODE CONVERSION
7 6 5 4 3 2 1 0
0 g f e d c b a
0 3F 0 0 1 1 1 1 1 1
1 06 0 0 0 0 0 1 1 0
2 5B 0 1 0 1 1 0 1 1
3 4F 0 1 0 0 1 1 1 1
4 66 0 1 1 0 0 1 1 0
5 6D 0 1 1 0 1 1 0 1
6 7D 0 1 1 1 1 1 0 1
7 07 0 0 0 0 0 1 1 1
8 7F 0 1 1 1 1 1 1 1
9 6F 0 1 1 0 1 1 1 1
A 77 0 1 1 1 0 1 1 1
B 7C 0 1 1 1 1 1 0 0
C 3A 0 0 1 1 1 0 0 1
D 5E 0 1 0 1 1 1 1 0
E 7A 0 1 1 1 1 0 0 1
F 71 0 1 1 1 0 0 0 1a
f b
g
e c
d
Figure 11.1: Sev en-Segmen t Displa y
11.2 Problems
11.2.1 ASCI I to Hexadecimal
Con v ert the con ten ts of the A_DIGIT v ariable from an ASCI I c haracter to a hexadecimal digit and
store the result in the H_DIGIT v ariable. Assume that A_DIGIT con tains the ASCI I represen tation
of a hexadecimal digit (7 bits with MSB=0).
Sample Problems:
T est A T est B
Input: A_DIGIT 43 ( C ) 36 ( 6 )
Output: H_DIGIT 0C 06
11.2.2 Sev en-Segmen t to Decimal
Con v ert the con ten ts of the CODE v ariable from a sev en-segmen t co de to a decimal n um b er and
store the result in the NUMBER v ariable. If CODE do es not con tain a v alid sev en-segmen t co de, set
NUMBER to FF 16 . Use the sev en-segmen t table giv en in Figure 11.1 and try to matc h co des.
Sample Problems:
T est A T est B
Input: CODE 4F 28
Output: NUMBER 03 FF
11.2.3 Decimal to ASCI I
Con v ert the con ten ts of the v ariable DIGIT from decimal digit to an ASCI I c haracter and store
the result in the v ariable CHAR . If the n um b er in DIGIT is not a decimal digit, set the con ten ts of
CHAR to an ASCI I space (20 16 ).
Sample Problems:
T est A T est B
Input: DIGIT 07 55
Output: CHAR 37 (7) 20 (Space)
11.2. PR OBLEMS 97
11.2.4 Binary to Binary-Co ded-Decimal
Con v ert the con ten ts of the v ariable NUMBER to four BCD digits in the STRING v ariable. The 32-bit
n um b er in NUMBER is unsigned and less than 10,000.
Sample Problem:
Input: NUMBER 1C52 (7250 10 )
Output: STRING 07 (7)
02 (2)
05 (5)
00 (0)
11.2.5 P ac k ed Binary-Co ded-Decimal to Binary String
Con v ert the eigh t digit pac k ed binary-co ded-decimal n um b er in the BCDNUM v ariable in to a 32-bit
n um b er in a NUMBER v ariable.
Sample Problem:
Input: BCDNUM 92529679
Output: NUMBER 0583E409 16 (92529679 10 )
11.2.6 ASCI I string to Binary n um b er
Con v ert the eigh t ASCI I c haracters in the v ariable STRING to an 8-bit binary n um b er in the
v ariable NUMBER . Clear the b yte v ariable ERROR if all the ASCI I c haracters are either ASCI I 1 or
ASCI I 0; otherwise set ERROR to all ones (FF 16 ).
Sample Problems:
T est A T est B
Input: STRING 31 (1) 31 (1)
31 (1) 31 (1)
30 (0) 30 (0)
31 (1) 31 (1)
30 (0) 30 (0)
30 (0) 37 (7)
31 (1) 31 (1)
30 (0) 30 (0)
Output: NUMBER D2 (1101 0010) 00 ( V alid )
ERROR 0 ( No Err or ) FF ( Err or )
98 CHAPTER 11. CODE CONVERSION
12 Arithmetic
Muc h of the arithmetic in some micropro cessor applications consists of m ultiple-w ord binary or
decimal manipulations. The pro cessor pro vides for decimal addition and subtraction, but do es
not pro vide for decimal m ultiplication or division, y ou m ust implemen t these op erations with
sequences of instruction.
Most pro cessors pro vide for b oth signed and unsigned binary arithmetic. Signed n um b ers are
represen ted in t w o's complemen t form. This means that the op erations of addition and subtraction
are the same whether the n um b ers are signed or unsigned.
Multiple-precision binary arithmetic requires simple rep etitions of the basic instructions. The
Carry ag transfers information b et w een w ords. It is set when an addition results in a carry or
a subtraction results in a b orro w. A dd with Carry and Subtract with Carry use this information
from the previous arithmetic op eration.
Decimal arithmetic is a common enough task for micropro cessors that most ha v e sp ecial instruc-
tions for this purp ose. These instructions ma y either p erform decimal op erations directly or correct
the results of binary op erations to the prop er decimal form. Decimal arithmetic is essen tial in
suc h applications as p oin t-of-sale terminals, c hec k pro cessors, order en try systems, and banking
terminals.
Y ou can implemen t decimal m ultiplication and division as series of additions and subtractions,
resp ectiv ely . Extra storage m ust b e reserv ed for results, since a m ultiplication pro duces a result
t wice as long as the op erands. A division con tracts the length of the result. Multiplications and
divisions are time-consuming when done in soft w are b ecause of the rep eated op erations that are
necessary .
12.1 Program Examples
12.1.2 64-Bit A ddition
Program 12.2: add64.s  64 Bit A ddition
1 * 64 bit addition
2
3 TTL 64 bit addition
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, =Value1 ; Pointer to first value
9 LDR R1, [R0] ; Load first part of value1
10 LDR R2, [R0, #4] ; Load lower part of value1
11 LDR R0, =Value2 ; Pointer to second value
12 LDR R3, [R0] ; Load upper part of value2
13 LDR R4, [R0, #4] ; Load lower part of value2
14 ADDS R6, R2, R4 ; Add lower 4 bytes and set carry flag
99
100 CHAPTER 12. ARITHMETIC
15 ADC R5, R1, R3 ; Add upper 4 bytes including carry
16 LDR R0, =Result ; Pointer to Result
17 STR R5, [R0] ; Store upper part of result
18
19 STR R6, [R0, #4] ; Store lower part of result
20 SWI &11
21
22 Value1 DCD &12A2E640, &F2100123 ; Value to be added
23 Value2 DCD &001019BF, &40023F51 ; Value to be added
24 Result DCD 0 ; Space to store result
25 END
12.1.3 Decimal A ddition
Program 12.3: addbcd.s  A dd two p acke d BCD numb ers to give a p acke d BCD r esult
1 * add two packed BCD numbers to give a packed BCD result
2
3 TTL Ch8Ex3
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Mask EQU 0x0000000F
8
9 Main
10 LDR R0, =Result ;address for storage
11 LDR R1, BCDNum1 ;load the first BCD number
12 LDR R2, BCDNum2 ;and the second
13 LDRB R8, Length ;init counter
14 ADD R0, R0, #3 ;adjust for offset
15 MOV R5, #0 ;carry
16
17 Loop
18 MOV R3, R1 ;copy what is left in the data register
19 MOV R4, R2 ;and the other number
20 AND R3, R3, #Mask ;mask out everything except low order nibble
21 AND R4, R4, #Mask ;mask out everything except low order nibble
22 MOV R1, R1, LSR #4 ;shift the original number one nibble
23 MOV R2, R2, LSR #4 ;shift the original number one nibble
24 ADD R6, R3, R4 ;add the digits
25 ADD R6, R6, R5 ;and the carry
26 CMP R6, #0xA ;is it over 10?
27 BLT RCarry1 ;if not, reset the carry to 0
28 MOV R5, #1 ;otherwise set the carry
29 SUB R6, R6, #0xA ;and subtract 10
30 B Next
31 RCarry1
32 MOV R5, #0 ;carry reset to 0
33
34 Next
35 MOV R3, R1 ;copy what is left in the data register
36 MOV R4, R2 ;and the other number
37 AND R3, R3, #Mask ;mask out everything except low order nibble
38 AND R4, R4, #Mask ;mask out everything except low order nibble
39 MOV R1, R1, LSR #4 ;shift the original number one nibble
40 MOV R2, R2, LSR #4 ;shift the original number one nibble
41 ADD R7, R3, R4 ;add the digits
42 ADD R7, R7, R5 ;and the carry
43 CMP R7, #0xA ;is it over 10?
44 BLT RCarry2 ;if not, reset the carry to 0
45 MOV R5, #1 ;otherwise set the carry
46 SUB R7, R7, #0xA ;and subtract 10
47 B Loopend
12.1. PR OGRAM EXAMPLES 101
48
49 RCarry2
50 MOV R5, #0 ;carry reset to 0
51 Loopend
52 MOV R7, R7, LSL #4 ;shift the second digit processed to the left
53 ORR R6, R6, R7 ;and OR in the first digit to the ls nibble
54 STRB R6, [R0], #-1 ;store the byte, and decrement address
55 SUBS R8, R8, #1 ;decrement loop counter
56 BNE Loop ;loop while > 0
57 SWI &11
58
59 AREA Data1, DATA
60 Length DCB &04
61 ALIGN
62 BCDNum1 DCB &36, &70, &19, &85 ;an 8 digit packed BCD number
63
64 AREA Data2, DATA
65 BCDNum2 DCB &12, &66, &34, &59 ;another 8 digit packed BCD number
66
67 AREA Data3, DATA
68 Result DCD 0 ;storage for result
69
70 END
12.1.4 Multiplication
16-Bit
Program 12.4a: mul16.s  16 bit binary multiplic ation
1 * 16 bit binary multiplication
2
3 TTL Ch8Ex1
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, Number1 ;load first number
9 LDR R1, Number2 ;and second
10 MUL R0, R1, R0 ;x:= y * x
11 * MUL R0, R0, R1 ;won't work - not allowed
12 STR R0, Result
13
14 SWI &11 ;all done
15
16 AREA Data1, DATA
17 Number1 DCD &706F ;a 16 bit binary number
18 Number2 DCD &0161 ;another
19 ALIGN
20
21 AREA Data2, DATA
22 Result DCD 0 ;storage for result
23 ALIGN
24
25 END
32-Bit
Program 12.4b: mul32.s  Multiply two 32 bit numb er to give a 64 bit r esult (c orrupts R0 and
102 CHAPTER 12. ARITHMETIC
R1)
1 * multiply two 32 bit number to give a 64 bit result
2 * (corrupts R0 and R1)
3
4 TTL Ch8Ex4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, Number1 ;load first number
10 LDR R1, Number2 ;and second
11 LDR R6, =Result ;load the address of result
12 MOV R5, R0, LSR #16 ;top half of R0
13 MOV R3, R1, LSR #16 ;top half of R1
14 BIC R0, R0, R5, LSL #16 ;bottom half of R0
15 BIC R1, R1, R3, LSL #16 ;bottom half of R1
16 MUL R2, R0, R1 ;partial result
17 MUL R0, R3, R0 ;partial result
18 MUL R1, R5, R1 ;partial result
19 MUL R3, R5, R3 ;partial result
20 ADDS R0, R1, R0 ;add middle parts
21 ADDCS R3, R3, #&10000 ;add in any carry from above
22 ADDS R2, R2, R0, LSL #16 ;LSB 32 bits
23 ADC R3, R3, R0, LSR #16 ;MSB 32 bits
24
25 STR R2, [R6] ;store LSB
26 ADD R6, R6, #4 ;increment pointer
27 STR R3, [R6] ;store MSB
28 SWI &11 ;all done
29
30 AREA Data1, DATA
31 Number1 DCD &12345678 ;a 16 bit binary number
32 Number2 DCD &ABCDEF01 ;another
33 ALIGN
34
35 AREA Data2, DATA
36 Result DCD 0 ;storage for result
37 ALIGN
38
39 END
12.1.5 32-Bit Binary Divide
Program 12.5: divide.s  Divide a 32 bit binary no by a 16 bit binary no stor e the quotient and
r emainder ther e is no 'DIV' instruction in ARM!
1 * divide a 32 bit binary no by a 16 bit binary no
2 * store the quotient and remainder
3 * there is no 'DIV' instruction in ARM!
4
5 TTL Ch8Ex2
6 AREA Program, CODE, READONLY
7 ENTRY
8
9 Main
10 LDR R0, Number1 ;load first number
11 LDR R1, Number2 ;and second
12 MOV R3, #0 ;clear register for quotient
13 Loop
14 CMP R1, #0 ;test for divide by 0
15 BEQ Err
16 CMP R0, R1 ;is the divisor less than the dividend?
17 BLT Done ;if so, finished
12.2. PR OBLEMS 103
18 ADD R3, R3, #1 ;add one to quotient
19 SUB R0, R0, R1 ;take away the number you first thought of
20 B Loop ;and loop
21 Err
22 MOV R3, #0xFFFFFFFF ;error flag (-1)
23 Done
24 STR R0, Remain ;store the remainder
25 STR R3, Quotient ;and the quotient
26 SWI &11 ;all done
27
28 AREA Data1, DATA
29 Number1 DCD &0075CBB1 ;a 16 bit binary number
30 Number2 DCD &0141 ;another
31 ALIGN
32
33 AREA Data2, DATA
34 Quotient DCD 0 ;storage for result
35 Remain DCD 0 ;storage for remainder
36 ALIGN
37
38 END
12.2 Problems
12.2.1 Multiple precision Binary subtraction
Subtract one m ultiple-w ord n um b er from another. The length in w ords of b oth n um b ers is in the
LENGTH v ariable. The n um b ers themselv es are stored (most signican t bits First) in the v ariables
NUM1 and NUM2 resp ectiv ely . Subtract the n um b er in NUM2 from the one in NUM1 . Store the
dierence in NUM1 .
Sample Problem:
Input: LENGTH 3 ( Numb er of wor ds in e ach numb er )
NUM1 2F5B8568 ( First numb er is 2F5B856884C32546706C9567 16 )
84C32546
706C9567
NUM2 14DF4098 ( The se c ond numb er is 14DF409885B81095A3BC1284 16 )
85B81095
A3BC1284
Output: NUM1 1A7C44CF ( Dier enc e is 1A7C44CFFF0B14B0CCB082E3 16 )
FF0B14B0
CCB082E3
That is,
2F5B856884C32546706C9567
âˆ’ 14DF409885B81095A3BC1284
1A7C44CFFF0B14B0CCB082E3
12.2.2 Decimal Subtraction
Subtract one pac k ed decimal (BCD) n um b er from another. The length in b ytes of b oth n um b ers
is in the b yte v ariable LENGTH . The n um b ers themselv es are in the v ariables NUM1 and NUM2 re-
sp ectiv ely . Subtract the n um b er con tained in NUM2 from the one con tained in NUM1 . Store the
dierence in NUM1 .
104 CHAPTER 12. ARITHMETIC
Sample Problem:
Input: LENGTH 4 ( Numb er of bytes in e ach numb er )
NUM1 36 ( The rst numb er is 367019857834 10 )
70
19
85
78
34
NUM2 12 ( The se c ond numb er is 126634593269 10 )
66
34
59
32
69
Output: NUM1 24 ( Dier enc e is 240385264565 10 )
03
85
26
45
65
That is,
367019857834
âˆ’ 126634593269
240385264565
12.2.3 32-Bit b y 32-Bit Multiply
Multiply the 32-bit v alue in the NUM1 v ariable b y the v alue in the NUM2 v ariable. Use the MULU
instruction and place the result in the 64-bit v ariable PROD1 .
Sample Problem:
Input: NUM1 0024 ( The rst numb er is 2468A C 16 )
68A C
NUM2 0328 ( The se c ond numb er is 3281088 10 )
1088
Output: PROD1 0000
72EC ( MULU pr o duct is 72ECB8C25B60 16 )
B8C2
5B60
PROD2 0000
72EC ( Shift pr o duct is 72ECB8C25B60 16 )
B8C2
5B60
13 Tables and Lists
T ables and lists are t w o of the basic data structures used with all computers. W e ha v e already seen
tables used to p erform co de con v ersions and arithmetic. T ables ma y also b e used to iden tify or
resp ond to commands and instructions, pro vide access to les or records, dene the meaning of k eys
or switc hes, and c ho ose among alternate programs. Lists are usually less structured than tables.
Lists ma y record tasks that the pro cessor m ust p erform, messages or data that the pro cessor m ust
record, or conditions that ha v e c hanged or should b e monitored.
13.1 Program Examples
13.1.1 A dd En try to List
Program 13.1a: insert.s  Examine a table for a match - stor e a new entry at the end if no
match found
1 * examine a table for a match - store a new entry at
2 * the end if no match found
3
4 TTL Ch9Ex1
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, List ;load the start address of the list
10 LDR R1, NewItem ;load the new item
11 LDR R3, [R0] ;copy the list counter
12 LDR R2, [R0], #4 ;init counter and increment pointer
13 LDR R4, [R0], #4
14 Loop
15 CMP R1, R4 ;does the item match the list?
16 BEQ Done ;found it - finished
17 SUBS R2, R2, #1 ;no - get the next item
18 LDR R4, [R0], #4 ;get the next item
19 BNE Loop ;and loop
20
21 SUB R0, R0, #4 ;adjust the pointer
22 ADD R3, R3, #1 ;increment the number of items
23 STR R3, Start ;and store it back
24 STR R1, [R0] ;store the new item at the end of the list
25
26 Done SWI &11
27
28 AREA Data1, DATA
29 Start DCD &4 ;length of list
30 DCD &5376 ;items
31 DCD &7615
32 DCD &138A
33 DCD &21DC
34 Store % &20 ;reserve 20 bytes of storage
105
106 CHAPTER 13. T ABLES AND LISTS
35
36 AREA Data2, DATA
37 NewItem DCD &16FA
38 List DCD Start
39
40 END
Program 13.1b: insert2.s  Examine a table for a match - stor e a new entry if no match found
extends insert.s
1 * examine a table for a match - store a new entry if no match found
2 * extends Ch9Ex1
3
4 TTL Ch9Ex2
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 Main
9 LDR R0, List ;load the start address of the list
10 LDR R1, NewItem ;load the new item
11 LDR R3, [R0] ;copy the list counter
12 LDR R2, [R0], #4 ;init counter and increment pointer
13 CMP R3, #0 ;it's an empty list
14 BEQ Insert ;so store it
15 LDR R4, [R0], #4 ;not empty - move to 1st item
16 Loop
17 CMP R1, R4 ;does the item match the list?
18 BEQ Done ;found it - finished
19 SUBS R2, R2, #1 ;no - get the next item
20 LDR R4, [R0], #4 ;get the next item
21 BNE Loop ;and loop
22
23 SUB R0, R0, #4 ;adjust the pointer
24 Insert ADD R3, R3, #1 ;incr list count
25 STR R3, Start ;and store it
26 STR R1, [R0] ;store new item at the end
27
28 Done SWI &11 ;all done
29
30 AREA Data1, DATA
31 Start DCD &4 ;length of list
32 DCD &5376 ;items
33 DCD &7615
34 DCD &138A
35 DCD &21DC
36 Store % &20 ;reserve 20 bytes of storage
37
38 AREA Data2, DATA
39 NewItem DCD &16FA
40 List DCD Start
41
42 END
13.1.2 Chec k an Ordered List
Program 13.2: search.s  Examine an or der e d table for a match
1 * examine an ordered table for a match
2
3 TTL Ch9Ex3
4 AREA Program, CODE, READONLY
13.1. PR OGRAM EXAMPLES 107
5 ENTRY
6
7 Main
8 LDR R0, =NewItem ;load the address past the list
9 SUB R0, R0, #4 ;adjust pointer to point at last element of list
10 LDR R1, NewItem ;load the item to test
11 LDR R3, Start ;init counter by reading index from list
12 CMP R3, #0 ;are there zero items
13 BEQ Missing ;zero items in list - error condition
14 LDR R4, [R0], #-4
15 Loop
16 CMP R1, R4 ;does the item match the list?
17 BEQ Done ;found it - finished
18 BHI Missing ;if the one to test is higher, it's not in the list
19 SUBS R3, R3, #1 ;no - decr counter
20 LDR R4, [R0], #-4 ;get the next item
21 BNE Loop ;and loop
22 ;if we get to here, it's not there either
23 Missing MOV R3, #0xFFFFFFFF ;flag it as missing
24
25 Done STR R3, Index ;store the index (either index or -1)
26 SWI &11 ;all done
27
28 AREA Data1, DATA
29 Start DCD &4 ;length of list
30 DCD &0000138A ;items
31 DCD &000A21DC
32 DCD &001F5376
33 DCD &09018613
34
35 AREA Data2, DATA
36 NewItem DCD &001F5376
37 Index DCW 0
38 List DCD Start
39
40 END
13.1.3 Remo v e an Elemen t from a Queue
Program 13.3: head.s  R emove the rst element of a queue
1 * remove the first element of a queue
2
3 TTL Ch9Ex4
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, Queue ;load the head of the queue
9 STR R1, Pointer ;and save it in 'Pointer'
10 CMP R0, #0 ;is it NULL?
11 BEQ Done ;if so, nothing to do
12
13 LDR R1, [R0] ;otherwise get the ptr to next
14 STR R1, Queue ;and make it the start of the queue
15
16 Done SWI &11
17
18 AREA Data1, DATA
19 Queue DCD Item1 ;pointer to the start of the queue
20 Pointer DCD 0 ;space to save the pointer
21
22 DArea % 20 ;space for new entries
108 CHAPTER 13. T ABLES AND LISTS
23
24 * each item consists of a pointer to the next item, and some data
25 Item1 DCD Item2 ;pointer
26 DCB 30, 20 ;data
27
28 Item2 DCD Item3 ;pointer
29 DCB 30, 0xFF ;data
30
31 Item3 DCD 0 ;pointer (NULL)
32 DCB 30,&87,&65 ;data
33
34 END
13.1.4 Sort a List
Program 13.4: sort.s  Sort a list of values  simple bubble sort
1 * sort a list of values - simple bubble sort
2
3 TTL Ch9Ex5
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R6, List ;pointer to start of list
9 MOV R0, #0 ;clear register
10 LDRB R0, [R6] ;get the length of list
11 MOV R8, R6 ;make a copy of start of list
12 Sort
13 ADD R7, R6, R0 ;get address of last element
14 MOV R1, #0 ;zero flag for changes
15 ADD R8, R8, #1 ;move 1 byte up the list each
16 Next ;iteration
17 LDRB R2, [R7], #-1 ;load the first byte
18 LDRB R3, [R7] ;and the second
19 CMP R2, R3 ;compare them
20 BCC NoSwitch ;branch if r2 less than r3
21
22 STRB R2, [R7], #1 ;otherwise swap the bytes
23 STRB R3, [R7] ;like this
24 ADD R1, R1, #1 ;flag that changes made
25 SUB R7, R7, #1 ;decrement address to check
26 NoSwitch
27 CMP R7, R8 ;have we checked enough bytes?
28 BHI Next ;if not, do inner loop
29 CMP R1, #0 ;did we mke changes
30 BNE Sort ;if so check again - outer loop
31
32 Done SWI &11 ;all done
33
34 AREA Data1, DATA
35 Start DCB 6
36 DCB &2A, &5B, &60, &3F, &D1, &19
37
38 AREA Data2, DATA
39 List DCD Start
40
41 END
13.2. PR OBLEMS 109
13.1.5 Using an Ordered Jump T able
13.2 Problems
13.2.1 Remo v e En try from List
Remo v e the v alue in the v ariable ITEM at a list if the v alue is presen t. The address of the list is
in the LIST v ariable. The rst en try in the list is the n um b er (in w ords) of elemen ts remaining in
the list. Mo v e en tries b elo w the one remo v ed up one p osition and reduce the length of the list b y
one.
Sample Problems:
T est A T est B
Input Output Input Output
ITEM D010257 D0102596
LIST Table Table
T able 00000004 No change 00000004 0003
2946C121 sinc e item C1212546 C1212546
2054A346 not in list D0102596 3A64422B
05723A64 3A64422B 6C20432E
12576C20 6C20432E 
13.2.2 A dd En try to Ordered List
Insert the v alue in the v ariable ITEM in to an ordered list if it is not already there. The address
of the list is in the LIST v ariable. The rst en try in the list is the list's length in w ords. The list
itself consists of unsigned binary n um b ers in increasing order. Place the new en try in the correct
p osition in the list, adjust the elemen t b elo w it do wn, and increase the length of the list b y one.
Sample Problems
T est A T est B
Input Output Input Output
ITEM 7A35B310 7A35B310
LIST T able T able
T able 00000004 0005 00000005 No change
09250037 09250037 09250037 sinc e ITEM
29567322 29567322 29567322 alr e ady in
A356A101 7A35B310 7A35B310 list.
E235C203 A356A101 A356A101
 E235C203 E235C203
13.2.3 A dd Elemen t to Queue
A dd the v alue in the v ariable ITEM to a queue. The address of the rst elemen t in the queue is
in the v ariable QUEUE . Eac h elemen t in the queue con tains a structure of t w o items ( value and
next ) where next is either the address of the next elemen t in the queue or zero if there is no next
elemen t. The new elemen t is placed at the end (tail) of the queue; the new elemen t's address will
b e in the elemen t that was at the end of the queue. The next en try of the new elemen t will con tain
zero to indicate that it is no w the end of the queue.
Sample Problem:
110 CHAPTER 13. T ABLES AND LISTS
Input Output
V alue Next V alue Next
ITEM 23854760 23854760
QUEUE 00000001 item1 00000001 item1
item1 00000123 item2 00000123 item2
item2 00123456 00000000 00123456 item3
item3   23854760 00000000
13.2.4 4-Byte Sort
Sort a list of 4-b yte en tries in to descending order. The rst three b ytes in eac h en try are an unsigned
k ey with the rst b yte b eing the most signican t. The fourth b yte is additional information and
should not b e used to determine the sort order, but should b e mo v ed along with its k ey . The
n um b er of en tries in the list is dened b y the w ord v ariable LENGTH . The list itself b egins at
lo cation LIST .
Sample Problem:
Input Output
LENGTH 00000004
LIST 414243 07 (ABC) 4A4B4C 13 (JKL)
4A4B4C 13 (JKL) 4A4B41 37 (JKA)
4A4B41 37 (JKA) 444B41 3F (DKA)
444B41 3F (DKA) 414243 07 (ABC)
13.2.5 Using a Jump T able with a Key
Using the v alue in the v ariable INDEX as a k ey to a jump table ( TABLE ). Eac h en try in the jump
table con tains a 32-bit iden tier follo w ed b y a 32-bit address to whic h the program should transfer
con trol if the k ey is equal to that iden tier.
Sample Problem:
INDEX 00000010
TABLE 00000001 Proc1
00000010 Proc2
0000001E Proc3
Proc1 NOP
Proc2 NOP
Proc3 NOP
Con trol should b e transfered to Proc2 , the second en try in the table.
14 The Stack
111
112 CHAPTER 14. THE ST A CK
15 Subroutines
None of the examples that w e ha v e sho wn th us far is a t ypical program that w ould stand b y itself. Most
real programs p erform a series of tasks, man y of whic h ma y b e used a n um b er of times or b e common to
other programs.
The standard metho d of pro ducing programs whic h can b e used in this manner is to write subroutines
that p erform particular tasks. The resulting sequences of instructions can b e written once, tested once,
and then used rep eatedly .
There are sp ecial instructions for transferring con trol to subroutines and restoring con trol to the main
program. W e often refer to the sp ecial instruction that transfers con trol to a subroutine as Call, Jump, or
Brac h to a Subroutine. The sp ecial instruction that restores con trol to the main program is usually called
Return.
In the ARM the Branc h-and-Link instruction ( BL ) is used to Branc h to a Subroutine. This sa v es the
curren t v alue of the program coun ter ( PC or R 15 ) in the Link Register ( LR or R 14 ) b efore placing the
starting address of the subroutine in the program coun ter. The ARM do es not ha v e a standard Return
from Subroutine instruction lik e other pro cessors, rather the programmer should cop y the v alue in the
Link Register in to the Program Coun ter in order to return to the instruction after the Branc h-and-Link
instruction. Th us, to return from a subroutine y ou should the instruction:
MOV PC, LR
Should the subroutine wish to call another subroutine it will ha v e to sa v e the v alue of the Link Register
b efore calling the nested subroutine.
15.1 T yp es of Subroutines
Sometimes a subroutine m ust ha v e sp ecial c haracteristics.
Relo catable
The co de can b e placed an ywhere in memory . Y ou can use suc h a subroutine easily , regardless of
other programs or the arrangemen t of the memory . A relo cating loader is necessary to place the
program in memory prop erly; the loader will start the program after other programs and will add
the starting address or relo cation constan t to all addresses in the program.
P osition Indep enden t
The co de do es not require a relo cating loader  all program addresses are expressed relativ e to the
program coun ter's curren t v alue. Data addresses are held in-registers at all times. W e will discuss
the writing of p osition indep enden t co de later in this c hapter.
Reen tran t
The subroutine can b e in terrupted and called b y the in terrupting program, giving the correct results
for b oth the in terrupting and in terrupted programs. Reen tran t subroutines are required for go o d
for ev en t based systems suc h as a m ultitasking op erating system (Windo ws or Unix) and em b edded
real time en vironmen ts. It is not dicult to mak e a subroutine reen tran t. The only requiremen t is
that the subroutine uses just registers and the stac k for its data storage, and the subroutine is self
con tained in that it do es not use an y v alue dened outside of the routine (global v alues).
Recursiv e
The subroutine can call itself. Suc h a subroutine clearly m ust also b e reen tran t.
113
114 CHAPTER 15. SUBR OUTINES
15.2 Subroutine Do cumen tation
Most programs consist of a main program and sev eral subroutines. This is useful as y ou can use kno wn pre-
written routines when a v ailable and y ou can debug and test the other subroutines prop erly and remem b er
their exact eects on registers and memory lo cations.
Y ou should pro vide sucien t do cumen tation suc h that users need not examine the subroutine's in ternal
structure. Among necessary sp ecications are:
â€¢ A description of the purp ose of the subroutine
â€¢ A list of input and output parameters
â€¢ Registers and memory lo cations used
â€¢ A sample case, p erhaps including a sample calling sequence
The subroutine will b e easy to use if y ou follo w these guidelines.
15.3 P arameter P assing T ec hniques
In order to b e really useful, a subroutine m ust b e general. F or example, a subroutine that can p erform
only a sp ecialized task, suc h as lo oking for a particular letter in an input string of xed length, will not
b e v ery useful. If, on the other hand, the subroutine can lo ok for an y letter, in strings of an y length, it
will b e far more helpful.
In order to pro vide subroutines with this exibilit y , it is necessary to pro vide them with the abilit y to
receiv e v arious kinds of information. W e call data or addresses that w e pro vide the subroutine parameters.
An imp ortan t part of writing subroutines is pro viding for transferring the parameters to the subroutine.
This pro cess is called P arameter P assing.
There are three general approac hes to passing parameters:
1. Place the parameters in registers.
2. Place the parameters in a blo c k of memory .
3. T ransfer the parameters and results on the hardw are stac k.
The registers often pro vide a fast, con v enien t w a y of passing parameters and returning results. The
limitations of this metho d are that it cannot b e expanded b ey ond the n um b er of a v ailable registers; it
often results in unforeseen side eects; and it lac ks generalit y .
The trade-o here is b et w een fast execution time and a more general approac h. Suc h a trade-o is common
in computer applications at all lev els. General approac hes are easy to learn and consisten t; they can b e
automated through the use of macros. On the other hand, approac hes that tak e adv an tage of the sp ecic
features of a particular task require less time and memory . The c hoice of one approac h o v er the other
dep ends on y our application, but y ou should tak e the general approac h (sa ving programming time and
simplifying do cumen tation and main tenance) unless time or memory constrain ts force y ou to do otherwise.
15.3.1 P assing P arameters In Registers
The rst and simplest metho d of passing parameters to a subroutine is via the registers. After calling a
subroutine, the calling program can load memory addresses, coun ters, and other data in to registers. F or
example, supp ose a subroutine op erates on t w o data buers of equal length. The subroutine migh t sp ecify
that the length of the t w o data buers b e in the register R 0 while the staring address of the t w o data
buer are in the registers R 1 and R 2 . The calling program w ould then call the subroutine as follo ws:
MOV R0, #BufferLen ; Length of Buffer in R0
LDR R1, =BufferA ; Buffer A beginning address in R1
LDR R2, =BufferB ; Buffer B beginning address in R2
BL Subr ; Call subroutine
15.3. P ARAMETER P ASSING TECHNIQUES 115
Using this metho d of parameter passing, the subroutine can simply assume that the parameters are
there. Results can also b e returned in registers, or the addresses of lo cations for results can b e passed as
parameters via the registers. Of course, this tec hnique is limited b y the n um b er of registers a v ailable.
Pro cessor features suc h as register indirect addressing, indexed addressing, and the abilit y to use an y
register as a stac k p oin ter allo w far more p o w erful and general w a ys of passing parameters.
15.3.2 P assing P arameters In A P arameter Blo c k
P arameters that are to b e passed to a subroutine can also b e placed in to memory in a parameter blo c k.
The lo cation of this parameter blo c k can b e passed to the subroutine via a register.
LDR R0, =Params ; R0 Points to Parameter Block
BL Subr ; Call the subroutine
If y ou place the parameter blo c k immediately after the subroutine call the address of the parameter
blo c k is automatically place in to the Link Register b y the Branc h and Link instruction. The subroutine
m ust mo dify the return address in the Link Register in addition to fetc hing the parameters. Using this
tec hnique, our example w ould b e mo died as follo ws:
BL Subr
DCD BufferLen ;Buffer Length
DCD BufferA ;Buffer A starting address
DCD BufferB ;Buffer B starting address
The subroutine sa v es' prior con ten ts of CPU registers, then loads parameters and adjusts the return
address as follo ws:
Subr LDR R0, [LR], #4 ; Read BuufferLen
LDR R1, [LR], #4 ; Read address of Buffer A
LDR R2, [LR], #4 ; Read address of Buffer B
; LR points to next instruction
The addressing mo de [LR], #4 will read the v alue at the address p oin ted to b y the Link Register and then
mo v e the register on b y four b ytes. Th us at the end of this sequence the v alue of LR has b een up dated to
p oin t to the next instruction after the parameter blo c k.
This parameter passing tec hnique has the adv an tage of b eing easy to read. It has, ho w ev er, the disadv an-
tage of requiring parameters to b e xe d when the program is written. P assing the address of the parameter
blo c k in via a register allo ws the papa meters to b e c hanged as the program is running.
15.3.3 P assing P arameters On The Stac k
Another common metho d of passing parameters to a subroutine is to push the parameters on to the stac k.
Using this parameter passing tec hnique, the subroutine call illustrated ab o v e w ould o ccur as follo ws:
MOV R0, #BufferLen ; Read Buffer Length
STR R0, [SP, #-4]! ; Save on the stack
LDR R0, =BufferA ; Read Address of Buffer A
STR R0, [SP, #-4]! ; Save on the stack
LDR R0, =BufferA ; Read Address of Buffer B
STR R0, [SP, #-4]! ; Save on the stack
BL Subr
The subroutine m ust b egin b y loading parameters in to CPU registers as follo ws:
Subr STMIA R12, {R0, R1, R2, R12, R14} ; save working registers to stack
LDR R0, [R12, #0] ; Buffer Length in D0
LDR R1, [R12, #4] ; Buffer A starting address
LDR R2, [R12, #8] ; Buffer B starting address
... ; Main function of subroutine
LDMIA R12, {R0, R1, R2, R12, R14} ; Recover working registers
MOV PC, LR ; Return to caller
116 CHAPTER 15. SUBR OUTINES
In this approac h, all parameters are passed and results are returned on the stac k.
The stac k gro ws do wn w ard (to w ard lo w er addresses). This o ccurs b ecause elemen ts are pushed on to the
stac k using the pre-decremen t address mo de. The use of the pre-decremen t mo de causes the stac k p oin ter
to alw a ys con tain the address of the last o ccupied lo cation, rather than the next empt y one as on some
other micropro cessors. This implies that y ou m ust initialise the stac k p oin ter to a v alue higher than the
largest address in the stac k area.
When passing parameters on the stac k, the programmer m ust implemen t this approac h as follo ws:
1. Decremen t the system stac k p oin ter to mak e ro om for parameters on the system stac k, and store
them using osets from the stac k p oin ter, or simply push the parameters on the stac k.
2. A ccess the parameters b y means of osets from the system stac k p oin ter.
3. Store the results on the stac k b y means of osets from the systems stac k p oin ter.
4. Clean up the stac k b efore or after returning from the subroutine, so that the parameters are remo v ed
and the results are handled appropriately .
15.4 T yp es Of P arameters
Regardless of our approac h to passing parameters, w e can sp ecify the parameters in a v ariet y of w a ys. F or
example, w e can:
pass-b y-v alue
Where the actual v alues are placed in the parameter list. The name comes from the fact that it is
only the v alue of the parameter that is passed in to the subroutine rather than the parameter itself.
This is the metho d used b y most high lev el programming languages.
pass-b y-reference
The address of the parameters are placed in the parameter list. The subroutine can access the v alue
directly rather than a cop y of the parameter. This is m uc h more dangerous as the subroutine can
c hange a v alue y ou don't w an t it to.
pass-b y-name
Rather than passing either the v alue or a reference to the v alue a string con taining the name of the
parameter is passed. This is used b y v ery high lev el languages or scripting languages. This is v ery
exible but rather time consuming as w e need to lo ok up the v alue asso ciated with the v ariable
name ev ery time w e wish to access the v ariable.
15.5 Program Examples
Program 15.1a: init1.s  Initiate a simple stack
1 * initiate a simple stack
2
3 TTL Ch10Ex1
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value1 ;put some data into registers
9 LDR R2, Value2
10 LDR R3, Value3
11 LDR R4, Value4
12
13 LDR R7, =Data2 ;load the top of stack
14 STMFD R7, {R1 - R4} ;push the data onto the stack
15
16 SWI &11 ;all done
15.5. PR OGRAM EXAMPLES 117
17
18 AREA Stack1, DATA
19 Value1 DCD 0xFFFF
20 Value2 DCD 0xDDDD
21 Value3 DCD 0xAAAA
22 Value4 DCD 0x3333
23
24 AREA Data2, DATA
25 Stack % 40 ;reserve 40 bytes of memory for the stack
26 StackEnd
27 DCD 0
28
29 END
Program 15.1b: init2.s  Initiate a simple stack
1 * initiate a simple stack
2
3 TTL Ch10Ex2
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R1, Value1 ;put some data into registers
9 LDR R2, Value2
10 LDR R3, Value3
11 LDR R4, Value4
12
13 LDR R7, =Data2
14 STMDB R7, {R1 - R4}
15
16 SWI &11 ;all done
17
18 AREA Stack1, DATA
19 Value1 DCD 0xFFFF
20 Value2 DCD 0xDDDD
21 Value3 DCD 0xAAAA
22 Value4 DCD 0x3333
23
24 AREA Data2, DATA
25 Stack % 40 ;reserve 40 bytes of memory for the stack
26 StackEnd
27 DCD 0
28
29 END
Program 15.1c: init3.s  Initiate a simple stack
1 * initiate a simple stack
2
3 TTL Ch10Ex3
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 StackStart EQU 0x9000
8 Main
9 LDR R1, Value1 ;put some data into registers
10 LDR R2, Value2
11 LDR R3, Value3
12 LDR R4, Value4
13
14 LDR R7, =StackStart ;Top of stack = 9000
15 STMDB R7, {R1 - R4} ;push R1-R4 onto stack
16
118 CHAPTER 15. SUBR OUTINES
17 SWI &11 ;all done
18
19 AREA Data1, DATA
20 Value1 DCD 0xFFFF ;some data to put on stack
21 Value2 DCD 0xDDDD
22 Value3 DCD 0xAAAA
23 Value4 DCD 0x3333
24
25 AREA Data2, DATA
26 ^ StackStart ;reserve 40 bytes of memory for the stack
27 Stack1 DCD 0
28
29 END
Program 15.1d: init3a.s  Initiate a simple stack
1 * initiate a simple stack
2
3 TTL Ch10Ex4
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 StackStart EQU 0x9000
8 start
9 LDR R1, Value1 ;put some data into registers
10 LDR R2, Value2
11 LDR R3, Value3
12 LDR R4, Value4
13
14 LDR R7, =StackStart ;Top of stack = 9000
15 STMDB R7, {R1 - R4} ;push R1-R4 onto stack
16
17 SWI &11 ;all done
18
19 AREA Data1, DATA
20 Value1 DCD 0xFFFF
21 Value2 DCD 0xDDDD
22 Value3 DCD 0xAAAA
23 Value4 DCD 0x3333
24
25 AREA Data2, DATA
26 ^ StackStart ;reserve 40 bytes of memory for the stack
27 Stack1 DCD 0
28
29 END
Program 15.1e: byreg.s  A simple subr outine example pr o gr am p asses a variable to the r outine in a
r e gister
1 * a simple subroutine example
2 * program passes a variable to the routine in a register
3
4 TTL Ch10Ex4
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 StackStart EQU 0x9000
9 Main
10 LDRB R0, HDigit ;variable stored to register
11 BL Hexdigit ;branch/link
12 STRB R0, AChar ;store the result of the subroutine
13 SWI &0 ;output to console
14 SWI &11 ;all done
15
15.5. PR OGRAM EXAMPLES 119
16 * =========================
17 * Hexdigit subroutine
18 * =========================
19
20 * Purpose
21 * Hexdigit subroutine converts a Hex digit to an ASCII character
22 *
23 * Initial Condition
24 * R0 contains a value in the range 00 ... 0F
25 *
26 * Final Condition
27 * R0 contains ASCII character in the range '0' ... '9' or 'A' ... 'F'
28 *
29 * Registers changed
30 * R0 only
31 *
32 * Sample case
33 * Initial condition R0 = 6
34 * Final condition R0 = 36 ('6')
35
36 Hexdigit
37 CMP R0, #0xA ;is it > 9
38 BLE Addz ;if not skip the next
39 ADD R0, R0, #"A" - "0" - 0xA ;adjust for A .. F
40
41 Addz
42 ADD R0, R0, #"0" ;convert to ASCII
43 MOV PC, LR ;return from subroutine
44
45 AREA Data1, DATA
46 HDigit DCB 6 ;digit to convert
47 AChar DCB 0 ;storage for ASCII character
48
49 END
Program 15.1f: bystack.s  A mor e c omplex subr outine example pr o gr am p asses variables to the r outine
using the stack
1 * a more complex subroutine example
2 * program passes variables to the routine using the stack
3
4 TTL Ch10Ex5
5 AREA Program, CODE, READONLY
6 ENTRY
7
8 StackStart EQU 0x9000 ;declare where top of stack will be
9 Mask EQU 0x0000000F ;bit mask for masking out lower nibble
10
11 Main
12 LDR R7, =StackStart ;Top of stack = 9000
13 LDR R0, Number ;Load number to register
14 LDR R1, =String ;load address of string
15 STR R1, [R7], #-4 ;and store it
16 STR R0, [R7], #-4 ;and store number to stack
17 BL Binhex ;branch/link
18 SWI &11 ;all done
19
20 * =========================
21 * Binhex subroutine
22 * =========================
23
24 * Purpose
25 * Binhex subroutine converts a 16 bit value to an ASCII string
26 *
27 * Initial Condition
28 * First parameter on the stack is the value
120 CHAPTER 15. SUBR OUTINES
29 * Second parameter is the address of the string
30 *
31 * Final Condition
32 * the HEX string occupies 4 bytes beginning with
33 * the address passed as the second parameter
34 *
35 * Registers changed
36 * No registers are affected
37 *
38 * Sample case
39 * Initial condition top of stack : 4CD0
40 * Address of string
41 * Final condition The string '4''C''D''0' in ASCII
42 * occupies memory
43
44 Binhex
45 MOV R8, R7 ;save stack pointer for later
46 STMDA R7, {R0-R6,R14} ;push contents of R0 to R6, and LR onto the stack
47 MOV R1, #4 ;init counter
48 ADD R7, R7, #4 ;adjust pointer
49 LDR R2, [R7], #4 ;get the number
50 LDR R4, [R7] ;get the address of the string
51 ADD R4, R4, #4 ;move past the end of where the string is to be stored
52
53 Loop
54 MOV R0, R2 ;copy the number
55 AND R0, R0, #Mask ;get the low nibble
56 BL Hexdigit ;convert to ASCII
57 STRB R0, [R4], #-1 ;store it
58 MOV R2, R2, LSR #4 ;shift to next nibble
59 SUBS R1, R1, #1 ;decr counter
60 BNE Loop ;loop while still elements left
61
62 LDMDA R8, {R0-R6,R14} ;restore the registers
63 MOV PC, LR ;return from subroutine
64
65 * =========================
66 * Hexdigit subroutine
67 * =========================
68
69 * Purpose
70 * Hexdigit subroutine converts a Hex digit to an ASCII character
71 *
72 * Initial Condition
73 * R0 contains a value in the range 00 ... 0F
74 *
75 * Final Condition
76 * R0 contains ASCII character in the range '0' ... '9' or 'A' ... 'F'
77 *
78 * Registers changed
79 * R0 only
80 *
81 * Sample case
82 * Initial condition R0 = 6
83 * Final condition R0 = 36 ('6')
84
85 Hexdigit
86 CMP R0, #0xA ;is the number 0 ... 9?
87 BLE Addz ;if so, branch
88 ADD R0, R0, #"A" - "0" - 0xA ;adjust for A ... F
89
90 Addz
91 ADD R0, R0, #"0" ;change to ASCII
92 MOV PC, LR ;return from subroutine
93
94 AREA Data1, DATA
95 Number DCD &4CD0 ;number to convert
15.5. PR OGRAM EXAMPLES 121
96 String DCB 4, 0 ;counted string for result
97
98 END
Program 15.1g: add64.s  A 64 bit addition subr outine
1 * a 64 bit addition subroutine
2
3 TTL Ch10Ex6
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 BL Add64 ;branch/link
9 DCD Value1 ;address of parameter 1
10 DCD Value2 ;address of parameter 2
11
12 SWI &11 ;all done
13
14
15 * =========================
16 * Add64 subroutine
17 * =========================
18
19 * Purpose
20 * Add two 64 bit values
21 *
22 * Initial Condition
23 * The two parameter values are passed immediately
24 * following the subroutine call
25 *
26 * Final Condition
27 * The sum of the two values is returned in R0 and R1
28 *
29 * Registers changed
30 * R0 and R1 only
31 *
32 * Sample case
33 * Initial condition
34 * para 1 = = &0420147AEB529CB8
35 * para 2 = = &3020EB8520473118
36 *
37 * Final condition
38 * R0 = &34410000
39 * R1 = &0B99CDD0
40
41 Add64
42 STMIA R12, {R2, R3, R14} ;save registers to stack
43 MOV R7, R12 ;copy stack pointer
44 SUB R7, R7, #4 ;adjust to point at LSB of 2nd value
45 LDR R3, [R7], #-4 ;load successive bytes
46 LDR R2, [R7], #-4
47 LDR R1, [R7], #-4
48 LDR R0, [R7], #-4
49
50 ADDS R1, R1, R3 ;add LS bytes & set carry flag
51 BCC Next ;branch if carry bit not set
52 ADD R0, R0, #1 ;otherwise add the carry
53 Next
54 ADD R0, R0, R2 ;add MS bytes
55 LDMIA R12, {R2, R3, R14} ;pop from stack
56 MOV PC, LR ;and return
57
58 AREA Data1, DATA
59 Value1 DCD &0420147A, &EB529CB8 ;number1 to add
60 Value2 DCD &3020EB85, &20473118 ;number2 to add
122 CHAPTER 15. SUBR OUTINES
61 END
Program 15.1h: factorial.s  A subr outine to nd the factorial of a numb er
1 * a subroutine to find the factorial of a number
2
3 TTL Ch10Ex6
4 AREA Program, CODE, READONLY
5 ENTRY
6
7 Main
8 LDR R0, Number ;get number
9 BL Factor ;branch/link
10 STR R0, FNum ;store the factorial
11
12 SWI &11 ;all done
13
14
15 * =========================
16 * Factor subroutine
17 * =========================
18
19 * Purpose
20 * Recursively find the factorial of a number
21 *
22 * Initial Condition
23 * R0 contains the number to factorial
24 *
25 * Final Condition
26 * R0 = factorial of number
27 *
28 * Registers changed
29 * R0 and R1 only
30 *
31 * Sample case
32 * Initial condition
33 * Number = 5
34 *
35 * Final condition
36 * FNum = 120 = 0x78
37
38 Factor
39 STR R0, [R12], #4 ;push to stack
40 STR R14, [R12], #4 ;push the return address
41 SUBS R0, R0, #1 ;subtract 1 from number
42 BNE F_Cont ;not finished
43
44 MOV R0, #1 ;Factorial == 1
45 SUB R12, R12, #4 ;adjust stack pointer
46 B Return ;done
47
48 F_Cont
49 BL Factor ;if not done, call again
50
51 Return
52 LDR R14, [R12], #-4 ;return address
53 LDR R1, [R12], #-4 ;load to R1 (can't do MUL R0, R0, xxx)
54 MUL R0, R1, R0 ;multiply the result
55 MOV PC, LR ;and return
56
57 AREA Data1, DATA
58 Number DCD 5 ;number
59 FNum DCD 0 ;factorial
60 END
15.6. PR OBLEMS 123
15.6 Problems
W rite b oth a calling program for the sample problem and at least one prop erly do cumen ted subroutine
for eac h problem.
15.6.1 ASCI I Hex to Binary
W rite a subroutine to con v ert the least signican t eigh t bits in register R 0 from the ASCI I represen tation
of a hexadecimal digit to the 4-bit binary represen tation of the digit. Place the result bac k in to R 0 .
Sample Problems:
T est A T est B
Input: R 0 43 `C' 36 `6'
Output: R 0 0C 06
15.6.2 ASCI I Hex String to Binary W ord
W rite a subroutine that tak es the address of a string of eigh t ASCI I c haracters in R 0 . It should con v ert
the hexadecimal string in to a 32-bit binary n um b er, whic h it return is R 0 .
Sample Problem:
Input: R 0 String
STRING 42 `B'
32 `2'
46 `F'
30 `0'
Output: R 0 0000B2F0
15.6.3 T est for Alphab etic Character
W rite a subroutine that c hec ks the c haracter in register R 0 to see if it is alphab etic (upp er- or lo w er-case).
It should set the Zero ag if the c haracter is alphab etic, and reset the ag if it is not.
Sample Problems:
T est A T est B T est C
Input: R 0 47 `G' 36 `6' 6A `j'
Output: Z FF 00 FF
15.6.4 Scan to Next Non-alphab etic
W rite a subroutien that tak es the address of the start of a text string in register R 1 and returns the
address of the rst non-alphab etic c haracter in the string in register R 1 . Y ou should consider using the
isalpha subroutine y ou ha v e just dene.
Sample Problems:
T est A B
Input: R 1 String 6100
String 43 `C' 32 `2'
61 `a' 50 `P'
74 `t' 49 `I'
0D CR 0D CR
Output: R 1 String + 4 String + 0
(CR) (2)
124 CHAPTER 15. SUBR OUTINES
15.6.5 Chec k Ev en P arit y
W rite a subroutine that tak es the address of a coun ted string in the register R 0 . It should c hec k for an
ev en n um b er of set bits in eac h c haracter of the string. If all the b ytes ha v e an ev en parit y then it should
set the Z -ag, if one or more b ytes ha v e an o dd parit y it should clear the Z -ag.
Sample Problems:
T est A T est B
Input: R 0 String String
String 03 03
47 47
AF AF
18 19
Output: Z 00 FF
Note that 19 16 is 0001 1001 2 whic h has three 1 bits and is th us has an o dd parit y .
15.6.6 Chec k the Chec ksum of a String
W rite a subroutine to calculate the 8-bit c hec ksum of the coun ted string p oin ted to b y the register R 0
and compares the calculated c hec ksum with the 8-bit c hec ksum at the end of the string. It should set the
Z -ag if the c hec ksums are equal, and reset the ag if they are not.
Sample Problems:
T est A T est B
Input: R 0 String String
String 03 (Length) 03 (Length)
41 (`A') 61 (`a')
42 (`B') 62 (`b')
43 (`C') 63 (`c')
C6 (Chec ksum) C6 ( Che cksum should b e 26</em> )
Output: Z Set Clear
15.6.7 Compare T w o Coun ted Strings
W rite a subroutine to compare t w o ASCI I strings. The rst b yte in eac h string is its length. Return the
result in the condition co des; i.e., the N -ag will b e set if the rst string is lexically less than (prior to)
the second, the Z -ag will b e set if the strings are equal, no ags are set if the second is prior to the rst.
Note that ABCD is lexically greater than ABC.
16 Interrupts and Exceptions
125
126 CHAPTER 16. INTERR UPTS AND EX CEPTIONS
AARM Instruction Deï¬nitions
This app endix describ es ev ery ARM instruction, in terms of:
Op eration
A Register T ransfer Language (R TL) / pseudo-co de description of what the instruction do es. F or
details of the register transfer language, see section ?? on page ?? .
Syn tax
<cc> Condition Co des <op1> Data Mo v emen t A ddressing Mo des <op2> Memory A ddressing
Mo des <S> Set Flags bit
Description
W ritten description of what the instruction do es. This will in terpret the formal description giv en
in the op eration part. It will also describ e an y additional notations used in the Syn tax part.
Exceptions
This giv es details of whic h exceptions can o ccur during the instruction. Prefetc h Ab ort is not listed
b ecause it can o ccur for an y instruction.
Usage
Suggestions and other information relating to ho w an instruction can b e used eectiv ely .
Condition Co des
Indicates what happ ens to the CPU Condition Co de Flags if the set ags option where to b e set.
Notes
Con tain an y additional explanation that w e can not t in to the previous categories.
App endix B pro vides a summary of the more common instructions in a more compact manner, using the
op eration section only .
ADC A dd with Carry
Op eration /angbracketleft c c/angbracketright : R dâ† R n +/angbracketleft op1/angbracketright + CPSR(C)
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax ADC/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright
Description The ADC (A dd with Carry) instruction adds the v alue of /angbracketleft op1/angbracketright and the Carry ag to the
v alue of R n and stores the result in R d . The condition co de ags are optionally up dated,
based on the result.
Usage ADC is used to syn thesize m ulti-w ord addition. If register pairs R 0 , R 1 and R 2 , R 3 hold
64-bit v alues (where R 0 and R 2 hold the least signican t w ords) the follo wing instructions
lea v e the 64-bit sum in R 4 , R 5 :
ADDS R4,R0,R2
ADC R5,R1,R3
If the second instruction is c hanged from:
ADC R5,R1,R3
127
128 A.3 Bit wise AND (AND)
to:
ADCS R5,R1,R3
the resulting v alues of the ags indicate:
N The 64-bit addition pro duced a negativ e result.
C An unsigned o v ero w o ccurred.
V A signed o v ero w o ccurred.
Z The most signican t 32 bits are all zero.
The follo wing instruction pro duces a single-bit Rotate Left with Extend op eration (33-bit
rotate through the Carry ag) on R 0 :
ADCS R0,R0,R0
See Data-pr o c essing op er ands - R otate right with extend for information on ho w to p erform
a similar rotation to the righ t.
Condition Co des
The N and Z ags are set according to the result of the addition, and the C and V ags are
set according to whether the addition generated a carry (unsigned o v ero w) and a signed
o v ero w, resp ectiv ely .
ADD A dd
Op eration /angbracketleft c c/angbracketright : R dâ† R n +/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax ADD/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright
Description A dds the v alue of /angbracketleft op1/angbracketright to the v alue of register R n , and stores the result in the destination
register R d . The condition co de ags are optionally up dated, based on the result.
Usage The ADD instruction is used to add t w o v alues together to pro duce a third.
T o incremen t a register v alue in R x use:
ADD Rx, Rx, #1
Constan t m ultiplication of R x b y2n+ 1 in to R d can b e p erformed with:
ADD Rd, Rx, Rx, LSL #n
T o form a PC-relativ e address use:
ADD Rs, PC, #offset
where the/angbracketleft oset/angbracketright m ust b e the dierence b et w een the required address and the address
held in the PC, where the PC is the address of the ADD instruction itself plus 8 b ytes.
Condition Co des
The N and Z ags are set according to the result of the addition, and the C and V ags are
set according to whether the addition generated a carry (unsigned o v ero w) and a signed
o v ero w, resp ectiv ely .
AND Bit wise AND
Op eration /angbracketleft c c/angbracketright : R dâ† R nâˆ§/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax AND/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright
Description The AND instruction p erforms a bit wise AND of the v alue of register R n with the v alue of
/angbracketleft op1/angbracketright , and stores the result in the destination register R d . The condition co de ags are
optionally up dated, based on the result.
A.4 Branc h, Branc h and Link (B, BL) 129
Usage AND is most useful for extracting a eld from a register, b y ANDing the register with a
mask v alue that has 1s in the eld to b e extracted, and 0s elsewhere.
Condition Co des
The N and Z ags are set according to the result of the op eration, and the C ag is set to
the carry output generated b y /angbracketleft op1/angbracketright (see 5.1 on page 45) The V ag is unaected.
B, BL Branc h, Branc h and Link
Op eration/angbracketleft c c/angbracketright/angbracketleft L/angbracketright : LRâ† PC + 8
/angbracketleft c c/angbracketright : PCâ† PC +/angbracketleft oset/angbracketright
Syn tax B/angbracketleft L/angbracketright/angbracketleft c c/angbracketright/angbracketleft oset/angbracketright
Description The B (Branc h) and BL (Branc h and Link) instructions cause a branc h to a target address,
and pro vide b oth conditional and unconditional c hanges to program o w.
The BL (Branc h and Link) instruction stores a return address in the link register ( LR or
R 14 ).
The/angbracketleft oset/angbracketright sp ecies the target address of the branc h. The address of the next instruction
is calculated b y adding the oset to the program coun ter ( PC ) whic h con tains the address
of the branc h instruction plus 8.
The branc h instructions can sp ecify a branc h of appro ximately Â± 32MB.
Usage The BL instruction is used to p erform a subroutine call. The return from subroutine is
ac hiev ed b y cop ying the LR to the PC . T ypically , this is done b y one of the follo wing
metho ds:
â€¢ Executing a MOV PC,R14 instruction.
â€¢ Storing a group of registers and R14 to the stac k on subroutine en try , using an in-
struction of the form:
STMFD R13!,{/angbracketleft r e gisters/angbracketright ,R14}
and then restoring the register v alues and returning with an instruction of the form:
LDMFD R13!,{/angbracketleft r e gisters/angbracketright ,PC}
Condition Co des
The condition co des are not eected b y this instruction.
Notes Branc hing bac kw ards past lo cation zero and forw ards o v er the end of the 32-bit address
space is UNPREDICT ABLE.
CMP Compare
Op eration/angbracketleft c c/angbracketright : ALU(0)â† R n -/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright : CSPRâ† ALU(Flags)
Syn tax CMP/angbracketleft c c/angbracketright R n ,/angbracketleft op1/angbracketright
Description The CMP (Compare) instruction compares a register v alue with another arithmetic v alue.
The condition ags are up dated, based on the result of subtracting /angbracketleft op1/angbracketright from R n , so that
subsequen t instructions can b e conditionally executed.
Condition Co des
The N and Z ags are set according to the result of the subtraction, and the C and V ags
are set according to whether the subtraction generated a b orro w (unsinged undero w) and
a signed o v ero w, resp ectiv ely .
130 A.7 Load Multiple (LDM)
EOR Exclusiv e OR
Op eration /angbracketleft c c/angbracketright : R dâ† R nâŠ•/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax EOR/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright
Description The EOR (Exclusiv e OR) instruction p erforms a bit wise Exclusiv e-OR of the v alue of
register R n with the v alue of /angbracketleft op1/angbracketright , and stores the result in the destination register R d .
The condition co de ags are optionally up dated, based on the result.
Usage EOR can b e used to in v ert selected bits in a register. F or eac h bit, EOR with 1 in v erts
that bit, and EOR with 0 lea v es it unc hanged.
Condition Co des
The N and Z ags are set according to the result of the op eration, and the C ag is set to
the carry output bit generated b y the shifter. The V ag is unaected.
LDM Load Multiple
Op eration if/angbracketleft c c/angbracketright
IA: addrâ† R n
IB: addrâ† R n + 4
D A: addrâ† R n - (#/angbracketleft r e gisters/angbracketright * 4) + 4
DB: addrâ† R n - (#/angbracketleft r e gisters/angbracketright * 4)
fo r each register R i in/angbracketleft r e gisters/angbracketright
IB: addrâ† addr + 4
DB: addrâ† addr - 4
R iâ† M(addr)
IA: addrâ† addr + 4
D A: addrâ† addr - 1
/angbracketleft !/angbracketright : R nâ† addr
Syn tax LDM/angbracketleft c c/angbracketright/angbracketleft mo de/angbracketright R n/angbracketleft !/angbracketright , {/angbracketleft r e gisters/angbracketright }
Description The LDM (Load Multiple) instruction is useful for blo c k loads, stac k op erations and pro-
cedure exit sequences. It loads a subset, or p ossibly all, of the general-purp ose registers
from sequen tial memory lo cations.
The general-purp ose registers loaded can include the PC . If they do, the w ord loaded for
the PC is treated as an address and a branc h o ccurs to that address.
The register R n p oin ts to the memory lo cal to load the v alues from. Eac h of the registers
listed in/angbracketleft r e gisters/angbracketright is loaded in turn, reading eac h v alue from the next memory address as
directed b y/angbracketleft mo de/angbracketright , one of:
IB Incremen t Before
DB Decremen t Before
IA Incremen t After
D A Decremen t After
The base register writebac k option ( /angbracketleft !/angbracketright ) causes the base register to b e mo died to hold the
address of the nal v alued loaded.
The register are loaded in sequence, the lo w est-n um b ered register from the lo w est memory
address, through to the highest-n um b ered register from the highest memory address.
If the PC ( R 15 ) is sp ecied in the register list, the instruction causes a branc h to the address
loaded in to the PC .
Exceptions Data Ab ort
Condition Co des
The condition co des are not eected b y this instruction.
A.8 Load Register (LDR) 131
Notes If the base register R n is sp ecied in/angbracketleft r e gisters/angbracketright , and base register writebac k is sp ecied
(/angbracketleft !/angbracketright ), the nal v alue of R n is UNPREDICT ABLE.
LDR Load Register
Op eration/angbracketleft c c/angbracketright : R dâ† M(/angbracketleft op2/angbracketright )
Syn tax LDR/angbracketleft c c/angbracketright R d ,/angbracketleft op2/angbracketright
Description The LDR (Load Register) instruction loads a w ord from the memory address calculated b y
/angbracketleft op1/angbracketright and writes it to register R d .
If the PC is sp ecied as register R d , the instruction loads a data w ord whic h it treats as an
address, then branc hes to that address.
Exceptions Data Ab ort
Usage Using the PC as the base register allo ws PC-relativ e addressing, whic h facilitates p osition-
indep enden t co de. Com bined with a suitable addressing mo de, LDR allo ws 32-bit memory
data to b e loaded in to a general-purp ose register where its v alue can b e manipulated. If
the destination register is the PC , this instruction loads a 32-bit address from memory and
branc hes to that address.
T o syn thesize a Branc h with Link, precede the LDR instruction with MOV LR, PC .
Condition Co des
The condition co des are not eected b y this instruction.
Notes If/angbracketleft op2/angbracketright sp ecies an address that is not w ord-aligned, the instruction attempts to load a
b yte. The result is UNPREDICT ABLE and the LDRB instruction should b e used.
If/angbracketleft op2/angbracketright sp ecies base register writebac k (!), and the same register is sp ecied for R d and
R n , the results are UNPREDICT ABLE.
If the PC ( R 15 ) is sp ecied for R d , the v alue m ust b e w ord alligned otherwise the result is
UNPREDICT ABLE.
LDRB Load Register Byte
Op eration/angbracketleft c c/angbracketright : R d (7:0)â† M(/angbracketleft op2/angbracketright )
/angbracketleft c c/angbracketright : R d (31:8)â† 0
Syn tax LDR/angbracketleft c c/angbracketright B R d ,/angbracketleft op2/angbracketright
Description The LDRB (Load Register Byte) instruction loads a b yte from the memory address calculated
b y/angbracketleft op2/angbracketright , zero-extends the b yte to a 32-bit w ord, and writes the w ord to register R d .
Exceptions Data Ab ort
Usage LDRB allo ws 8-bit memory data to b e loaded in to a general-purp ose register where it can
b e manipulated.
Using the PC as the base register allo ws PC-relativ e addressing, to facilitate p osition-
indep enden t co de.
Condition Co des
The condition co des are not eected b y this instruction.
Notes If the PC ( R 15 ) is sp ecied for R d , the result is UNPREDICT ABLE.
If/angbracketleft op2/angbracketright sp ecies base register writebac k (!), and the same register is sp ecied for R d and
R n , the results are UNPREDICT ABLE.
MO V Mo v e
Op eration /angbracketleft c c/angbracketright : R dâ†/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
132 A.12 Bit wise OR (ORR)
Syn tax MOV/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d ,/angbracketleft op1/angbracketright
Description The MOV (Mo v e) instruction mo v es the v alue of /angbracketleft op1/angbracketright to the destination register R d . The
condition co de ags are optionally up dated, based on the result.
Usage MOV is used to:
â€¢ Mo v e a v alue from one register to another.
â€¢ Put a constan t v alue in to a register.
â€¢ P erform a shift without an y other arithmetic or logical op eration. A left shift b y n
can b e used to m ultiply b y 2n.
â€¢ When the PC is the destination of the instruction, a branc h o ccurs. The instruction:
MOV PC, LR
can therefore b e used to return from a subroutine (see instructions B , and BL on
page 129).
Condition Co des
The N and Z ags are set according to the v alue mo v ed (p ost-shift if a shift is sp ecied),
and the C ag is set to the carry output bit generated b y the shifter (see 5.1 on page 45).
The V ag is unaected.
MVN Mo v e Negativ e
Op eration /angbracketleft c c/angbracketright : R dâ†/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax MVN/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d ,/angbracketleft op1/angbracketright
Description The MVN (Mo v e Negativ e) instruction mo v es the logical one's complemen t of the v alue of
/angbracketleft op1/angbracketright to the destination register R d . The condition co de ags are optionally up dated,
based on the result.
Usage MVN is used to:
â€¢ W rite a negativ e v alue in to a register.
â€¢ F orm a bit mask.
â€¢ T ak e the one's complemen t of a v alue.
Condition Co des
The N and Z ags are set according to the result of the op eration, and the C ag is set to
the carry output bit generated b y the shifter (see 5.1 on page 45). The V ag is unaected.
ORR Bit wise OR
Op eration /angbracketleft c c/angbracketright : R dâ† R nâˆ¨/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax ORR/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright
Description The ORR (Logical OR) instruction p erforms a bit wise (inclusiv e) OR of the v alue of register
R n with the v alue of /angbracketleft op1/angbracketright , and stores the result in the destination register R d . The
condition co de ags are optionally up dated, based on the result.
Usage ORR can b e used to set selected bits in a register. F or eac h bit, OR with 1 sets the bit, and
OR with 0 lea v es it unc hanged.
Condition Co des
The N and Z ags are set according to the result of the op eration, and the C ag is set to
the carry output bit generated b y the shifter (see 5.1 on page 45). The V ag is unaected.
A.13 Subtract with Carry (SBC) 133
SBC Subtract with Carry
Op eration /angbracketleft c c/angbracketright : R dâ† R n -/angbracketleft op1/angbracketright - NOT(CPSR(C))
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax SBC/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright
Description The SBC (Subtract with Carry) instruction is used to syn thesize m ulti-w ord subtraction.
SBC subtracts the v alue of /angbracketleft op1/angbracketright and the v alue of NOT(Carry ag) from the v alue of
register R n , and stores the result in the destination register R d . The condition co de ags
are optionally up dated, based on the result.
Usage If register pairs R 0 , R 1 and R 2 , R 3 hold 64-bit v alues ( R 0 and R 2 hold the least signican t
w ords), the follo wing instructions lea v e the 64-bit dierence in R 4 , R 5 :
SUBS R4,R0,R2
SBC R5,R1,R3
Condition Co des
The N and Z ags are set according to the result of the subtraction, and the C and V ags
are set according to whether the subtraction generated a b orro w (unsigned undero w) and
a signed o v ero w, resp ectiv ely .
Notes If/angbracketleft S/angbracketright is sp ecied, the C ag is set to:
0 if no b orro w o ccurs
1 if a b orro w do es o ccur
In other w ords, the C ag is used as a NOT(b orro w) ag. This in v ersion of the b orro w
condition is usually comp ensated for b y subsequen t instructions. F or example:
â€¢ The SBC and RSC instructions use the C ag as a NOT(b orro w) op erand, p erforming
a normal subtraction if C == 1 and subtracting one more than usual if C == 0.
â€¢ The HS (unsigned higher or same) and LO (unsigned lo w er) conditions are equiv alen t
to CS (carry set) and CC (carry clear) resp ectiv ely .
STM Store Multiple
Op eration if/angbracketleft c c/angbracketright
IA: addrâ† R n
IB: addrâ† R n + 4
D A: addrâ† R n - (#/angbracketleft r e gisters/angbracketright * 4) + 4
DB: addrâ† R n - (#/angbracketleft r e gisters/angbracketright * 4)
fo r each register R i in/angbracketleft r e gisters/angbracketright
IB: addrâ† addr + 4
DB: addrâ† addr - 4
M(addr)â† R i
IA: addrâ† addr + 4
D A: addrâ† addr - 4
/angbracketleft !/angbracketright : R nâ† addr
Syn tax STM/angbracketleft c c/angbracketright/angbracketleft mo de/angbracketright R n/angbracketleft !/angbracketright , {/angbracketleft r e gisters/angbracketright }
Description The STM (Store Multiple) instruction stores a subset (or p ossibly all) of the general-purp ose
registers to sequen tial memory lo cations.
The register R n sp ecies the base register used to store the registers. Eac h register giv en
in R registers is stored in turn, storing eac h register in the next memory address as directed
b y/angbracketleft mo de/angbracketright , whic h can b e one of:
134 A.16 Store Register Byte (STRB)
IB Incremen t Before
DB Decremen t Before
IA Incremen t After
D A Decremen t After
If the base register writebac k option ( /angbracketleft !/angbracketright ) is sp ecied, the base register ( R n ) is mo died
with the new base address.
/angbracketleft r e gisters/angbracketright is a list of registers, separated b y commas and sp ecies the set of registers to
b e stored. The registers are stored in sequence, the lo w est-n um b ered register to the lo w est
memory address, through to the highest-n um b ered register to the highest memory address.
If R 15 ( PC ) is sp ecied in/angbracketleft r e gisters/angbracketright , the v alue stored is UNKNO WN.
Exceptions Data Ab ort
Usage STM is useful as a blo c k store instruction (com bined with LDM it allo ws ecien t blo c k cop y)
and for stac k op erations. A single STM used in the sequence of a pro cedure can push the
return address and general-purp ose register v alues on to the stac k, up dating the stac k
p oin ter in the pro cess.
Condition Co des
The condition co des are not eected b y this instruction.
Notes If R 15 ( PC ) is giv en as the base register ( R n ), the result is UNPREDICT ABLE.
If R n is sp ecied as/angbracketleft r e gisters/angbracketright and base register writebac k ( /angbracketleft !/angbracketright ) is sp ecied:
â€¢ If R n is the lo w est-n um b ered register sp ecied in /angbracketleft r e gisters/angbracketright , the original v alue of R n
is stored.
â€¢ Otherwise, the stored v alue of R n is UNPREDICT ABLE.
The v alue of R n should b e w ord alligned.
STR Store Register
Op eration/angbracketleft c c/angbracketright : M(/angbracketleft op2/angbracketright )â† R d
Syn tax STR/angbracketleft c c/angbracketright R d ,/angbracketleft op2/angbracketright
Description The STR (Store Register) instruction stores a w ord from register R d to the memory address
calculated b y/angbracketleft op2/angbracketright .
Exceptions Data Ab ort
Usage Com bined with a suitable addressing mo de, STR stores 32-bit data from a general-purp ose
register in to memory . Using the PC as the base register allo ws PC-relativ e addressing,
whic h facilitates p osition-indep enden t co de.
Condition Co des
The condition co des are not eected b y this instruction.
Notes Using the PC as the source register ( R d ) will cause an UNKNO WN v alue to b e written.
If/angbracketleft op2/angbracketright sp ecies base register writebac k (!), and the same register is sp ecied for R d and
R n , the results are UNPREDICT ABLE.
The address calculated b y /angbracketleft op2/angbracketright m ust b e w ord-alligned. The result of a store to a non-
w ord-alligned address is UNPREDICT ABLE.
STRB Store Register Byte
Op eration/angbracketleft c c/angbracketright : M(/angbracketleft op2/angbracketright )â† R d (7:0)
Syn tax STR/angbracketleft c c/angbracketright B R d ,/angbracketleft op2/angbracketright
Description The STRB (Store Register Byte) instruction stores a b yte from the least signican t b yte of
register R d to the memory address calculated b y /angbracketleft op2/angbracketright .
Exceptions Data Ab ort
A.17 Subtract (SUB) 135
Usage Com bined with a suitable addressing mo de, STRB writes the least signican t b yte of a
general-purp ose register to memory . Using the PC as the base register allo ws PC-relativ e
addressing, whic h facilitates p osition-indep enden t co de.
Condition Co des
The condition co des are not eected b y this instruction.
Notes Sp ecing the PC as the source register ( R d ) is UNPREDICT ABLE.
If/angbracketleft op2/angbracketright sp ecies base register writebac k (!), and the same register is sp ecied for R d and
R n , the results are UNPREDICT ABLE.
SUB Subtract
Op eration /angbracketleft c c/angbracketright : R dâ† R n -/angbracketleft op1/angbracketright
/angbracketleft c c/angbracketright/angbracketleft S/angbracketright : CPSRâ† ALU(Flags)
Syn tax SUB/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright
Description Subtracts the v alue of /angbracketleft op1/angbracketright from the v alue of register R n , and stores the result in the
destination register R d . The condition co de ags are optionally up dated, based on the
result.
Usage SUB is used to subtract one v alue from another to pro duce a third. T o decremen t a register
v alue (in R x ) use:
SUBS Rx, Rx, #1
SUBS is useful as a lo op coun ter decremen t, as the lo op branc h can test the ags for the
appropriate termination condition, without the need for a compare instruction:
CMP Rx, #0
This b oth decremen ts the lo op coun ter in R x and c hec ks whether it has reac hed zero.
Condition Co des
The N and Z ags are set according to the result of the subtraction, and the C and V ags
are set according to whether the subtraction generated a b orro w (unsigned undero w) and
a signed o v ero w, resp ectiv ely .
Notes If/angbracketleft S/angbracketright is sp ecied, the C ag is set to:
1 if no b orro w o ccurs
0 if a b orro w do es o ccur
In other w ords, the C ag is used as a NOT(b orro w) ag. This in v ersion of the b orro w
condition is usually comp ensated for b y subsequen t instructions. F or example:
â€¢ The SBC and RSC instructions use the C ag as a NOT(b orro w) op erand, p erforming
a normal subtraction if C == 1 and subtracting one more than usual if C == 0.
â€¢ The HS (unsigned higher or same) and LO (unsigned lo w er) conditions are equiv alen t
to CS (carry set) and CC (carry clear) resp ectiv ely .
SWI Soft w are In terrupt
Op eration/angbracketleft c c/angbracketright : R 14_svcâ† PC + 8
/angbracketleft c c/angbracketright : SPSR_svcâ† CPSR
/angbracketleft c c/angbracketright : CPSR(mo de)â† Sup erviso r
/angbracketleft c c/angbracketright : CPSR(I)â† 1 (Disable Interrupts)
/angbracketleft c c/angbracketright : PCâ† 0x00000008
Syn tax SWI/angbracketleft c c/angbracketright/angbracketleft value/angbracketright
Description Causes a SWI exception (see 3.4 on page 29).
Exceptions Soft w are in terrupt
136 A.20 Sw ap Byte (SWPB)
Usage The SWI instruction is used as an op erating system service call. The metho d used to select
whic h op erating system service is required is sp ecied b y the op erating system, and the SWI
exception handler for the op erating system determines and pro vides the requested service.
T w o t ypical metho ds are:
â€¢ /angbracketleft value/angbracketright sp ecies whic h service is required, and an y parameters needed b y the selected
service are passed in general-purp ose registers.
â€¢ /angbracketleft value/angbracketright is ignored, general-purp ose register R 0 is used to select whic h service is w an ted,
and an y parameters needed b y the selected service are passed in other general-purp ose
registers.
Condition Co des
The ags will b e eected b y the op eration of the soft w are in terrupt. It is not p ossible to
sa y ho w they will b e eected. The status of the condition co de ags is unkno wn after a
soft w are in terrupt is UNKNO WN.
SWP Sw ap
Op eration/angbracketleft c c/angbracketright : ALU(0)â† M(R n )
/angbracketleft c c/angbracketright : M(R n )â† R m
/angbracketleft c c/angbracketright : R dâ† ALU(0)
Syn tax SWP/angbracketleft c c/angbracketright R d , R m , [ R n ]
Description Sw aps a w ord b et w een registers and memory . SWP loads a w ord from the memory address
giv en b y the v alue of register R n . The v alue of register R m is then stored to the memory
address giv en b y the v alue of R n , and the original loaded v alue is written to register R d . If
the same register is sp ecied for R d and R m , this instruction sw aps the v alue of the register
and the v alue at the memory address.
Exceptions Data Ab ort
Usage The SWP instruction can b e used to implemen t semaphores. F or sample co de, see Semaphor e
instructions .
Condition Co des
The condition co des are not eected b y this instruction.
Notes If the address con tained in R n is non w ord-aligned the eect is UNPREDICT ABLE.
If the PC is sp ecied as the destination ( R d ), address ( R n ) or the v alue ( R m ), the result is
UNPREDICT ABLE.
If the same register is sp ecied as /angbracketleft R n/angbracketright and/angbracketleft R m/angbracketright , or/angbracketleft R n/angbracketright and/angbracketleft R d/angbracketright , the result is UNPRE-
DICT ABLE.
If a data ab ort is signaled on either the load access or the store access, the loaded v alue is
not written to/angbracketleft R d/angbracketright . If a data ab ort is signaled on the load access, the store access do es
not o ccur.
SWPB Sw ap Byte
Op eration/angbracketleft c c/angbracketright : ALU(0)â† M(R n )
/angbracketleft c c/angbracketright : M(R n )â† R m (7:0)
/angbracketleft c c/angbracketright : R d (7:0)â† ALU(0)
Syn tax SWP/angbracketleft c c/angbracketright B R d , R m , [ R n ]
Description Sw aps a b yte b et w een registers and memory . SWPB loads a b yte from the memory address
giv en b y the v alue of register R n . The v alue of the least signican t b yte of register R m is
stored to the memory address giv en b y R n , the original loaded v alue is zero-extended to a
32-bit w ord, and the w ord is written to register R d . If the same register is sp ecied for R d
and R m , this instruction sw aps the v alue of the least signican t b yte of the register and
the b yte v alue at the memory address.
A.20 Sw ap Byte (SWPB) 137
Exceptions Data Ab ort
Usage The SWPB instruction can b e used to implemen t semaphores, in a similar manner to that
sho wn for SWP instructions in Semaphor e instructions .
Condition Co des
The condition co des are not eected b y this instruction.
Notes If the PC is sp ecied for R d , R n , or R m , the result is UNPREDICT ABLE.
If the same register is sp ecied as R n and R m , or R n and R d , the result is UNPRE-
DICT ABLE.
If a data ab ort is signaled on either the load access or the store access, the loaded v alue is
not written to/angbracketleft R d/angbracketright . If a data ab ort is signaled on the load access, the store access do es
not o ccur.
138 A.20 Sw ap Byte (SWPB)
BARM Instruction Summary
c c: Condition Co des
Generic Unsigne d Signe d
CS Carry Set HI Higer Than GT Greater Than
CC Carry Clear HS Higer or Same GE Greater Than or Equal
EQ Equal (Zero Set) LO Lo w er Than L T Less Than
NE Not Equal (Zero Clear) LS Lo w er Than or Same LE Less Than or Equal
VS Ov ero w Set MI Min us (Negativ e)
V C Ov ero w Clear PL Plus (P ositiv e)
op1: Data A c c ess
Immediate #/angbracketleft value/angbracketright /angbracketleft op1/angbracketrightâ† IR(v alue)
Register R m /angbracketleft op1/angbracketrightâ† R m
Logical Shift Left Immediate R m , LSL #/angbracketleft value/angbracketright /angbracketleft op1/angbracketrightâ† R m/lessmuch IR(v alue)
Logical Shift Left Register R m , LSL R s/angbracketleft op1/angbracketrightâ† R m/lessmuch R s (7:0)
Logical Shift Righ t Immediate R m , LSR #/angbracketleft value/angbracketright /angbracketleft op1/angbracketrightâ† R m/greatermuch IR(v alue)
Logical Shift Righ t Register R m , LSR R s/angbracketleft op1/angbracketrightâ† R m/greatermuch R s (7:0)
Arithmetic Shift Righ t Immediate R m , ASR #/angbracketleft value/angbracketright /angbracketleft op1/angbracketrightâ† R m+/greatermuch IR(v alue)
Arithmetic Shift Righ t Register R m , ASR R s/angbracketleft op1/angbracketrightâ† R m+/greatermuch R s (7:0)
Rotate Righ t Immediate R m , ROR #/angbracketleft value/angbracketright /angbracketleft op1/angbracketrightâ† R m>/greatermuch/angbracketleft value/angbracketright
Rotate Righ t Register R m , ROR R s/angbracketleft op1/angbracketrightâ† R m>/greatermuch R s (4:0)
Rotate Righ t with Extend R m , RRX /angbracketleft op1/angbracketrightâ† CPSR(C) >/greatermuch R m>/greatermuch CPSR(C)
op2: Memory A c c ess
Immediate Oset [ R n , #Â±/angbracketleft value/angbracketright ] /angbracketleft op2/angbracketrightâ† R n + IR(v alue)
Register Oset [ R n , R m ] /angbracketleft op2/angbracketrightâ† R n + R m
Scaled Register Oset [/angbracketleft R n/angbracketright , R m ,/angbracketleft shift/angbracketright #/angbracketleft value/angbracketright ]/angbracketleft op2/angbracketrightâ† R n + ( R m shift IR(v alue))
Immediate Pre-indexed [ R n , #Â±/angbracketleft value/angbracketright ]! /angbracketleft op2/angbracketrightâ† R n + IR(v alue)
R nâ†/angbracketleft op2/angbracketright
Register Pre-indexed [ R n , R m ]! /angbracketleft op2/angbracketrightâ† R n + R m
R nâ†/angbracketleft op2/angbracketright
Scaled Register Pre-indexed [ R n , R m ,/angbracketleft shift/angbracketright #/angbracketleft value/angbracketright ]!/angbracketleft op2/angbracketrightâ† R n + ( R m shift IR(v alue))
R nâ†/angbracketleft op2/angbracketright
Immediate P ost-indexed [ R n ], #Â±/angbracketleft value/angbracketright /angbracketleft op2/angbracketrightâ† R n
R nâ† R n + IR(v alue)
Register P ost-indexed [ R n ], R m /angbracketleft op2/angbracketrightâ† R n
R nâ† R n + R m
Scaled Register P ost-indexed [ R n ], R m ,/angbracketleft shift/angbracketright #/angbracketleft value/angbracketright /angbracketleft op2/angbracketrightâ† R n
R nâ† R n + R m shift IR(v alue)
Where/angbracketleft shift/angbracketright is one of: LSL , LSR , ASR , ROR or RRX and has the same eect as for /angbracketleft op1/angbracketright
139
140 APPENDIX B. ARM INSTR UCTION SUMMAR Y
ARM Instructions
A dd with Carry ADC/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ† R n +/angbracketleft op1/angbracketright + CPSR(C)
A dd ADD/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ† R n +/angbracketleft op1/angbracketright
Bit wise AND AND/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ† R n &/angbracketleft op1/angbracketright
Branc h B/angbracketleft c c/angbracketright /angbracketleft oset/angbracketright /angbracketleft c c/angbracketright : PCâ† PC +/angbracketleft oset/angbracketright
Branc h and Link BL/angbracketleft c c/angbracketright /angbracketleft oset/angbracketright /angbracketleft c c/angbracketright : LRâ† PC + 8
/angbracketleft c c/angbracketright : PCâ† PC +/angbracketleft oset/angbracketright
Compare CMP/angbracketleft c c/angbracketright R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : CSPRâ† ( R n -/angbracketleft op1/angbracketright )
Exclusiv e OR EOR/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ† R nâŠ•/angbracketleft op1/angbracketright
Load Register LDR/angbracketleft c c/angbracketright R d ,/angbracketleft op2/angbracketright /angbracketleft c c/angbracketright : R dâ† M(/angbracketleft op2/angbracketright )
Load Register Byte LDR/angbracketleft c c/angbracketright B R d ,/angbracketleft op2/angbracketright /angbracketleft c c/angbracketright : R d (7:0)â† M(/angbracketleft op2/angbracketright )
/angbracketleft c c/angbracketright : R d (31:8)â† 0
Mo v e MOV/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ†/angbracketleft op1/angbracketright
Mo v e Negativ e MVN/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ†/angbracketleft op1/angbracketright
Bit wise OR ORR/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ† R n |/angbracketleft op1/angbracketright
Subtract with Carry SBC/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ† R n -/angbracketleft op1/angbracketright - CPSR(C)
Store Register STR/angbracketleft c c/angbracketright R d ,/angbracketleft op2/angbracketright /angbracketleft c c/angbracketright : M(/angbracketleft op2/angbracketright )â† R d
Store Register Byte STR/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d ,/angbracketleft op2/angbracketright /angbracketleft c c/angbracketright : M(/angbracketleft op2/angbracketright )â† R d (7:0)
Subtract SUB/angbracketleft c c/angbracketright/angbracketleft S/angbracketright R d , R n ,/angbracketleft op1/angbracketright /angbracketleft c c/angbracketright : R dâ† R n -/angbracketleft op1/angbracketright
Soft w are In terrupt SWI/angbracketleft c c/angbracketright /angbracketleft value/angbracketright
Sw ap SWP/angbracketleft c c/angbracketright R d , R m , [ R n ]/angbracketleft c c/angbracketright : R dâ† M( R n )
/angbracketleft c c/angbracketright : M( R n )â† R m
Sw ap Byte SWP/angbracketleft c c/angbracketright B R d , R m , [ R n ]/angbracketleft c c/angbracketright : R d (7:0)â† M( R n )(7:0)
/angbracketleft c c/angbracketright : M( R n )(7:0)â† R m (7:0)
Index
Characters
ASCI I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
In ternational . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
Unico de . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
Condition Co des . . . . . . . . . . . 2829, 3132, 4243
Carry Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Mnemonics . . . . . . . . . . . . . . . . . . . . . . . . . 31, 42
Negativ e Flag . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Ov ero w Flag . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Zero Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2930
Data Ab ort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
F ast In terrupt . . . . . . . . . . . . . . . . . . . . . . . . . . 30
In terrupt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
Prefetc h Ab ort . . . . . . . . . . . . . . . . . . . . . . . . . 30
Reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Soft w are In terrupt . . . . . . . . . . . . . . . . . . . . . . 29
Undened . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
Instructions
ADC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
ADD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
AND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
B, BL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
CMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
EOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
LDM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
LDR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
LDRB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
MO V . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
MVN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
ORR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
SBC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
STM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
STR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
STRB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
SUB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
SWI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
SWP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
SWPB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
Programs
add.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
add2.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5960
add64.s . . . . . 6364, 6970, 99100, 121122
addb cd.s . . . . . . . . . . . . . . . . . . . . . . . . . . 100101
bigger.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62, 69
b yreg.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118119b ystac k.s . . . . . . . . . . . . . . . . . . . . . . . . . . 119121
coun tneg.s . . . . . . . . . . . . . . . . . . . . . . . . . . 7374
coun tneg16.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
cstrcmp.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 8687
dectonib.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 9394
divide.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 102103
factorial.s . . . . . . . . . . . . . . . . . . . 6465, 70, 122
halftobin.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
head.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107108
init1.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116117
init2.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
init3.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117118
init3a.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
insert.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 105106
insert2.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
in v ert.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
largest16.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
mo v e16.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
m ul16.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
m ul32.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 101102
nibble.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
nibtohex.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 9192
nibtoseg.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 9293
normalize.s . . . . . . . . . . . . . . . . . . . . . . . . . . 7576
padzeros.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 8485
searc h.s . . . . . . . . . . . . . . . . . . . . . . . . . . . 106107
setparit y .s . . . . . . . . . . . . . . . . . . . . . . . . . . . 8586
shiftleft.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6061
skipblanks.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
sort.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
strcmp.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8788
strlen.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8384
strlencr.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8283
sum16.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
sum16b.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7273
ub cdtohalf.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
ub cdtohalf2.s . . . . . . . . . . . . . . . . . . . . . . . . 9495
w ordtohex.s . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2528
General Purp ose ( R 0  R 12 ) . . . . . . . . . . . . . 25
Link Register ( LR / R 14 ) . . . . . . . . . . . . . . . . 27
Program Coun ter ( PC / R 15 ) . . . . . . . . . . . . 27
Stac k P oin ter ( SP / R 13 ) . . . . . . . . . . . . . . . . 26
Status Register ( CPSR / SPSR ) . . . . . . . . . . 28
Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8082
Coun ted . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
Fixed Length . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
141
142 INDEX
T erminated . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
                </div>
                <div class="page-info">
                    <p>Pages: 156 | Uploaded: 2025-08-31 22:50</p>
                </div>
            </div>
        </body>
        </html>
        